<!DOCTYPE html><html lang="zh-CN"><head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="referrer" content="no-referrer">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 5.4.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/pikaqiu-32x32-next.ico">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/pikaqiu-32x32-next.ico">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">





  
  
  

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"henfy233.github.io","root":"/","scheme":"Gemini","version":"7.8.0","exturl":true,"sidebar":{"position":"right","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":true,"show_result":true,"style":"defaul"},"back2top":{"enable":true,"sidebar":true,"scrollpercent":true},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":true,"mediumzoom":false,"lazyload":true,"pangu":true,"comments":{"style":"tabs","active":"gitalk","storage":true,"lazyload":true,"nav":{"gitalk":{"order":-2}},"activeClass":"gitalk"},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":true,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},"path":"search.xml"};
  </script>

  <meta name="description" content="介绍目前常见前端面试题，参考链接 https://interview2.poetries.top/">
<meta property="og:type" content="article">
<meta property="og:title" content="JS">
<meta property="og:url" content="http://henfy233.github.io/2022/08/16/JS/index.html">
<meta property="og:site_name" content="Henfy-Blog">
<meta property="og:description" content="介绍目前常见前端面试题，参考链接 https://interview2.poetries.top/">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://raw.githubusercontent.com/henfy233/picgo/main/img/2.png">
<meta property="og:image" content="https://raw.githubusercontent.com/henfy233/picgo/main/img/20210414155100.png">
<meta property="og:image" content="https://raw.githubusercontent.com/henfy233/picgo/main/img/112.png">
<meta property="og:image" content="https://raw.githubusercontent.com/henfy233/picgo/main/img/105.png">
<meta property="og:image" content="https://raw.githubusercontent.com/henfy233/picgo/main/img/20210414142754.png">
<meta property="og:image" content="https://s.poetries.work/images/20210414100319.png">
<meta property="og:image" content="https://s.poetries.work/uploads/2022/08/d1451162abd9747e.png">
<meta property="og:image" content="https://s.poetries.work/uploads/2022/08/ef508139131f6abc.png">
<meta property="og:image" content="https://s.poetries.work/uploads/2022/08/e2a1fe0d0aa4d4fd.png">
<meta property="og:image" content="https://s.poetries.work/uploads/2022/08/ee6a489b7e87ef0f.png">
<meta property="og:image" content="https://s.poetries.work/gitee/2020/09/101.png">
<meta property="og:image" content="https://raw.githubusercontent.com/henfy233/picgo/main/img/7.png">
<meta property="og:image" content="https://s.poetries.work/gitee/2020/07/8.png">
<meta property="og:image" content="https://s.poetries.work/gitee/2020/07/9.png">
<meta property="og:image" content="https://s.poetries.work/gitee/2020/07/10.png">
<meta property="og:image" content="https://s.poetries.work/gitee/2020/07/11.png">
<meta property="og:image" content="https://s.poetries.work/gitee/2020/07/12.png">
<meta property="og:image" content="https://s.poetries.work/gitee/2020/07/13.png">
<meta property="og:image" content="https://s.poetries.work/gitee/2020/07/14.png">
<meta property="og:image" content="https://s.poetries.work/gitee/2020/07/15.png">
<meta property="og:image" content="https://s.poetries.work/gitee/2020/07/16.png">
<meta property="article:published_time" content="2022-08-16T15:06:07.000Z">
<meta property="article:modified_time" content="2022-08-19T14:54:19.858Z">
<meta property="article:author" content="henfy">
<meta property="article:tag" content="面试">
<meta property="article:tag" content="前端">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://raw.githubusercontent.com/henfy233/picgo/main/img/2.png">

<link rel="canonical" href="http://henfy233.github.io/2022/08/16/JS/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : false,
    isPost : true,
    lang   : 'zh-CN'
  };
</script>

  <title>JS | Henfy-Blog</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

<script>function loadCss(l){var d=document,h=d.head,s=d.createElement('link');s.rel='stylesheet';s.href=l;!function e(f){if (d.body)return f();setTimeout(function(){e(f)})}(function(){h.appendChild(s);});}loadCss('/style.css');loadCss('//fonts.loli.net/css?family=Lato:300,300italic,400,400italic,700,700italic|youyuan:300,300italic,400,400italic,700,700italic|Inconsolata:300,300italic,400,400italic,700,700italic&display=swap&subset=latin,latin-ext');loadCss('//cdnjs.cloudflare.com/ajax/libs/font-awesome/5.13.0/css/all.min.css');loadCss('//cdn.jsdelivr.net/gh/fancyapps/fancybox@3/dist/jquery.fancybox.min.css');loadCss('//cdn.jsdelivr.net/npm/gitalk@1/dist/gitalk.min.css');</script><noscript><link rel="stylesheet" href="/style.css"><link rel="stylesheet" href="//fonts.loli.net/css?family=Lato:300,300italic,400,400italic,700,700italic|youyuan:300,300italic,400,400italic,700,700italic|Inconsolata:300,300italic,400,400italic,700,700italic&amp;display=swap&amp;subset=latin,latin-ext"><link rel="stylesheet" href="//cdnjs.cloudflare.com/ajax/libs/font-awesome/5.13.0/css/all.min.css"><link rel="stylesheet" href="//cdn.jsdelivr.net/gh/fancyapps/fancybox@3/dist/jquery.fancybox.min.css"><link rel="stylesheet" href="//cdn.jsdelivr.net/npm/gitalk@1/dist/gitalk.min.css"></noscript></head>

<body itemscope="" itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope="" itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">Henfy-Blog</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
      <p class="site-subtitle" itemprop="description">专注以前端领域开发</p>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
        <i class="fa fa-search fa-fw fa-lg"></i>
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a>

  </li>
        <li class="menu-item menu-item-about">

    <a href="/about/" rel="section"><i class="fa fa-user fa-fw"></i>关于</a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>标签<span class="badge">4</span></a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>分类<span class="badge">5</span></a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档<span class="badge">15</span></a>

  </li>
      <li class="menu-item menu-item-search">
        <a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>搜索
        </a>
      </li>
  </ul>
</nav>



  <div class="search-pop-overlay">
    <div class="popup search-popup">
        <div class="search-header">
  <span class="search-icon">
    <i class="fa fa-search"></i>
  </span>
  <div class="search-input-container">
    <input autocomplete="off" autocapitalize="off" placeholder="搜索..." spellcheck="false" type="search" class="search-input">
  </div>
  <span class="popup-btn-close">
    <i class="fa fa-times-circle"></i>
  </span>
</div>
<div id="search-result">
  <div id="no-result">
    <i class="fa fa-spinner fa-pulse fa-5x fa-fw"></i>
  </div>
</div>

    </div>
  </div>

</div>
    </header>

    
  <div class="reading-progress-bar"></div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content post posts-expand">
            

    
  
  
  <article itemscope="" itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://henfy233.github.io/2022/08/16/JS/">

    <span hidden="" itemprop="author" itemscope="" itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.jpg">
      <meta itemprop="name" content="henfy">
      <meta itemprop="description" content="技术分享的博客">
    </span>

    <span hidden="" itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Henfy-Blog">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          JS
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2022-08-16 23:06:07" itemprop="dateCreated datePublished" datetime="2022-08-16T23:06:07+08:00">2022-08-16</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2022-08-19 22:54:19" itemprop="dateModified" datetime="2022-08-19T22:54:19+08:00">2022-08-19</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope="" itemtype="http://schema.org/Thing">
                  <a href="/categories/%E5%89%8D%E7%AB%AF/" itemprop="url" rel="index"><span itemprop="name">前端</span></a>
                </span>
            </span>

          
            <span class="post-meta-item" title="阅读次数" id="busuanzi_container_page_pv" style="display: none;">
              <span class="post-meta-item-icon">
                <i class="fa fa-eye"></i>
              </span>
              <span class="post-meta-item-text">阅读次数：</span>
              <span id="busuanzi_value_page_pv"></span>
            </span><br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="far fa-file-word"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>89k</span>
            </span>
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="far fa-clock"></i>
              </span>
                <span class="post-meta-item-text">阅读时长 ≈</span>
              <span>1:21</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
        <p>介绍目前常见前端面试题，参考链接 <span class="exturl" data-url="aHR0cHM6Ly9pbnRlcnZpZXcyLnBvZXRyaWVzLnRvcC8=">https://interview2.poetries.top/<i class="fa fa-external-link-alt"></i></span></p>
<span id="more"></span>



<h2 id="JavaScript"><a href="#JavaScript" class="headerlink" title="JavaScript"></a>JavaScript</h2><h3 id="❤-this指向"><a href="#❤-this指向" class="headerlink" title="❤ this指向"></a>❤ this指向</h3><p><strong>1. this 指向有哪几种</strong></p>
<ul>
<li>默认绑定：全局环境中，<code>this</code>默认绑定到<code>window</code></li>
<li>隐式绑定：一般地，被直接对象所包含的函数调用时，也称为方法调用，<code>this</code>隐式绑定到该直接对象</li>
<li>隐式丢失：隐式丢失是指被隐式绑定的函数丢失绑定对象，从而默认绑定到<code>window</code>。显式绑定：通过<code>call()</code>、<code>apply()</code>、<code>bind()</code>方法把对象绑定到<code>this</code>上，叫做显式绑定</li>
<li><code>new</code>绑定：如果函数或者方法调用之前带有关键字<code>new</code>，它就构成构造函数调用。对于<code>this</code>绑定来说，称为<code>new</code>绑定<ul>
<li>构造函数通常不使用<code>return</code>关键字，它们通常初始化新对象，当构造函数的函数体执行完毕时，它会显式返回。在这种情况下，构造函数调用表达式的计算结果就是这个新对象的值</li>
<li>如果构造函数使用<code>return</code>语句但没有指定返回值，或者返回一个原始值，那么这时将忽略返回值，同时使用这个新对象作为调用结果</li>
<li>如果构造函数显式地使用<code>return</code>语句返回一个对象，那么调用表达式的值就是这个对象</li>
</ul>
</li>
</ul>
<p><strong>2. 改变函数内部 this 指针的指向函数（bind，apply，call的区别）</strong></p>
<ul>
<li><code>apply</code>：调用一个对象的一个方法，用另一个对象替换当前对象。例如：<code>B.apply(A, arguments)</code>;即A对象应用B对象的方法</li>
<li><code>call</code>：调用一个对象的一个方法，用另一个对象替换当前对象。例如：<code>B.call(A, args1,args2)</code>;即A对象调用B对象的方法</li>
<li><code>bind</code>除了返回是函数以外，它的参数和<code>call</code>一样</li>
</ul>
<p><strong>3. 箭头函数</strong></p>
<ul>
<li>箭头函数没有<code>this</code>，所以需要通过查找作用域链来确定<code>this</code>的值，这就意味着如果箭头函数被非箭头函数包含，<code>this</code>绑定的就是最近一层非箭头函数的<code>this</code>，</li>
<li>箭头函数没有自己的<code>arguments</code>对象，但是可以访问外围函数的<code>arguments</code>对象</li>
<li>不能通过<code>new</code>关键字调用，同样也没有<code>new.target</code>值和原型</li>
</ul>
<p><strong>牛客网解释：</strong></p>
<ul>
<li><strong>得分点</strong> 全局执行上下文、函数执行上下文、this严格模式下undefined、非严格模式window、构造函数新对象本身、普通函数不继承this、箭头函数无this，可继承</li>
<li><strong>标准回答</strong><ul>
<li><strong>this关键字</strong>由来：在对象内部的方法中使用对象内部的属性是一个非常普遍的需求。但是 JavaScript 的作用域机制并不支持这一点，基于这个需求，JavaScript 又搞出来另外一套 this 机制。</li>
<li><strong>this存在的场景</strong>有三种 <strong>全局执行上下文</strong> 和 <strong>函数执行上下文</strong> 和 <strong>eval执行上下文</strong>，eval这种不讨论。<ul>
<li>在全局执行环境中无论是否在严格模式下，（在任何函数体外部）<code>this</code> 都指向全局对象。</li>
<li>在函数执行上下文中访问this，函数的调用方式决定了 <code>this</code> 的值。在全局环境中调用一个函数，函数内部的 this 指向的是全局变量 window，通过一个对象来调用其内部的一个方法，该方法的执行上下文中的 this 指向对象本身。</li>
<li>普通函数this指向：当函数被正常调用时，在严格模式下，this 值是 undefined，非严格模式下 this 指向的是全局对象 window；通过一个对象来调用其内部的一个方法，该方法的执行上下文中的 this 指向对象本身。</li>
<li>new 关键字构建好了一个新对象，并且构造函数中的 this 其实就是新对象本身。嵌套函数中的 this 不会继承外层函数的 this 值。</li>
<li>箭头函数this指向：箭头函数并不会创建其自身的执行上下文，所以箭头函数中的 this 取决于它的外部函数。</li>
</ul>
</li>
</ul>
</li>
<li><strong>加分回答</strong><ul>
<li>箭头函数因为没有this，所以也不能作为构造函数，但是需要继承函数外部this的时候，使用箭头函数比较方便</li>
</ul>
</li>
</ul>
<figure class="highlight js"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> myObj = {</span><br><span class="line">    name : <span class="string">"闷倒驴"</span>,</span><br><span class="line">    showThis:<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>{</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="built_in">this</span>);</span><br><span class="line">        <span class="comment">// myObj</span></span><br><span class="line">        <span class="keyword">var</span> bar = <span class="function">()=&gt;</span>{</span><br><span class="line">            <span class="built_in">this</span>.name = <span class="string">"王美丽"</span>;</span><br><span class="line">            <span class="built_in">console</span>.log(<span class="built_in">this</span>)</span><br><span class="line">            <span class="comment">// myObj</span></span><br><span class="line">    	}</span><br><span class="line">    	bar();</span><br><span class="line">	}</span><br><span class="line">};</span><br><span class="line">myObj.showThis();</span><br><span class="line"><span class="built_in">console</span>.log(myObj.name);  <span class="comment">// "王美丽"</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">window</span>.name); <span class="comment">// ''</span></span><br></pre></td></tr></tbody></table></figure>



<h3 id="❤-This"><a href="#❤-This" class="headerlink" title="❤ This"></a>❤ This</h3><p><code>new</code> 的方式优先级最高，接下来是 <code>bind</code> 这些函数，然后是 <code>obj.foo()</code> 这种调用方式，最后是 <code>foo</code> 这种调用方式，同时，箭头函数的 <code>this</code> 一旦被绑定，就不会再被任何方式所改变。</p>
<p><img data-src="https://raw.githubusercontent.com/henfy233/picgo/main/img/2.png" alt="image.png"></p>
<p>由于 JS 的设计原理: 在函数中，可以引用运行环境中的变量。因此就需要一个机制来让我们可以在函数体内部获取当前的运行环境，这便是<code>this</code></p>
<p>但这种机制并不完全能满足我们的业务需求，因此提供了三种方式可以手动修改 <code>this</code> 的指向:</p>
<ul>
<li><code>call: fn.call(target, 1, 2)</code></li>
<li><code>apply: fn.apply(target, [1, 2])</code></li>
<li><code>bind: fn.bind(target)(1,2)</code></li>
</ul>
<h3 id="❤-call-apply-bind的作用和区别"><a href="#❤-call-apply-bind的作用和区别" class="headerlink" title="❤ call apply bind的作用和区别"></a>❤ call apply bind的作用和区别</h3><ul>
<li><strong>得分点</strong> bind改变this指向不直接调用、call和apply改变this指向直接调用、apply接收第二个参数为数组 、call用于对象的继承 、伪数组转换成真数组、apply用于找出数组中的最大值和最小值以及数组合并、bind用于vue或者react框架中改变函数的this指向</li>
<li><strong>标准回答</strong><ul>
<li>call、apply、bind的作用都是改变函数运行时的this指向。 </li>
<li>bind和call、apply在使用上有所不同，bind在改变this指向的时候，返回一个改变执行上下文的函数，不会立即执行函数，而是需要调用该函数的时候再调用即可，但是call和apply在改变this指向的同时执行了该函数。</li>
<li>bind只接收一个参数，就是this指向的执行上文。 </li>
<li>call、apply接收多个参数，第一个参数都是this指向的执行上文，后面的参数都是作为改变this指向的函数的参数。但是call和apply参数的格式不同，call是一个参数对应一个原函数的参数，但是apply第二个参数是数组，数组中每个元素代表函数接收的参数，数组有几个元素函数就接收几个元素。</li>
</ul>
</li>
<li><strong>加分回答</strong><ul>
<li><p><strong>call的应用场景：</strong> 对象的继承，在子构造函数这种调用父构造函数，但是改变this指向，就可以继承父的属性</p>
<figure class="highlight js"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> arrayLike = {</span><br><span class="line">  <span class="number">0</span>: <span class="string">'java'</span>,</span><br><span class="line">  <span class="number">1</span>: <span class="string">'script'</span>,</span><br><span class="line">  length: <span class="number">2</span></span><br><span class="line">}</span><br><span class="line"><span class="built_in">Array</span>.prototype.push.call(arrayLike, <span class="string">'jack'</span>, <span class="string">'lily'</span>);</span><br><span class="line"><span class="built_in">console</span>.log(<span class="keyword">typeof</span> arrayLike); <span class="comment">// 'object'</span></span><br><span class="line"><span class="built_in">console</span>.log(arrayLike);</span><br><span class="line"><span class="comment">// {0: "java", 1: "script", 2: "jack", 3: "lily", length: 4}</span></span><br></pre></td></tr></tbody></table></figure></li>
<li><p><strong>apply的应用场景：</strong></p>
</li>
</ul>
</li>
</ul>
<figure class="highlight js"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 获取数组中最大、最小的一项</span></span><br><span class="line"><span class="keyword">let</span> max = <span class="built_in">Math</span>.max.apply(<span class="literal">null</span>, array);</span><br><span class="line"><span class="keyword">let</span> min = <span class="built_in">Math</span>.min.apply(<span class="literal">null</span>, array);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 实现两个数组合并</span></span><br><span class="line"><span class="keyword">let</span> arr1 = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>];</span><br><span class="line"><span class="keyword">let</span> arr2 = [<span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>];</span><br><span class="line"><span class="built_in">Array</span>.prototype.push.apply(arr1, arr2);</span><br><span class="line"><span class="built_in">console</span>.log(arr1);</span><br><span class="line"><span class="comment">// [1, 2, 3, 4, 5, 6]</span></span><br></pre></td></tr></tbody></table></figure>

<ul>
<li><strong>bind的应用场景</strong> 在vue或者react框架中，使用bind将定义的方法中的this指向当前类</li>
</ul>
<p><img data-src="https://raw.githubusercontent.com/henfy233/picgo/main/img/20210414155100.png" alt="call apply bind的作用和区别"></p>
<blockquote>
<p><code>call、apply</code> 和 <code>bind</code> 是挂在 <code>Function</code> 对象上的三个方法，调用这三个方法的必须是一个函数。</p>
</blockquote>
<figure class="highlight js"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">func.call(thisArg, param1, param2, ...)</span><br><span class="line">func.apply(thisArg, [param1,param2,...])</span><br><span class="line">func.bind(thisArg, param1, param2, ...)</span><br></pre></td></tr></tbody></table></figure>

<ul>
<li>在浏览器里，在全局范围内this 指向window对象；</li>
<li>在函数中，this永远指向最后调用他的那个对象；</li>
<li>构造函数中，this指向new出来的那个新的对象；</li>
<li><code>call、apply、bind</code>中的this被强绑定在指定的那个对象上；</li>
<li>箭头函数中this比较特殊,箭头函数this为父作用域的this，不是调用时的this.要知道前四种方式,都是调用时确定,也就是动态的,而箭头函数的this指向是静态的,声明的时候就确定了下来；</li>
<li><code>apply、call、bind</code>都是js给函数内置的一些API，调用他们可以为函数指定this的执行,同时也可以传参。</li>
</ul>
<p><strong>实现一个 bind 函数</strong></p>
<p>对于实现以下几个函数，可以从几个方面思考</p>
<ul>
<li>不传入第一个参数，那么默认为 <code>window</code></li>
<li>改变了 <code>this</code> 指向，让新的对象可以执行该函数。那么思路是否可以变成给新的对象添加一个函数，然后在执行完以后删除？</li>
</ul>
<figure class="highlight js"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Function</span>.prototype.myBind = <span class="function"><span class="keyword">function</span> (<span class="params">context</span>) </span>{</span><br><span class="line">  <span class="keyword">if</span> (<span class="keyword">typeof</span> <span class="built_in">this</span> !== <span class="string">'function'</span>) {</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">TypeError</span>(<span class="string">'Error'</span>)</span><br><span class="line">  }</span><br><span class="line">  <span class="keyword">var</span> _this = <span class="built_in">this</span></span><br><span class="line">  <span class="keyword">var</span> args = [...arguments].slice(<span class="number">1</span>)</span><br><span class="line">  <span class="comment">// 返回一个函数</span></span><br><span class="line">  <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> <span class="title">F</span>(<span class="params"></span>) </span>{</span><br><span class="line">    <span class="comment">// 因为返回了一个函数，我们可以 new F()，所以需要判断</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">this</span> <span class="keyword">instanceof</span> F) {</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">new</span> _this(...args, ...arguments)</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">return</span> _this.apply(context, args.concat(...arguments))</span><br><span class="line">  }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p><strong>实现一个 call 函数</strong></p>
<figure class="highlight js"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Function</span>.prototype.myCall = <span class="function"><span class="keyword">function</span> (<span class="params">context</span>) </span>{</span><br><span class="line">  <span class="keyword">var</span> context = context || <span class="built_in">window</span></span><br><span class="line">  <span class="comment">// 给 context 添加一个属性</span></span><br><span class="line">  <span class="comment">// getValue.call(a, 'pp', '24') =&gt; a.fn = getValue</span></span><br><span class="line">  context.fn = <span class="built_in">this</span></span><br><span class="line">  <span class="comment">// 将 context 后面的参数取出来</span></span><br><span class="line">  <span class="keyword">var</span> args = [...arguments].slice(<span class="number">1</span>)</span><br><span class="line">  <span class="comment">// getValue.call(a, 'pp', '24') =&gt; a.fn('pp', '24')</span></span><br><span class="line">  <span class="keyword">var</span> result = context.fn(...args)</span><br><span class="line">  <span class="comment">// 删除 fn</span></span><br><span class="line">  <span class="keyword">delete</span> context.fn</span><br><span class="line">  <span class="keyword">return</span> result</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p><strong>实现一个 apply 函数</strong></p>
<figure class="highlight js"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Function</span>.prototype.myApply = <span class="function"><span class="keyword">function</span>(<span class="params">context = <span class="built_in">window</span>, ...args</span>) </span>{</span><br><span class="line">  <span class="comment">// this--&gt;func  context--&gt; obj  args--&gt; 传递过来的参数</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// 在context上加一个唯一值不影响context上的属性</span></span><br><span class="line">  <span class="keyword">let</span> key = <span class="built_in">Symbol</span>(<span class="string">'key'</span>)</span><br><span class="line">  context[key] = <span class="built_in">this</span>; <span class="comment">// context为调用的上下文,this此处为函数，将这个函数作为context的方法</span></span><br><span class="line">  <span class="comment">// let args = [...arguments].slice(1)   //第一个参数为obj所以删除,伪数组转为数组</span></span><br><span class="line">  </span><br><span class="line">  <span class="keyword">let</span> result = context[key](...args); </span><br><span class="line">  <span class="keyword">delete</span> context[key]; <span class="comment">// 不删除会导致context属性越来越多</span></span><br><span class="line">  <span class="keyword">return</span> result;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>



<h3 id="❤-变量提升"><a href="#❤-变量提升" class="headerlink" title="❤ 变量提升"></a>❤ 变量提升</h3><blockquote>
<p>当执行 JS 代码时，会生成执行环境，只要代码不是写在函数中的，就是在全局执行环境中，函数中的代码会产生函数执行环境，只此两种执行环境</p>
</blockquote>
<figure class="highlight js"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">b() <span class="comment">// call b</span></span><br><span class="line"><span class="built_in">console</span>.log(a) <span class="comment">// undefined</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> a = <span class="string">'Hello world'</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">b</span>(<span class="params"></span>) </span>{</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'call b'</span>)</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<blockquote>
<p>这是因为函数和变量提升的原因。通常提升的解释是说将声明的代码移动到了顶部，这其实没有什么错误，便于大家理解。但是更准确的解释应该是：在生成执行环境时，会有两个阶段。第一个阶段是创建的阶段，JS 解释器会找出需要提升的变量和函数，并且给他们提前在内存中开辟好空间，函数的话会将整个函数存入内存中，变量只声明并且赋值为 <code>undefined</code>，所以在第二个阶段，也就是代码执行阶段，我们可以直接提前使用</p>
</blockquote>
<ul>
<li>在提升的过程中，相同的函数会覆盖上一个函数，并且函数优先于变量提升</li>
</ul>
<figure class="highlight js"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">b() <span class="comment">// call b second</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">b</span>(<span class="params"></span>) </span>{</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'call b fist'</span>)</span><br><span class="line">}</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">b</span>(<span class="params"></span>) </span>{</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'call b second'</span>)</span><br><span class="line">}</span><br><span class="line"><span class="keyword">var</span> b = <span class="string">'Hello world'</span></span><br></pre></td></tr></tbody></table></figure>

<blockquote>
<p><code>var</code> 会产生很多错误，所以在 <code>ES6</code>中引入了 <code>let</code>。<code>let</code> 不能在声明前使用，但是这并不是常说的 <code>let</code> 不会提升，<code>let</code> 提升了，在第一阶段内存也已经为他开辟好了空间，但是因为这个声明的特性导致了并不能在声明前使用</p>
</blockquote>
<p><strong>牛客网解释：</strong></p>
<ul>
<li><strong>得分点</strong> Var声明的变量声明提升、函数声明提升、let和const变量不提升</li>
<li><strong>标准回答</strong><ul>
<li><strong>变量提升</strong>是指JS的变量和函数声明会在代码编译期，提升到代码的最前面。</li>
<li>变量提升成立的前提是使用<strong>Var关键字</strong>进行声明的变量，并且变量提升的时候只有声明被提升，赋值并不会被提升，同时函数的声明提升会比变量的提升优先。</li>
<li>变量提升的结果，可以在变量初始化之前访问该变量，返回的是<strong>undefined</strong>。在函数声明前可以调用该函数。</li>
</ul>
</li>
<li><strong>加分回答</strong><ul>
<li>使用let和const声明的变量是创建提升，形成暂时性死区，在初始化之前访问let和const创建的变量会报错。</li>
</ul>
</li>
</ul>
<h3 id="❤-作用域"><a href="#❤-作用域" class="headerlink" title="❤ 作用域"></a>❤ 作用域</h3><ul>
<li>作用域： 作用域是定义变量的区域，它有一套访问变量的规则，这套规则来管理浏览器引擎如何在当前作用域以及嵌套的作用域中根据变量（标识符）进行变量查找</li>
<li>作用域链： 作用域链的作用是保证对执行环境有权访问的所有变量和函数的有序访问，通过作用域链，我们可以访问到外层环境的变量和 函数。</li>
</ul>
<blockquote>
<p>作用域链的本质上是一个指向变量对象的指针列表。变量对象是一个包含了执行环境中所有变量和函数的对象。作用域链的前 端始终都是当前执行上下文的变量对象。全局执行上下文的变量对象（也就是全局对象）始终是作用域链的最后一个对象。</p>
</blockquote>
<ul>
<li>当我们查找一个变量时，如果当前执行环境中没有找到，我们可以沿着作用域链向后查找</li>
<li>作用域链的创建过程跟执行上下文的建立有关….</li>
</ul>
<blockquote>
<p>作用域可以理解为变量的可访问性，总共分为三种类型，分别为：</p>
</blockquote>
<ul>
<li>全局作用域</li>
<li>函数作用域</li>
<li>块级作用域，ES6 中的 <code>let</code>、<code>const</code> 就可以产生该作用域</li>
</ul>
<p>其实看完前面的闭包、<code>this</code> 这部分内部的话，应该基本能了解作用域的一些应用。</p>
<p>一旦我们将这些作用域嵌套起来，就变成了另外一个重要的知识点「作用域链」，也就是 JS 到底是如何访问需要的变量或者函数的。</p>
<ul>
<li>首先作用域链是在定义时就被确定下来的，和箭头函数里的 this 一样，后续不会改变，JS 会一层层往上寻找需要的内容。</li>
<li>其实作用域链这个东西我们在闭包小结中已经看到过它的实体了：<code>[[Scopes]]</code></li>
</ul>
<p>图中的 <code>[[Scopes]]</code> 是个数组，作用域的一层层往上寻找就等同于遍历 <code>[[Scopes]]</code>。</p>
<h3 id="JS-作用链域"><a href="#JS-作用链域" class="headerlink" title="JS 作用链域"></a>JS 作用链域</h3><ul>
<li>全局函数无法查看局部函数的内部细节，但局部函数可以查看其上层的函数细节，直至全局细节</li>
<li>如果当前作用域没有找到属性或方法，会向上层作用域查找，直至全局函数，这种形式就是作用域链</li>
</ul>
<h3 id="❤-闭包"><a href="#❤-闭包" class="headerlink" title="❤ 闭包"></a>❤ 闭包</h3><blockquote>
<p> 闭包其实就是一个可以访问其他函数内部变量的函数。创建闭包的最常见的方式就是在一个函数内创建另一个函数，创建的函数可以 访问到当前函数的局部变量。</p>
</blockquote>
<p><strong>闭包产生的本质就是：当前环境中存在指向父级作用域的引用</strong></p>
<p><strong>闭包有两个常用的用途</strong></p>
<ul>
<li>闭包的第一个用途是使我们在函数外部能够访问到函数内部的变量。通过使用闭包，我们可以通过在外部调用闭包函数，从而在外部访问到函数内部的变量，可以使用这种方法来创建私有变量。</li>
<li>函数的另一个用途是使已经运行结束的函数上下文中的变量对象继续留在内存中，因为闭包函数保留了这个变量对象的引用，所以这个变量对象不会被回收。</li>
</ul>
<blockquote>
<p>其实闭包的本质就是作用域链的一个特殊的应用，只要了解了作用域链的创建过程，就能够理解闭包的实现原理。</p>
</blockquote>
<ul>
<li>闭包的特性：<ul>
<li>函数内再嵌套函数</li>
<li>内部函数可以引用外层的参数和变量</li>
<li>参数和变量不会被垃圾回收机制回收</li>
</ul>
</li>
</ul>
<p><strong>说说你对闭包的理解</strong></p>
<ul>
<li>使用闭包主要是为了设计私有的方法和变量。<ul>
<li>闭包的<strong>优点</strong>是可以避免全局变量的污染，</li>
<li><strong>缺点</strong>是闭包会常驻内存，会增大内存使用量，使用不当很容易造成内存泄露。在js中，函数即闭包，只有函数才会产生作用域的概念</li>
</ul>
</li>
<li>闭包 的最大用处有两个，一个是可以读取函数内部的变量，另一个就是让这些变量始终保持在内存中</li>
<li>闭包的另一个用处，是封装对象的私有属性和私有方法</li>
<li><strong>好处</strong>：能够实现封装和缓存等；</li>
<li><strong>坏处</strong>：就是消耗内存、不正当使用会造成内存溢出的问题</li>
</ul>
<p><strong>使用闭包的注意点</strong></p>
<ul>
<li>由于闭包会使得函数中的变量都被保存在内存中，内存消耗很大，所以不能滥用闭包，否则会造成网页的性能问题，在IE中可能导致内存泄露</li>
<li>解决方法是，在退出函数之前，将不使用的局部变量全部删除</li>
</ul>
<ul>
<li><strong>得分点：</strong>变量背包、作用域链、局部变量不销毁、函数体外访问函数的内部变量、内存泄漏、内存溢出、形成块级作用域、柯里化、构造函数中定义特权方法、Vue中数据响应式Observer</li>
<li><strong>标准回答：</strong>闭包 一个函数和词法环境的引用捆绑在一起，这样的组合就是闭包（closure）。<ul>
<li>一般就是一个函数A，return其内部的函数B，被return出去的B函数能够在外部访问A函数内部的变量，这时候就形成了一个B函数的变量背包，A函数执行结束后这个变量背包也不会被销毁，并且这个变量背包在A函数外部只能通过B函数访问。</li>
<li><strong>形成的原理</strong>：作用域链，当前作用域可以访问上级作用域中的变量</li>
<li><strong>解决的问题</strong>：能够让函数作用域中的变量在函数执行结束之后不被销毁，同时也能在函数外部可以访问函数内部的局部变量。</li>
<li><strong>带来的问题</strong>：由于垃圾回收器不会将闭包中变量销毁，于是就造成了内存泄露，内存泄露积累多了就容易导致内存溢出。</li>
</ul>
</li>
<li><strong>加分回答：</strong><ul>
<li>闭包的应用，能够模仿块级作用域，能够实现柯里化，在构造函数中定义特权方法、Vue中数据响应式Observer中使用闭包等。</li>
</ul>
</li>
</ul>
<h3 id="❤-New的原理"><a href="#❤-New的原理" class="headerlink" title="❤ New的原理"></a>❤ New的原理</h3><ul>
<li><p><strong>得分点</strong> 创建空对象、为对象添加属性、把新对象当作this的上下文、箭头函数不能作为构造函数</p>
</li>
<li><p><strong>标准回答</strong></p>
</li>
<li><p><code>new</code> 操作符可以帮助我们构建出一个实例，并且绑定上 this，内部执行步骤可大概分为以下几步：</p>
<ol>
<li>创建一个新对象</li>
<li>对象连接到构造函数原型上，并绑定 <code>this</code>（this 指向新对象）</li>
<li>执行构造函数代码（为这个新对象添加属性）</li>
<li>返回新对象</li>
</ol>
<p>在第四步返回新对象这边有一个情况会例外：</p>
<blockquote>
<p>那么问题来了，如果不用 <code>new</code> 这个关键词，结合上面的代码改造一下，去掉 <code>new</code>，会发生什么样的变化呢？我们再来看下面这段代码</p>
</blockquote>
<figure class="highlight js"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params"></span>)</span>{</span><br><span class="line">  <span class="built_in">this</span>.name = <span class="string">'Jack'</span>;</span><br><span class="line">}</span><br><span class="line"><span class="keyword">var</span> p = Person();</span><br><span class="line"><span class="built_in">console</span>.log(p) <span class="comment">// undefined</span></span><br><span class="line"><span class="built_in">console</span>.log(name) <span class="comment">// Jack</span></span><br><span class="line"><span class="built_in">console</span>.log(p.name) <span class="comment">// 'name' of undefined</span></span><br></pre></td></tr></tbody></table></figure>

<p>从上面的代码中可以看到，我们没有使用 <code>new</code> 这个关键词，返回的结果就是 <code>undefined</code>。其中由于 <code>JavaScript</code> 代码在默认情况下 <code>this</code> 的指向是 <code>window</code>，那么 <code>name</code> 的输出结果就为 <code>Jack</code>，这是一种不存在 <code>new</code> 关键词的情况。</p>
<p>那么当构造函数中有 <code>return</code> 一个对象的操作，结果又会是什么样子呢？我们再来看一段在上面的基础上改造过的代码。</p>
<figure class="highlight js"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params"></span>)</span>{</span><br><span class="line">   <span class="built_in">this</span>.name = <span class="string">'Jack'</span>;</span><br><span class="line">   <span class="keyword">return</span> {<span class="attr">age</span>: <span class="number">18</span>}</span><br><span class="line">}</span><br><span class="line"><span class="keyword">var</span> p = <span class="keyword">new</span> Person();</span><br><span class="line"><span class="built_in">console</span>.log(p)  <span class="comment">// {age: 18}</span></span><br><span class="line"><span class="built_in">console</span>.log(p.name) <span class="comment">// undefined</span></span><br><span class="line"><span class="built_in">console</span>.log(p.age) <span class="comment">// 18</span></span><br></pre></td></tr></tbody></table></figure>

<blockquote>
<p>通过这段代码又可以看出，当构造函数最后 <code>return</code> 出来的是一个和 <code>this</code> 无关的对象时，<code>new 命令会直接返回这个新对象</code>，<code>而不是通过 new 执行步骤生成的 this 对象</code></p>
</blockquote>
<p>但是这里要求构造函数必须是返回一个对象，<code>如果返回的不是对象，那么还是会按照 new 的实现步骤，返回新生成的对象</code>。接下来还是在上面这段代码的基础之上稍微改动一下</p>
<figure class="highlight js"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params"></span>)</span>{</span><br><span class="line">   <span class="built_in">this</span>.name = <span class="string">'Jack'</span>;</span><br><span class="line">   <span class="keyword">return</span> <span class="string">'tom'</span>;</span><br><span class="line">}</span><br><span class="line"><span class="keyword">var</span> p = <span class="keyword">new</span> Person();</span><br><span class="line"><span class="built_in">console</span>.log(p)  <span class="comment">// {name: 'Jack'}</span></span><br><span class="line"><span class="built_in">console</span>.log(p.name) <span class="comment">// Jack</span></span><br></pre></td></tr></tbody></table></figure>

<p>可以看出，当构造函数中 <code>return</code> 的不是一个对象时，那么它还是会根据 <code>new</code> 关键词的执行逻辑，生成一个新的对象（绑定了最新 <code>this</code>），最后返回出来</p>
<blockquote>
<p>因此我们总结一下：<code>new 关键词执行之后总是会返回一个对象，要么是实例对象，要么是 return 语句指定的对象</code></p>
</blockquote>
</li>
<li><p><strong>加分回答</strong></p>
<ul>
<li><code>new</code>关键字后面的构造函数不能是箭头函数。</li>
</ul>
</li>
</ul>
<h3 id="❤-原型，原型链"><a href="#❤-原型，原型链" class="headerlink" title="❤ 原型，原型链"></a>❤ 原型，原型链</h3><p><strong><code>__proto__</code>和prototype关系</strong>：<code>__proto__</code>和<code>constructor</code>是<strong>对象</strong>独有的。<code>prototype</code>属性是<strong>函数</strong>独有的</p>
<p>当我们访问一个对象的属性时，如果这个对象内部不存在这个属性，那么它就会去它的原型对象里找这个属性，这个原型对象又会有自己的原型，于是就这样一直找下去，也就是原型链的概念。原型链的尽头一般来说都是 <code>Object.prototype</code> 所以这就是我们新建的对象为什么能够使用 <code>toString()</code> 等方法的原因。</p>
<blockquote>
<p>特点：JavaScript 对象是通过引用来传递的，我们创建的每个新对象实体中并没有一份属于自己的原型副本。当我们修改原型时，与 之相关的对象也会继承这一改变</p>
</blockquote>
<ul>
<li>原型(<code>prototype</code>): 一个简单的对象，用于实现对象的 属性继承。可以简单的理解成对象的爹。在 <code>Firefox</code> 和 <code>Chrome</code> 中，每个<code>JavaScript</code>对象中都包含一个<code>__proto__</code>(非标准)的属性指向它爹(该对象的原型)，可<code>obj.__proto__</code>进行访问。</li>
<li>构造函数: 可以通过<code>new</code>来 新建一个对象 的函数。</li>
<li>实例: 通过构造函数和<code>new</code>创建出来的对象，便是实例。 实例通过<code>__proto__</code>指向原型，通过<code>constructor</code>指向构造函数。</li>
</ul>
<figure class="highlight js"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 实例</span></span><br><span class="line"><span class="keyword">const</span> instance = <span class="keyword">new</span> <span class="built_in">Object</span>()</span><br><span class="line"><span class="comment">// 原型</span></span><br><span class="line"><span class="keyword">const</span> prototype = <span class="built_in">Object</span>.prototype</span><br></pre></td></tr></tbody></table></figure>

<p><strong>这里我们可以来看出三者的关系:</strong></p>
<ul>
<li><code>实例.__proto__ === 原型</code></li>
<li><code>原型.constructor === 构造函数</code></li>
<li><code>构造函数.prototype === 原型</code></li>
</ul>
<p><img data-src="https://raw.githubusercontent.com/henfy233/picgo/main/img/112.png" alt="img"></p>
<p><strong>总结：</strong></p>
<p><img data-src="https://raw.githubusercontent.com/henfy233/picgo/main/img/105.png" alt="img"></p>
<ul>
<li>每个函数都有 <code>prototype</code> 属性，除了 <code>Function.prototype.bind()</code>，该属性指向原型。</li>
<li>每个对象都有 <code>__proto__</code> 属性，指向了创建该对象的构造函数的原型。其实这个属性指向了 <code>[[prototype]]</code>，但是 <code>[[prototype]]</code>是内部属性，我们并不能访问到，所以使用 <code>_proto_</code>来访问。</li>
<li>对象可以通过 <code>__proto__</code> 来寻找不属于该对象的属性，<code>__proto__</code> 将对象连接起来组成了原型链。</li>
</ul>
<h3 id="❤-继承"><a href="#❤-继承" class="headerlink" title="❤ 继承"></a>❤ 继承</h3><p><img data-src="https://raw.githubusercontent.com/henfy233/picgo/main/img/20210414142754.png" alt="img"></p>
<blockquote>
<p>涉及面试题：原型如何实现继承？<code>Class</code> 如何实现继承？<code>Class</code> 本质是什么？</p>
</blockquote>
<p>首先先来讲下 <code>class</code>，其实在 <code>JS</code>中并不存在类，<code>class</code> 只是语法糖，本质还是函数</p>
<figure class="highlight js"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span> </span>{}</span><br><span class="line">Person <span class="keyword">instanceof</span> <span class="built_in">Function</span> <span class="comment">// true</span></span><br></pre></td></tr></tbody></table></figure>

<p><strong>组合继承</strong></p>
<blockquote>
<p>组合继承是最常用的继承方式</p>
</blockquote>
<figure class="highlight js"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Parent</span>(<span class="params">value</span>) </span>{</span><br><span class="line">  <span class="built_in">this</span>.val = value</span><br><span class="line">}</span><br><span class="line">Parent.prototype.getValue = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>{</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="built_in">this</span>.val)</span><br><span class="line">}</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Child</span>(<span class="params">value</span>) </span>{</span><br><span class="line">  Parent.call(<span class="built_in">this</span>, value)</span><br><span class="line">}</span><br><span class="line">Child.prototype = <span class="keyword">new</span> Parent()</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> child = <span class="keyword">new</span> Child(<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">child.getValue() <span class="comment">// 1</span></span><br><span class="line">child <span class="keyword">instanceof</span> Parent <span class="comment">// true</span></span><br></pre></td></tr></tbody></table></figure>

<ul>
<li>以上继承的方式核心是在子类的构造函数中通过 <code>Parent.call(this)</code> 继承父类的属性，然后改变子类的原型为 <code>new Parent()</code> 来继承父类的函数。</li>
<li>这种继承方式<strong>优点</strong>在于构造函数可以传参，不会与父类引用属性共享，可以复用父类的函数，但是也存在一个<strong>缺点</strong>就是在继承父类函数的时候调用了父类构造函数，导致子类的原型上多了不需要的父类属性，存在内存上的浪费</li>
</ul>
<p>-</p>
<ul>
<li>构造继承</li>
<li>原型继承</li>
<li>实例继承</li>
<li>拷贝继承</li>
<li>原型<code>prototype</code>机制或<code>apply</code>和<code>call</code>方法去实现较简单，建议使用构造函数与原型混合方式</li>
</ul>
<figure class="highlight javascript"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Parent</span>(<span class="params"></span>)</span>{</span><br><span class="line">	<span class="built_in">this</span>.name = <span class="string">'wang'</span>;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Child</span>(<span class="params"></span>)</span>{</span><br><span class="line">        <span class="built_in">this</span>.age = <span class="number">28</span>;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">Child.prototype = <span class="keyword">new</span> Parent();<span class="comment">//继承了Parent，通过原型</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> demo = <span class="keyword">new</span> Child();</span><br><span class="line">alert(demo.age);</span><br><span class="line">alert(demo.name);<span class="comment">//得到被继承的属性</span></span><br></pre></td></tr></tbody></table></figure>



<h3 id="数据类型"><a href="#数据类型" class="headerlink" title="数据类型"></a>数据类型</h3><h4 id="介绍-JS-有哪些内置对象"><a href="#介绍-JS-有哪些内置对象" class="headerlink" title="介绍 JS 有哪些内置对象"></a>介绍 JS 有哪些内置对象</h4><ul>
<li>数据封装类对象：<code>Object</code>、<code>Array</code>、<code>Boolean</code>、<code>Number</code>、<code>String</code></li>
<li>其他对象：<code>Function</code>、<code>Arguments</code>、<code>Math</code>、<code>Date</code>、<code>RegExp</code>、<code>Error</code></li>
<li>ES6新增对象：<code>Symbol</code>、<code>Map</code>、<code>Set</code>、<code>Promises</code>、<code>Proxy</code>、<code>Reflect</code></li>
</ul>
<h4 id="JS-有几种类型，画一下内存图"><a href="#JS-有几种类型，画一下内存图" class="headerlink" title="JS 有几种类型，画一下内存图"></a>JS 有几种类型，画一下内存图</h4><ul>
<li>原始数据类型（<code>Undefined</code>，<code>Null</code>，<code>Boolean</code>，<code>Number</code>、<code>String</code>）– 栈</li>
<li>引用数据类型（对象、数组和函数）– 堆</li>
<li>两种类型的区别是：存储位置不同：</li>
<li>原始数据类型是直接存储在栈(<code>stack</code>)中的简单数据段，占据空间小、大小固定，属于被频繁使用数据；</li>
<li>引用数据类型存储在堆(<code>heap</code>)中的对象，占据空间大、大小不固定，如果存储在栈中，将会影响程序运行的性能；</li>
<li>引用数据类型在栈中存储了指针，该指针指向堆中该实体的起始地址。</li>
<li>当解释器寻找引用值时，会首先检索其在栈中的地址，取得地址后从堆中获得实体。</li>
</ul>
<h4 id="❤-JS-基本数据类型-引用数据类型"><a href="#❤-JS-基本数据类型-引用数据类型" class="headerlink" title="❤ JS 基本数据类型 引用数据类型"></a>❤ JS 基本数据类型 引用数据类型</h4><ul>
<li><p>得分点</p>
<p>Number、String、Boolean、BigInt、Symbol、Null、Undefined、Object、8种</p>
</li>
<li><p>标准回答</p>
</li>
<li><p>JS数据类型分为两类：</p>
<ul>
<li>一类是基本数据类型，也叫简单数据类型，包含7种类型，分别是<code>Null</code>、<code>Undefined</code>、<code>Number</code>、<code>String</code>、<code>Boolean</code>、<code>Symbol</code>（<code>es6</code>新增，表示独一无二的值）、<code>BigInt</code>（<code>es10</code>新增）。</li>
<li>另一类是引用数据类型也叫复杂数据类型，通常用<code>Object</code>代表，普通对象，数组<code>Array</code>，正则<code>RegExp</code>，日期<code>Date</code>，数学<code>Math</code>，函数<code>Function</code>都属于Object。</li>
</ul>
</li>
<li><p>数据分成两大类的本质区别：基本数据类型和引用数据类型它们在内存中的存储方式不同。</p>
<ul>
<li>基本数据类型是直接存储在栈中的简单数据段，占据空间小，属于被频繁使用的数据。</li>
<li>引用数据类型是存储在堆内存中，占据空间大。引用数据类型在栈中存储了指针，该指针指向堆中该实体的起始地址，当解释器寻找引用值时，会检索其在栈中的地址，取得地址后从堆中获得实体。</li>
</ul>
</li>
<li><p>加分回答</p>
</li>
<li><p>Symbol是ES6新出的一种数据类型，这种数据类型的特点就是没有重复的数据，可以作为object的key。<br>数据的创建方法Symbol()，因为它的构造函数不够完整，所以不能使用new Symbol()创建数据。由于Symbol()创建数据具有唯一性，所以 Symbol() !== Symbol(), 同时使用Symbol数据作为key不能使用for获取到这个key，需要使用Object.getOwnPropertySymbols(obj)获得这个obj对象中key类型是Symbol的key值。</p>
</li>
</ul>
<figure class="highlight js"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> key = <span class="built_in">Symbol</span>(<span class="string">'key'</span>);</span><br><span class="line"><span class="keyword">let</span> obj = { [key]: <span class="string">'symbol'</span>};</span><br><span class="line"><span class="keyword">let</span> keyArray = <span class="built_in">Object</span>.getOwnPropertySymbols(obj); <span class="comment">// 返回一个数组[Symbol('key')]</span></span><br><span class="line">obj[keyArray[<span class="number">0</span>]] <span class="comment">// 'symbol'</span></span><br></pre></td></tr></tbody></table></figure>

<p>BigInt也是ES6新出的一种数据类型，这种数据类型的特点就是数据涵盖的范围大，能够解决超出普通数据类型范围报错的问题。</p>
<p>使用方法：<br>-整数末尾直接+n：647326483767797n<br>-调用BigInt()构造函数：BigInt(“647326483767797”)</p>
<p>注意：BigInt和Number之间不能进行混合操作</p>
<p><img data-src="https://s.poetries.work/images/20210414100319.png" alt="数据类型"></p>
<h3 id="❤-JS-判断变量的类型"><a href="#❤-JS-判断变量的类型" class="headerlink" title="❤ JS 判断变量的类型"></a>❤ JS 判断变量的类型</h3><ul>
<li><strong>得分点：</strong> <code>typeof</code>、<code>instanceof</code>、<code>Object.prototype.toString.call()</code>（对象原型链判断方法）、 <code>constructor</code> (用于引用数据类型)</li>
<li><strong>标准回答：</strong> JS 有4种方法判断变量的类型，分别是<code>typeof</code>、<code>instanceof</code>、<code>Object.prototype.toString.call()</code>（对象原型链判断方法）、 <code>constructor</code> (用于引用数据类型)<ul>
<li><code>typeof</code>：常用于判断基本数据类型，对于引用数据类型除了<code>function</code>返回<code>’function‘</code>，其余全部返回<code>’object'</code>。</li>
<li><code>instanceof</code>：主要用于区分引用数据类型，检测方法是检测的类型在当前实例的原型链上，用其检测出来的结果都是true，不太适合用于简单数据类型的检测，检测过程繁琐且对于简单数据类型中的undefined, null, symbol检测不出来。</li>
<li><code>constructor</code>：用于检测引用数据类型，检测方法是获取实例的构造函数判断和某个类是否相同，如果相同就说明该数据是符合那个数据类型的，这种方法不会把原型链上的其他类也加入进来，避免了原型链的干扰。</li>
<li><code>Object.prototype.toString.call()</code>：适用于所有类型的判断检测，检测方法是<code>Object.prototype.toString.call(数据) </code>返回的是该数据类型的字符串。 这四种判断数据类型的方法中，各种数据类型都能检测且检测精准的就是<code>Object.prototype.toString.call()</code>这种方法。</li>
</ul>
</li>
<li><strong>加分回答：</strong><ul>
<li><code>instanceof</code>的实现原理：验证当前类的原型<code>prototype</code>是否会出现在实例的原型链__proto__上，只要在它的原型链上，则结果都为true。因此，<code>instanceof</code> 在查找的过程中会遍历左边变量的原型链，直到找到右边变量的 <code>prototype</code>，找到返回true，未找到返回false。</li>
<li><code>Object.prototype.toString.call()</code>原理：<code>Object.prototype.toString </code>表示一个返回对象类型的字符串，<code>call()</code>方法可以改变this的指向，那么把<code>Object.prototype.toString()</code>方法指向不同的数据类型上面，返回不同的结果</li>
</ul>
</li>
</ul>
<p><strong>（1）typeof</strong></p>
<blockquote>
<p>typeof 对于原始类型来说，除了 null 都可以显示正确的类型</p>
</blockquote>
<figure class="highlight js"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(<span class="keyword">typeof</span> <span class="number">2</span>);               <span class="comment">// number</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="keyword">typeof</span> <span class="literal">true</span>);            <span class="comment">// boolean</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="keyword">typeof</span> <span class="string">'str'</span>);           <span class="comment">// string</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="keyword">typeof</span> []);              <span class="comment">// object     []数组的数据类型在 typeof 中被解释为 object</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="keyword">typeof</span> <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>{});    <span class="comment">// function</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="keyword">typeof</span> {});              <span class="comment">// object</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="keyword">typeof</span> <span class="literal">undefined</span>);       <span class="comment">// undefined</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="keyword">typeof</span> <span class="literal">null</span>);            <span class="comment">// object     null 的数据类型被 typeof 解释为 object</span></span><br></pre></td></tr></tbody></table></figure>

<blockquote>
<p><code>typeof</code> 对于对象来说，除了函数都会显示 <code>object</code>，所以说 <code>typeof</code> 并不能准确判断变量到底是什么类型,所以想判断一个对象的正确类型，这时候可以考虑使用 <code>instanceof</code></p>
</blockquote>
<p><strong>（2）instanceof</strong></p>
<blockquote>
<p>instanceof<code>可以正确的判断对象的类型，因为内部机制是通过判断对象的原型链中是不是能找到类型的</code>prototype</p>
</blockquote>
<figure class="highlight js"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(<span class="number">2</span> <span class="keyword">instanceof</span> <span class="built_in">Number</span>);                    <span class="comment">// false</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="literal">true</span> <span class="keyword">instanceof</span> <span class="built_in">Boolean</span>);                <span class="comment">// false </span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">'str'</span> <span class="keyword">instanceof</span> <span class="built_in">String</span>);                <span class="comment">// false  </span></span><br><span class="line"><span class="built_in">console</span>.log([] <span class="keyword">instanceof</span> <span class="built_in">Array</span>);                    <span class="comment">// true</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>{} <span class="keyword">instanceof</span> <span class="built_in">Function</span>);       <span class="comment">// true</span></span><br><span class="line"><span class="built_in">console</span>.log({} <span class="keyword">instanceof</span> <span class="built_in">Object</span>);                   <span class="comment">// true    </span></span><br><span class="line"><span class="comment">// console.log(undefined instanceof Undefined);</span></span><br><span class="line"><span class="comment">// console.log(null instanceof Null);</span></span><br></pre></td></tr></tbody></table></figure>

<ul>
<li><code>instanceof</code> 可以准确地判断复杂引用数据类型，但是不能正确判断基础数据类型；</li>
<li>而 <code>typeof</code> 也存在弊端，它虽然可以判断基础数据类型（<code>null</code> 除外），但是引用数据类型中，除了 <code>function</code> 类型以外，其他的也无法判断</li>
</ul>
<figure class="highlight js"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 我们也可以试着实现一下 instanceof</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">_instanceof</span>(<span class="params">left, right</span>) </span>{</span><br><span class="line">    <span class="comment">// 由于instance要检测的是某对象，需要有一个前置判断条件</span></span><br><span class="line">    <span class="comment">//基本数据类型直接返回false</span></span><br><span class="line">    <span class="keyword">if</span>(<span class="keyword">typeof</span> left !== <span class="string">'object'</span> || left === <span class="literal">null</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获得类型的原型</span></span><br><span class="line">    <span class="keyword">let</span> prototype = right.prototype</span><br><span class="line">    <span class="comment">// 获得对象的原型</span></span><br><span class="line">    left = left.__proto__</span><br><span class="line">    <span class="comment">// 判断对象的类型是否等于类型的原型</span></span><br><span class="line">    <span class="keyword">while</span> (<span class="literal">true</span>) {</span><br><span class="line">    	<span class="keyword">if</span> (left === <span class="literal">null</span>)</span><br><span class="line">    		<span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">    	<span class="keyword">if</span> (prototype === left)</span><br><span class="line">    		<span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">    	left = left.__proto__</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">'test'</span>, _instanceof(<span class="literal">null</span>, <span class="built_in">Array</span>)) <span class="comment">// false</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">'test'</span>, _instanceof([], <span class="built_in">Array</span>)) <span class="comment">// true</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">'test'</span>, _instanceof(<span class="string">''</span>, <span class="built_in">Array</span>)) <span class="comment">// false</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">'test'</span>, _instanceof({}, <span class="built_in">Object</span>)) <span class="comment">// true</span></span><br></pre></td></tr></tbody></table></figure>

<p><strong>（3）constructor</strong></p>
<figure class="highlight js"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">console</span>.log((<span class="number">2</span>).constructor === <span class="built_in">Number</span>); <span class="comment">// true</span></span><br><span class="line"><span class="built_in">console</span>.log((<span class="literal">true</span>).constructor === <span class="built_in">Boolean</span>); <span class="comment">// true</span></span><br><span class="line"><span class="built_in">console</span>.log((<span class="string">'str'</span>).constructor === <span class="built_in">String</span>); <span class="comment">// true</span></span><br><span class="line"><span class="built_in">console</span>.log(([]).constructor === <span class="built_in">Array</span>); <span class="comment">// true</span></span><br><span class="line"><span class="built_in">console</span>.log((<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>{}).constructor === <span class="built_in">Function</span>); <span class="comment">// true</span></span><br><span class="line"><span class="built_in">console</span>.log(({}).constructor === <span class="built_in">Object</span>); <span class="comment">// true</span></span><br></pre></td></tr></tbody></table></figure>

<blockquote>
<p>这里有一个坑，如果我创建一个对象，更改它的原型，<code>constructor</code>就会变得不可靠了</p>
</blockquote>
<figure class="highlight js"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Fn</span>(<span class="params"></span>)</span>{};</span><br><span class="line"> </span><br><span class="line">Fn.prototype=<span class="keyword">new</span> <span class="built_in">Array</span>();</span><br><span class="line"> </span><br><span class="line"><span class="keyword">var</span> f=<span class="keyword">new</span> Fn();</span><br><span class="line"> </span><br><span class="line"><span class="built_in">console</span>.log(f.constructor===Fn);    <span class="comment">// false</span></span><br><span class="line"><span class="built_in">console</span>.log(f.constructor===<span class="built_in">Array</span>); <span class="comment">// true </span></span><br></pre></td></tr></tbody></table></figure>

<p><strong>（4）Object.prototype.toString.call()</strong></p>
<blockquote>
<p><code>toString()</code> 是 <code>Object</code> 的原型方法，调用该方法，可以统一返回格式为 <code>“[object Xxx]”</code> 的字符串，其中 <code>Xxx</code> 就是对象的类型。对于 <code>Object</code> 对象，直接调用 <code>toString()</code> 就能返回 <code>[object Object]</code>；而对于其他对象，则需要通过 <code>call</code> 来调用，才能返回正确的类型信息。我们来看一下代码。</p>
</blockquote>
<figure class="highlight js"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Object</span>.prototype.toString({})       <span class="comment">// "[object Object]"</span></span><br><span class="line"><span class="built_in">Object</span>.prototype.toString.call({})  <span class="comment">// 同上结果，加上call也ok</span></span><br><span class="line"><span class="built_in">Object</span>.prototype.toString.call(<span class="number">1</span>)    <span class="comment">// "[object Number]"</span></span><br><span class="line"><span class="built_in">Object</span>.prototype.toString.call(<span class="string">'1'</span>)  <span class="comment">// "[object String]"</span></span><br><span class="line"><span class="built_in">Object</span>.prototype.toString.call(<span class="literal">true</span>)  <span class="comment">// "[object Boolean]"</span></span><br><span class="line"><span class="built_in">Object</span>.prototype.toString.call(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>{})  <span class="comment">// "[object Function]"</span></span><br><span class="line"><span class="built_in">Object</span>.prototype.toString.call(<span class="literal">null</span>)   <span class="comment">//"[object Null]"</span></span><br><span class="line"><span class="built_in">Object</span>.prototype.toString.call(<span class="literal">undefined</span>) <span class="comment">//"[object Undefined]"</span></span><br><span class="line"><span class="built_in">Object</span>.prototype.toString.call(<span class="regexp">/123/g</span>)    <span class="comment">//"[object RegExp]"</span></span><br><span class="line"><span class="built_in">Object</span>.prototype.toString.call(<span class="keyword">new</span> <span class="built_in">Date</span>()) <span class="comment">//"[object Date]"</span></span><br><span class="line"><span class="built_in">Object</span>.prototype.toString.call([])       <span class="comment">//"[object Array]"</span></span><br><span class="line"><span class="built_in">Object</span>.prototype.toString.call(<span class="built_in">document</span>)  <span class="comment">//"[object HTMLDocument]"</span></span><br><span class="line"><span class="built_in">Object</span>.prototype.toString.call(<span class="built_in">window</span>)   <span class="comment">//"[object Window]"</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 从上面这段代码可以看出，Object.prototype.toString.call() 可以很好地判断引用类型，甚至可以把 document 和 window 都区分开来。</span></span><br></pre></td></tr></tbody></table></figure>

<blockquote>
<p>实现一个全局通用的数据类型判断方法，来加深你的理解，代码如下</p>
</blockquote>
<figure class="highlight js"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getType</span>(<span class="params">obj</span>)</span>{</span><br><span class="line">  <span class="keyword">let</span> type  = <span class="keyword">typeof</span> obj;</span><br><span class="line">  <span class="keyword">if</span> (type !== <span class="string">"object"</span>) {    <span class="comment">// 先进行typeof判断，如果是基础数据类型，直接返回</span></span><br><span class="line">    <span class="keyword">return</span> type;</span><br><span class="line">  }</span><br><span class="line">  <span class="comment">// 对于typeof返回结果是object的，再进行如下的判断，正则返回结果</span></span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">Object</span>.prototype.toString.call(obj).replace(<span class="regexp">/^\[object (\S+)\]$/</span>, <span class="string">'$1'</span>);  <span class="comment">// 注意正则中间有个空格</span></span><br><span class="line">}</span><br><span class="line"><span class="comment">/* 代码验证，需要注意大小写，哪些是typeof判断，哪些是toString判断？思考下 */</span></span><br><span class="line">getType([])     <span class="comment">// "Array" typeof []是object，因此toString返回</span></span><br><span class="line">getType(<span class="string">'123'</span>)  <span class="comment">// "string" typeof 直接返回</span></span><br><span class="line">getType(<span class="built_in">window</span>) <span class="comment">// "Window" toString返回</span></span><br><span class="line">getType(<span class="literal">null</span>)   <span class="comment">// "Null"首字母大写，typeof null是object，需toString来判断</span></span><br><span class="line">getType(<span class="literal">undefined</span>)   <span class="comment">// "undefined" typeof 直接返回</span></span><br><span class="line">getType()            <span class="comment">// "undefined" typeof 直接返回</span></span><br><span class="line">getType(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>{}) <span class="comment">// "function" typeof能判断，因此首字母小写</span></span><br><span class="line">getType(<span class="regexp">/123/g</span>)      <span class="comment">//"RegExp" toString返回</span></span><br></pre></td></tr></tbody></table></figure>

<p><strong>小结</strong></p>
<ul>
<li><code>typeof</code><ul>
<li>直接在计算机底层基于数据类型的值（二进制）进行检测</li>
<li><code>typeof null</code>为<code>object</code> 原因是对象存在在计算机中，都是以<code>000</code>开始的二进制存储，所以检测出来的结果是对象</li>
<li><code>typeof</code> 普通对象/数组对象/正则对象/日期对象 都是<code>object</code></li>
<li><code>typeof NaN === 'number'</code></li>
</ul>
</li>
<li><code>instanceof</code><ul>
<li>检测当前实例是否属于这个类的</li>
<li>底层机制：只要当前类出现在实例的原型上，结果都是true</li>
<li>不能检测基本数据类型</li>
</ul>
</li>
<li><code>constructor</code><ul>
<li>支持基本类型</li>
<li>constructor可以随便改，也不准</li>
</ul>
</li>
<li><code>Object.prototype.toString.call([val])</code><ul>
<li>返回当前实例所属类信息</li>
</ul>
</li>
</ul>
<blockquote>
<p>判断 <code>Target</code> 的类型，单单用 <code>typeof</code> 并无法完全满足，这其实并不是 <code>bug</code>，本质原因是 <code>JS</code> 的万物皆对象的理论。因此要真正完美判断时，我们需要区分对待:</p>
</blockquote>
<ul>
<li>基本类型(<code>null</code>): 使用 <code>String(null)</code></li>
<li>基本类型(<code>string / number / boolean / undefined</code>) + <code>function</code>: - 直接使用 <code>typeof</code>即可</li>
<li>其余引用类型(<code>Array / Date / RegExp Error</code>): 调用<code>toString</code>后根据<code>[object XXX]</code>进行判断</li>
</ul>
<h3 id="❤-JS-单线程模型"><a href="#❤-JS-单线程模型" class="headerlink" title="❤ JS 单线程模型"></a>❤ JS 单线程模型</h3><blockquote>
<p>JavaScript语言的一大特点就是单线程，也就是说，同一时间只能做一件事，前面的任务没做完，后面的任务只能等着。</p>
</blockquote>
<p><strong>1. 为什么JavaScript是单线程的呢?</strong></p>
<ul>
<li>这主要与JavaScript用途有关。它的主要用途是与用户互动，以及操作DOM。如果JavaScript是多线程的，会带来很多复杂的问题，假如 JavaScript有A和B两个线程，A线程在DOM节点上添加了内容，B线程删除了这个节点，应该是哪个为准呢? 所以，为了避免复杂性，所以设计成了单线程。</li>
<li>虽然 HTML5 提出了Web Worker标准。Web Worker 的作用，就是为 JavaScript 创造多线程环境，允许主线程创建 Worker 线程，将一些任务分配给后者运行。但是子线程完全受主线程控制，且不得操作DOM。所以这个并没有改变JavaScript单线程的本质。一般使用 Web Worker 的场景是代码中有很多计算密集型或高延迟的任务，可以考虑分配给 Worker 线程。</li>
<li>但是使用的时候一定要注意，worker 线程是为了让你的程序跑的更快，但是如果 worker 线程和主线程之间通信的时间大于了你不使用worker线程的时间，结果就得不偿失了。</li>
</ul>
<p><strong>2. 浏览器内核中线程之间的关系</strong></p>
<ul>
<li>GUI渲染线程和JS引擎线程互斥<ul>
<li>js是可以操作DOM的，如果在修改这些元素的同时渲染页面（js线程和ui线程同时运行），那么渲染线程前后获得的元素数据可能就不一致了。</li>
</ul>
</li>
<li>JS阻塞页面加载<ul>
<li>js如果执行时间过长就会阻塞页面</li>
</ul>
</li>
</ul>
<p><strong>3. 浏览器是多进程的优点</strong></p>
<ul>
<li>默认新开 一个 tab 页面 新建 一个进程,所以单个 tab 页面崩溃不会影响到整个浏览器。</li>
<li>第三方插件崩溃也不会影响到整个浏览器。</li>
<li>多进程可以充分利用现代 CPU 多核的优势。</li>
<li>方便使用沙盒模型隔离插件等进程,提高浏览器的稳定性。</li>
</ul>
<p><strong>4. 进程和线程又是什么呢</strong></p>
<p>进程（process）和线程（thread）是操作系统的基本概念。</p>
<ul>
<li>进程是 CPU 资源分配的最小单位（是能拥有资源和独立运行的最小单位）。</li>
<li>线程是 CPU 调度的最小单位（是建立在进程基础上的一次程序运行单位）。</li>
</ul>
<blockquote>
<p>由于每个进程至少要做一件事,所以一个进程至少有一个线程。系统会给每个进程分配独立的内存,因此进程有它独立的资源。同一进程内的各个线程之间共享该进程的内存空间（包括代码段,数据集,堆等）。</p>
</blockquote>
<p>进程可以理解为一个工厂不不同车间，相互独立。线程是车间里的工人，可以自己做自己的事情,也可以相互配合做同一件事情。</p>
<p><strong>5. 任务队列</strong></p>
<ul>
<li>单线程就意味着，所有任务都要排队执行，前一个任务结束，才会执行后一个任务。</li>
<li>如果一个任务需要执行，但此时JavaScript引擎正在执行其他任务，那么这个任务就需要放到一个队列中进行等待。等到线程空闲时，就可以从这个队列中取出最早加入的任务进行执行（类似于我们去银行排队办理业务，单线程相当于说这家银行只有一个服务窗口，一次只能为一个人服务，后面到的就需要排队，而任务队列就是排队区，先到的就优先服务）</li>
</ul>
<p><strong>注意：</strong> 如果当前线程空闲，并且队列为空，那每次加入队列的函数将立即执行。</p>
<blockquote>
<p>为什么会有任务队列？ 由于 JS 是单线程的，同步执行任务会造成浏览器的阻塞，所以我们将 JS 分成一个又一个的任务，通过不停的循环来执行事件队列中的任务。</p>
</blockquote>
<h3 id="请解释什么是事件代理"><a href="#请解释什么是事件代理" class="headerlink" title="请解释什么是事件代理"></a>请解释什么是事件代理</h3><ul>
<li>事件代理（<code>Event Delegation</code>），又称之为事件委托。是 <code>JavaScript</code> 中常用绑定事件的常用技巧。顾名思义，“事件代理”即是把原本需要绑定的事件委托给父元素，让父元素担当事件监听的职务。事件代理的原理是DOM元素的事件冒泡。使用事件代理的好处是可以提高性能</li>
<li>可以大量节省内存占用，减少事件注册，比如在<code>table</code>上代理所有<code>td</code>的<code>click</code>事件就非常棒</li>
<li>可以实现当新增子对象时无需再次对其绑定</li>
</ul>
<h3 id="事件模型"><a href="#事件模型" class="headerlink" title="事件模型"></a>事件模型</h3><blockquote>
<p><code>W3C</code>中定义事件的发生经历三个阶段：捕获阶段（<code>capturing</code>）、目标阶段（<code>targetin</code>）、冒泡阶段（<code>bubbling</code>）</p>
</blockquote>
<ul>
<li>冒泡型事件：当你使用事件冒泡时，子级元素先触发，父级元素后触发</li>
<li>捕获型事件：当你使用事件捕获时，父级元素先触发，子级元素后触发</li>
<li><code>DOM</code>事件流：同时支持两种事件模型：捕获型事件和冒泡型事件</li>
<li>阻止冒泡：在<code>W3c</code>中，使用<code>stopPropagation()</code>方法；在IE下设置<code>cancelBubble = true</code></li>
<li>阻止捕获：阻止事件的默认行为，例如<code>click - &lt;a&gt;</code>后的跳转。在<code>W3c</code>中，使用<code>preventDefault()</code>方法，在<code>IE</code>下设置<code>window.event.returnValue = false</code></li>
</ul>
<h3 id="❤-数组和数组的区别"><a href="#❤-数组和数组的区别" class="headerlink" title="❤ 数组和数组的区别"></a>❤ 数组和数组的区别</h3><ul>
<li><strong>得分点</strong> 类型是object、不能使用数组方法、可以获取长度、可以使用for in遍历</li>
<li><strong>标准回答</strong> 伪数组它的类型不是Array，而是Object，而数组类型是Array。可以使用的length属性查看长度，也可以使用[index]获取某个元素，但是不能使用数组的其他方法，也不能改变长度，遍历使用<code>for in</code>方法。<ul>
<li>伪数组的常见场景：<ul>
<li>函数的参数<code>arguments </code></li>
<li>原生js获取DOM：<code>document.querySelector('div') </code>等</li>
<li>jquery获取DOM：<code>$(“div”)</code>等</li>
</ul>
</li>
</ul>
</li>
<li><strong>加分回答</strong><ul>
<li>伪数组转换成真数组方法</li>
<li><code>Array.prototype.slice.call(伪数组) </code></li>
<li><code>[].slice.call(伪数组) </code></li>
<li><code>Array.from(伪数组) </code>转换后的数组长度由 <code>length</code> 属性决定。索引不连续时转换结果是连续的，会自动补位。</li>
</ul>
</li>
</ul>
<h3 id="❤-Ajax原理"><a href="#❤-Ajax原理" class="headerlink" title="❤ Ajax原理"></a>❤ Ajax原理</h3><ul>
<li><code>Ajax</code>的原理简单来说是在用户和服务器之间加了—个中间层(<code>AJAX</code>引擎)，通过<code>XmlHttpRequest</code>对象来向服务器发异步请求，从服务器获得数据，然后用<code>javascrip</code>t来操作<code>DOM</code>而更新页面。使用户操作与服务器响应异步化。这其中最关键的一步就是从服务器获得请求数据</li>
<li><code>Ajax</code>的过程只涉及<code>JavaScript</code>、<code>XMLHttpRequest</code>和<code>DOM</code>。<code>XMLHttpRequest</code>是<code>aja</code>x的核心机制</li>
</ul>
<figure class="highlight javascript"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/** 1. 创建Ajax对象 **/</span></span><br><span class="line"><span class="keyword">var</span> xhr = <span class="keyword">new</span> XMLHttpRequest()</span><br><span class="line"><span class="comment">/** 2. 连接服务器 **/</span></span><br><span class="line">xhr.open(<span class="string">'get'</span>, <span class="string">'test.html'</span>, <span class="literal">true</span>)</span><br><span class="line"><span class="comment">/** 3. 发送请求 **/</span></span><br><span class="line">xhr.send();</span><br><span class="line"><span class="comment">/** 4. 接受请求 **/</span></span><br><span class="line">xhr.onreadystatechange = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>{</span><br><span class="line">	<span class="keyword">if</span>(xhr.readyState == <span class="number">4</span>){</span><br><span class="line">        <span class="comment">// 请求的状态码</span></span><br><span class="line">        <span class="comment">// 0:请求还没有建立（open执行前）</span></span><br><span class="line">        <span class="comment">// 1：请求建立了还没发送（执行了open）</span></span><br><span class="line">        <span class="comment">// 2：请求正式发送（执行了send）</span></span><br><span class="line">        <span class="comment">// 3：请求已受理，有部分数据可以用，但还没有处理完成</span></span><br><span class="line">        <span class="comment">// 4：请求完全处理完成</span></span><br><span class="line">		<span class="keyword">if</span>(xhr.status == <span class="number">200</span>){</span><br><span class="line">			success(xhr.responseText);</span><br><span class="line">		} <span class="keyword">else</span> {</span><br><span class="line">			<span class="comment">/** false **/</span></span><br><span class="line">			fail &amp;&amp; fail(xhr.status);</span><br><span class="line">		}</span><br><span class="line">	}</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p><strong>ajax 有那些优缺点?</strong></p>
<ul>
<li>优点：<ul>
<li>通过异步模式，提升了用户体验.</li>
<li>优化了浏览器和服务器之间的传输，减少不必要的数据往返，减少了带宽占用.</li>
<li><code>Ajax</code>在客户端运行，承担了一部分本来由服务器承担的工作，减少了大用户量下的服务器负载。</li>
<li><code>Ajax</code>可以实现动态不刷新（局部刷新）</li>
</ul>
</li>
<li>缺点：<ul>
<li>安全问题 <code>AJAX</code>暴露了与服务器交互的细节。</li>
<li>对搜索引擎的支持比较弱。</li>
<li>不容易调试。</li>
</ul>
</li>
</ul>
<p><strong>牛客网解释：</strong></p>
<ul>
<li><strong>得分点</strong> new XMLHttpRequest()、设置请求参数open()、发送请求request.send()、响应request.onreadystatechange</li>
<li><strong>标准回答</strong> 创建ajax过程：<ol>
<li>创建XHR对象：new XMLHttpRequest()</li>
<li>设置请求参数：request.open(Method, 服务器接口地址);</li>
<li>发送请求: request.send()，如果是get请求不需要参数，post请求需要参数request.send(data)</li>
<li>监听请求成功后的状态变化：根据状态码进行相应的处理。</li>
</ol>
</li>
</ul>
<figure class="highlight js"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">XHR.onreadystatechange = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>{</span><br><span class="line">    <span class="keyword">if</span> (XHR.readyState == <span class="number">4</span> &amp;&amp; XHR.status == <span class="number">200</span>) {</span><br><span class="line">        <span class="built_in">console</span>.log(XHR.responseText);</span><br><span class="line">        <span class="comment">// 主动释放,JS本身也会回收的</span></span><br><span class="line">        XHR = <span class="literal">null</span>;</span><br><span class="line">    }</span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure>

<ul>
<li><strong>加分回答</strong><ul>
<li>POST请求需要设置请求头 readyState值说明<ul>
<li>0：初始化,XHR对象已经创建,还未执行open</li>
<li>1：载入,已经调用open方法,但是还没发送请求</li>
<li>2：载入完成,请求已经发送完成</li>
<li>3：交互,可以接收到部分数据</li>
<li>4：数据全部返回 status值说明<ul>
<li>200：成功</li>
<li>404：没有发现文件、查询或URl</li>
<li>500：服务器产生内部错误</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="模块化开发怎么做？"><a href="#模块化开发怎么做？" class="headerlink" title="模块化开发怎么做？"></a>模块化开发怎么做？</h3><ul>
<li>立即执行函数,不暴露私有成员</li>
</ul>
<figure class="highlight javascript"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> module1 = (<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>{</span><br><span class="line">　　　　<span class="keyword">var</span> _count = <span class="number">0</span>;</span><br><span class="line">　　　　<span class="keyword">var</span> m1 = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>{</span><br><span class="line">　　　　　　<span class="comment">//...</span></span><br><span class="line">　　　　};</span><br><span class="line">　　　　<span class="keyword">var</span> m2 = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>{</span><br><span class="line">　　　　　　<span class="comment">//...</span></span><br><span class="line">　　　　};</span><br><span class="line">　　　　<span class="keyword">return</span> {</span><br><span class="line">　　　　　　m1 : m1,</span><br><span class="line">　　　　　　m2 : m2</span><br><span class="line">　　　　};</span><br><span class="line">})();</span><br></pre></td></tr></tbody></table></figure>



<h3 id="异步加载JS的方式有哪些？"><a href="#异步加载JS的方式有哪些？" class="headerlink" title="异步加载JS的方式有哪些？"></a>异步加载JS的方式有哪些？</h3><ul>
<li>设置<code>&lt;script&gt;</code>属性 async=”async” （一旦脚本可用，则会异步执行）</li>
<li>动态创建 <code>script DOM</code>：<code>document.createElement('script');</code></li>
<li><code>XmlHttpRequest</code> 脚本注入</li>
<li>异步加载库 <code>LABjs</code></li>
<li>模块加载器 <code>Sea.js</code></li>
</ul>
<h3 id="❤-内存泄露"><a href="#❤-内存泄露" class="headerlink" title="❤ 内存泄露"></a>❤ 内存泄露</h3><p><span class="exturl" data-url="aHR0cHM6Ly9pbnRlcnZpZXcyLnBvZXRyaWVzLnRvcC9kb2NzL2V4Y2VsbGVudC1kb2NzLzMtSlMlRTYlQTglQTElRTUlOUQlOTcuaHRtbCNfMTMtJUU1JTg2JTg1JUU1JUFEJTk4JUU2JUIzJTg0JUU5JTlDJUIy">参考链接<i class="fa fa-external-link-alt"></i></span></p>
<h4 id="Chrome-devTools-查看内存情况"><a href="#Chrome-devTools-查看内存情况" class="headerlink" title="Chrome devTools 查看内存情况"></a>Chrome devTools 查看内存情况</h4><blockquote>
<ul>
<li>打开<code>Chrome</code>的无痕模式，这样做的目的是为了屏蔽掉<code>Chrome</code>插件对我们之后测试内存占用情况的影响</li>
<li>打开开发者工具，找到<code>Performance</code>这一栏，可以看到其内部带着一些功能按钮，例如：开始录制按钮；刷新页面按钮；清空记录按钮；记录并可视化js内存、节点、事件监听器按钮；触发垃圾回收机制按钮等</li>
</ul>
</blockquote>
<p><img data-src="https://s.poetries.work/uploads/2022/08/d1451162abd9747e.png" alt="img"></p>
<p>简单录制一下百度页面，看看我们能获得什么，如下动图所示：</p>
<blockquote>
<p>从上图中我们可以看到，在页面从零到加载完成这个过程中<code>JS Heap</code>（js堆内存）、<code>documents</code>（文档）、<code>Nodes</code>（DOM节点）、<code>Listeners</code>（监听器）、<code>GPU memory</code>（<code>GPU</code>内存）的最低值、最高值以及随时间的走势曲线，这也是我们主要关注的点</p>
</blockquote>
<p>看看开发者工具中的<code>Memory</code>一栏，其主要是用于记录页面堆内存的具体情况以及js堆内存随加载时间线动态的分配情况</p>
<p><img data-src="https://s.poetries.work/uploads/2022/08/ef508139131f6abc.png" alt="img"></p>
<p>堆快照就像照相机一样，能记录你当前页面的堆内存情况，每快照一次就会产生一条快照记录</p>
<p><img data-src="https://s.poetries.work/uploads/2022/08/e2a1fe0d0aa4d4fd.png" alt="img"></p>
<blockquote>
<p>如上图所示，刚开始执行了一次快照，记录了当时堆内存空间占用为<code>33.7MB</code>，然后我们点击了页面中某些按钮，又执行一次快照，记录了当时堆内存空间占用为<code>32.5MB</code>。并且点击对应的快照记录，能看到当时所有内存中的变量情况（结构、占总占用内存的百分比…）</p>
</blockquote>
<p><img data-src="https://s.poetries.work/uploads/2022/08/ee6a489b7e87ef0f.png" alt="img"></p>
<blockquote>
<p>在开始记录后，我们可以看到图中右上角有起伏的蓝色与灰色的柱形图，其中<code>蓝色</code>表示当前时间线下占用着的内存；<code>灰色</code>表示之前占用的内存空间已被清除释放</p>
</blockquote>
<p>在得知有内存泄漏的情况存在时，我们可以改用<code>Memory</code>来更明确得确认问题和定位问题</p>
<p>首先可以用<code>Allocation instrumentation on timeline</code>来确认问题，如下图所示：</p>
<h4 id="内存泄漏的场景"><a href="#内存泄漏的场景" class="headerlink" title="内存泄漏的场景"></a>内存泄漏的场景</h4><ul>
<li>闭包使用不当引起内存泄漏</li>
<li>全局变量</li>
<li>分离的<code>DOM</code>节点</li>
<li>控制台的打印</li>
<li>遗忘的定时器</li>
</ul>
<p><strong>1. 闭包使用不当引起内存泄漏</strong></p>
<p>使用<code>Performance</code>和<code>Memory</code>来查看一下闭包导致的内存泄漏问题</p>
<figure class="highlight html"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">button</span> <span class="attr">onclick</span>=<span class="string">"myClick()"</span>&gt;</span>执行fn1函数<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="javascript">    <span class="function"><span class="keyword">function</span> <span class="title">fn1</span> (<span class="params"></span>) </span>{</span></span><br><span class="line"><span class="javascript">        <span class="keyword">let</span> a = <span class="keyword">new</span> <span class="built_in">Array</span>(<span class="number">10000</span>)  <span class="comment">// 这里设置了一个很大的数组对象</span></span></span><br><span class="line"></span><br><span class="line"><span class="javascript">        <span class="keyword">let</span> b = <span class="number">3</span></span></span><br><span class="line"></span><br><span class="line"><span class="javascript">        <span class="function"><span class="keyword">function</span> <span class="title">fn2</span>(<span class="params"></span>) </span>{</span></span><br><span class="line"><span class="javascript">            <span class="keyword">let</span> c = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]</span></span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        fn2()</span><br><span class="line"></span><br><span class="line"><span class="javascript">        <span class="keyword">return</span> a</span></span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line"><span class="javascript">    <span class="keyword">let</span> res = []  </span></span><br><span class="line"></span><br><span class="line"><span class="javascript">    <span class="function"><span class="keyword">function</span> <span class="title">myClick</span>(<span class="params"></span>) </span>{</span></span><br><span class="line">        res.push(fn1())</span><br><span class="line">    }</span><br><span class="line"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></tbody></table></figure>

<blockquote>
<p>在退出<code>fn1</code>函数执行上下文后，该上下文中的变量<code>a</code>本应被当作垃圾数据给回收掉，但因<code>fn1</code>函数最终将变量<code>a</code>返回并赋值给全局变量<code>res</code>，其产生了对变量<code>a</code>的引用，所以变量<code>a</code>被标记为活动变量并一直占用着相应的内存，假设变量<code>res</code>后续用不到，这就算是一种闭包使用不当的例子</p>
</blockquote>
<p><strong>2. 全局变量</strong></p>
<p>全局的变量一般是不会被垃圾回收掉的当然这并不是说变量都不能存在全局，只是有时候会因为疏忽而导致某些变量流失到全局，例如未声明变量，却直接对某变量进行赋值，就会导致该变量在全局创建，如下所示：</p>
<figure class="highlight js"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fn1</span>(<span class="params"></span>) </span>{</span><br><span class="line">    <span class="comment">// 此处变量name未被声明</span></span><br><span class="line">    name = <span class="keyword">new</span> <span class="built_in">Array</span>(<span class="number">99999999</span>)</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">fn1()</span><br></pre></td></tr></tbody></table></figure>

<ul>
<li>此时这种情况就会在全局自动创建一个变量<code>name</code>，并将一个很大的数组赋值给<code>name</code>，又因为是全局变量，所以该内存空间就一直不会被释放</li>
<li>解决办法的话，自己平时要多加注意，不要在变量未声明前赋值，或者也可以<code>开启严格模式</code>，这样就会在不知情犯错时，收到报错警告，例如</li>
</ul>
<figure class="highlight js"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fn1</span>(<span class="params"></span>) </span>{</span><br><span class="line"><span class="meta">    'use strict'</span>;</span><br><span class="line">    name = <span class="keyword">new</span> <span class="built_in">Array</span>(<span class="number">99999999</span>)</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">fn1()</span><br></pre></td></tr></tbody></table></figure>

<p><strong>3. 分离的<code>DOM</code>节点</strong></p>
<p>假设你手动移除了某个<code>dom</code>节点，本应释放该dom节点所占用的内存，但却因为疏忽导致某处代码仍对该被移除节点有引用，最终导致该节点所占内存无法被释放，例如这种情况</p>
<figure class="highlight html"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"root"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"child"</span>&gt;</span>我是子元素<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">button</span>&gt;</span>移除<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="javascript">  <span class="keyword">let</span> btn = <span class="built_in">document</span>.querySelector(<span class="string">'button'</span>)</span></span><br><span class="line"><span class="javascript">  <span class="keyword">let</span> child = <span class="built_in">document</span>.querySelector(<span class="string">'.child'</span>)</span></span><br><span class="line"><span class="javascript">  <span class="keyword">let</span> root = <span class="built_in">document</span>.querySelector(<span class="string">'#root'</span>)</span></span><br><span class="line">  </span><br><span class="line"><span class="javascript">  btn.addEventListener(<span class="string">'click'</span>, <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>{</span></span><br><span class="line">      root.removeChild(child)</span><br><span class="line">  })</span><br><span class="line"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></tbody></table></figure>

<blockquote>
<p>该代码所做的操作就是点击按钮后移除<code>.child</code>的节点，虽然点击后，该节点确实从<code>dom</code>被移除了，但全局变量<code>child</code>仍对该节点有引用，所以导致该节点的内存一直无法被释放，可以尝试用<code>Memory</code>的快照功能来检测一下</p>
</blockquote>
<blockquote>
<p>同样的先记录一下初始状态的快照，然后点击移除按钮后，再点击一次快照，此时内存大小我们看不出什么变化，因为移除的节点占用的内存实在太小了可以忽略不计，但我们可以点击第二条快照记录，在筛选框里输入<code>detached</code>，于是就会展示所有脱离了却又未被清除的节点对象</p>
</blockquote>
<p>解决办法如下图所示：</p>
<figure class="highlight html"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"root"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"child"</span>&gt;</span>我是子元素<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">button</span>&gt;</span>移除<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="javascript">    <span class="keyword">let</span> btn = <span class="built_in">document</span>.querySelector(<span class="string">'button'</span>)</span></span><br><span class="line"></span><br><span class="line"><span class="javascript">    btn.addEventListener(<span class="string">'click'</span>, <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>{  </span></span><br><span class="line"><span class="javascript">        <span class="keyword">let</span> child = <span class="built_in">document</span>.querySelector(<span class="string">'.child'</span>)</span></span><br><span class="line"><span class="javascript">        <span class="keyword">let</span> root = <span class="built_in">document</span>.querySelector(<span class="string">'#root'</span>)</span></span><br><span class="line"></span><br><span class="line">        root.removeChild(child)</span><br><span class="line">    })</span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></tbody></table></figure>

<blockquote>
<p>改动很简单，就是将对<code>.child</code>节点的引用移动到了<code>click</code>事件的回调函数中，那么当移除节点并退出回调函数的执行上文后就会自动清除对该节点的引用，那么自然就不会存在内存泄漏的情况了，我们来验证一下</p>
</blockquote>
<p>结果很明显，这样处理过后就不存在内存泄漏的情况了</p>
<p><strong>4. 控制台的打印</strong></p>
<figure class="highlight html"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">button</span>&gt;</span>按钮<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="javascript">    <span class="built_in">document</span>.querySelector(<span class="string">'button'</span>).addEventListener(<span class="string">'click'</span>, <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>{</span></span><br><span class="line"><span class="javascript">        <span class="keyword">let</span> obj = <span class="keyword">new</span> <span class="built_in">Array</span>(<span class="number">1000000</span>)</span></span><br><span class="line"></span><br><span class="line"><span class="javascript">        <span class="built_in">console</span>.log(obj);</span></span><br><span class="line">    })</span><br><span class="line"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></tbody></table></figure>

<p>我们在按钮的点击回调事件中创建了一个很大的数组对象并打印，用<code>performance</code>来验证一下</p>
<blockquote>
<p>开始录制，先触发一次垃圾回收清除初始的内存，然后点击三次按钮，即执行了三次点击事件，最后再触发一次垃圾回收。查看录制结果发现<code>JS Heap</code>曲线成阶梯上升，并且最终保持的高度比初始基准线高很多，这说明每次执行点击事件创建的很大的数组对象<code>obj</code>都因为<code>console.log</code>被浏览器保存了下来并且无法被回收</p>
</blockquote>
<p>接下来注释掉<code>console.log</code>，再来看一下结果：</p>
<figure class="highlight html"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">button</span>&gt;</span>按钮<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="javascript">    <span class="built_in">document</span>.querySelector(<span class="string">'button'</span>).addEventListener(<span class="string">'click'</span>, <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>{</span></span><br><span class="line"><span class="javascript">        <span class="keyword">let</span> obj = <span class="keyword">new</span> <span class="built_in">Array</span>(<span class="number">1000000</span>)</span></span><br><span class="line"></span><br><span class="line"><span class="javascript">        <span class="comment">// console.log(obj);</span></span></span><br><span class="line">    })</span><br><span class="line"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></tbody></table></figure>

<p>可以看到没有打印以后，每次创建的<code>obj</code>都立马被销毁了，并且最终触发垃圾回收机制后跟初始的基准线同样高，说明已经不存在内存泄漏的现象了</p>
<p>其实同理 <code>console.log</code>也可以用<code>Memory</code>来进一步验证</p>
<blockquote>
<p>最后简单总结一下：在开发环境下，可以使用控制台打印便于调试，但是在生产环境下，尽可能得不要在控制台打印数据。所以我们经常会在代码中看到类似如下的操作：</p>
</blockquote>
<figure class="highlight js"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 如果在开发环境下，打印变量obj</span></span><br><span class="line"><span class="keyword">if</span>(isDev) {</span><br><span class="line">    <span class="built_in">console</span>.log(obj)</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<blockquote>
<p>这样就避免了生产环境下无用的变量打印占用一定的内存空间，同样的除了<code>console.log</code>之外，<code>console.error</code>、<code>console.info</code>、<code>console.dir</code>等等都不要在生产环境下使用</p>
</blockquote>
<p><strong>5. 遗忘的定时器</strong></p>
<blockquote>
<p>定时器也是平时很多人会忽略的一个问题，比如定义了定时器后就再也不去考虑清除定时器了，这样其实也会造成一定的内存泄漏。来看一个代码示例：</p>
</blockquote>
<figure class="highlight html"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">button</span>&gt;</span>开启定时器<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="javascript">    <span class="function"><span class="keyword">function</span> <span class="title">fn1</span>(<span class="params"></span>) </span>{</span></span><br><span class="line"><span class="javascript">        <span class="keyword">let</span> largeObj = <span class="keyword">new</span> <span class="built_in">Array</span>(<span class="number">100000</span>)</span></span><br><span class="line"></span><br><span class="line"><span class="javascript">        <span class="built_in">setInterval</span>(<span class="function">() =&gt;</span> {</span></span><br><span class="line"><span class="javascript">            <span class="keyword">let</span> myObj = largeObj</span></span><br><span class="line">        }, 1000)</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line"><span class="javascript">    <span class="built_in">document</span>.querySelector(<span class="string">'button'</span>).addEventListener(<span class="string">'click'</span>, <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>{</span></span><br><span class="line">        fn1()</span><br><span class="line">    })</span><br><span class="line"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></tbody></table></figure>

<p>这段代码是在点击按钮后执行<code>fn1</code>函数，<code>fn1</code>函数内创建了一个很大的数组对象<code>largeObj</code>，同时创建了一个<code>setInterval</code>定时器，定时器的回调函数只是简单的引用了一下变量<code>largeObj</code>，我们来看看其整体的内存分配情况吧：</p>
<p>按道理来说点击按钮执行<code>fn1</code>函数后会退出该函数的执行上下文，紧跟着函数体内的局部变量应该被清除，但图中<code>performance</code>的录制结果显示似乎是存在内存泄漏问题的，即最终曲线高度比基准线高度要高，那么再用<code>Memory</code>来确认一次：</p>
<ul>
<li>在我们点击按钮后，从动态内存分配的图上看到出现一个蓝色柱形，说明浏览器为变量<code>largeObj</code>分配了一段内存，但是之后这段内存并没有被释放掉，说明的确存在内存泄漏的问题，原因其实就是因为<code>setInterval</code>的回调函数内对变量<code>largeObj</code>有一个引用关系，而定时器一直未被清除，所以变量<code>largeObj</code>的内存也自然不会被释放</li>
<li>那么我们如何来解决这个问题呢，假设我们只需要让定时器执行三次就可以了，那么我们可以改动一下代码：</li>
</ul>
<figure class="highlight html"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">button</span>&gt;</span>开启定时器<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="javascript">    <span class="function"><span class="keyword">function</span> <span class="title">fn1</span>(<span class="params"></span>) </span>{</span></span><br><span class="line"><span class="javascript">        <span class="keyword">let</span> largeObj = <span class="keyword">new</span> <span class="built_in">Array</span>(<span class="number">100000</span>)</span></span><br><span class="line"><span class="javascript">        <span class="keyword">let</span> index = <span class="number">0</span></span></span><br><span class="line"></span><br><span class="line"><span class="javascript">        <span class="keyword">let</span> timer = <span class="built_in">setInterval</span>(<span class="function">() =&gt;</span> {</span></span><br><span class="line"><span class="javascript">            <span class="keyword">if</span>(index === <span class="number">3</span>) <span class="built_in">clearInterval</span>(timer);</span></span><br><span class="line"><span class="javascript">            <span class="keyword">let</span> myObj = largeObj</span></span><br><span class="line">            index ++</span><br><span class="line">        }, 1000)</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line"><span class="javascript">    <span class="built_in">document</span>.querySelector(<span class="string">'button'</span>).addEventListener(<span class="string">'click'</span>, <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>{</span></span><br><span class="line">        fn1()</span><br><span class="line">    })</span><br><span class="line"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></tbody></table></figure>

<p>现在我们再通过<code>performance</code>和<code>memory</code>来看看还不会存在内存泄漏的问题</p>
<ul>
<li><code>performance</code></li>
</ul>
<blockquote>
<p>这次的录制结果就能看出，最后的曲线高度和初始基准线的高度一样，说明并没有内存泄漏的情况</p>
</blockquote>
<ul>
<li><code>memory</code></li>
</ul>
<p>这里做一个解释，图中刚开始出现的蓝色柱形是因为我在录制后刷新了页面，可以忽略；然后我们点击了按钮，看到又出现了一个蓝色柱形，此时就是为<code>fn1</code>函数中的变量<code>largeObj</code>分配了内存，<code>3s</code>后该内存又被释放了，即变成了灰色柱形。所以我们可以得出结论，这段代码不存在内存泄漏的问题</p>
<blockquote>
<p>简单总结一下： 大家在平时用到了定时器，如果在用不到定时器后一定要清除掉，否则就会出现本例中的情况。除了<code>setTimeout</code>和<code>setInterval</code>，其实浏览器还提供了一个<code>API</code>也可能就存在这样的问题，那就是<code>requestAnimationFrame</code></p>
</blockquote>
<h4 id="JS-内存泄漏-整合"><a href="#JS-内存泄漏-整合" class="headerlink" title="JS 内存泄漏 整合"></a>JS 内存泄漏 整合</h4><blockquote>
<p>JavaScript 内存泄露指对象在不需要使用它时仍然存在，导致占用的内存不能使用或回收</p>
</blockquote>
<ul>
<li>未使用 var 声明的全局变量</li>
<li>闭包函数(Closures)</li>
<li>循环引用(两个对象相互引用)</li>
<li>控制台日志(console.log)</li>
<li>移除存在绑定事件的DOM元素(IE)</li>
<li><code>setTimeout</code> 的第一个参数使用字符串而非函数的话，会引发内存泄漏</li>
<li>垃圾回收器定期扫描对象，并计算引用了每个对象的其他对象的数量。如果一个对象的引用数量为 0（没有其他对象引用过该对象），或对该对象的唯一引用是循环的，那么该对象的内存即可回收</li>
</ul>
<h3 id="❤-null，undefined-的区别，如何让一个属性变为null"><a href="#❤-null，undefined-的区别，如何让一个属性变为null" class="headerlink" title="❤ null，undefined 的区别，如何让一个属性变为null"></a>❤ null，undefined 的区别，如何让一个属性变为null</h3><ul>
<li><code>undefined</code> 表示不存在这个值。</li>
<li><code>undefined</code> :是一个表示”无”的原始值或者说表示”缺少值”，就是此处应该有一个值，但是还没有定义。当尝试读取时会返回 <code>undefined</code></li>
<li>例如变量被声明了，但没有赋值时，就等于<code>undefined</code></li>
<li><code>null</code> 表示一个对象被定义了，值为“空值”</li>
<li><code>null</code> : 是一个对象(空对象, 没有任何属性和方法)</li>
<li>例如作为函数的参数，表示该函数的参数不是对象；</li>
<li>在验证<code>null</code>时，一定要使用　<code>===</code> ，因为 <code>==</code>无法分别<code>null</code> 和　<code>undefined</code></li>
</ul>
<p><strong>牛客网解释：</strong></p>
<ul>
<li><strong>得分点：</strong>操作的变量没有被赋值、全局对象的一个属性、函数没有return返回值、值 <code>null</code> 特指对象的值未设置 undefined == null、undefined !== null</li>
<li><strong>标准回答：</strong><ul>
<li><strong>undefind</strong> 是全局对象的一个属性，当一个变量没有被赋值或者一个函数没有返回值或者某个对象不存在某个属性却去访问或者函数定义了形参但没有传递实参，这时候都是undefined。undefined通过typeof判断类型是’undefined’。undefined == undefined undefined === undefined 。</li>
<li><strong>null</strong>代表对象的值未设置，相当于一个对象没有设置指针地址就是null。null通过typeof判断类型是’object’。null === null null == null null == undefined null !== undefined undefined 表示一个变量初始状态值，而 null 则表示一个变量被人为的设置为空对象，而不是原始状态。在实际使用过程中，不需要对一个变量显式的赋值 undefined，当需要释放一个对象时，直接赋值为 null 即可。 让一个变量为null，直接给该变量赋值为null即可。</li>
</ul>
</li>
<li><strong>加分回答：</strong> null 其实属于自己的类型 Null，而不属于Object类型，typeof 之所以会判定为 Object 类型，是因为JavaScript 数据类型在底层都是以二进制的形式表示的，二进制的前三位为 0 会被 typeof 判断为对象类型，而 null 的二进制位恰好都是 0 ，因此，null 被误判断为 Object 类型。 对象被赋值了null 以后，对象对应的堆内存中的值就是游离状态了，GC 会择机回收该值并释放内存。因此，需要释放某个对象，就将变量设置为 null，即表示该对象已经被清空，目前无效状态。</li>
</ul>
<h3 id="let-与-var的区别"><a href="#let-与-var的区别" class="headerlink" title="let 与 var的区别"></a>let 与 var的区别</h3><ul>
<li><code>let</code>命令不存在变量提升，如果在<code>let</code>前使用，会导致报错</li>
<li>如果块区中存在<code>let</code>和<code>const</code>命令，就会形成封闭作用域</li>
<li>不允许重复声明，因此，不能在函数内部重新声明参数</li>
</ul>
<h3 id="let-var-const"><a href="#let-var-const" class="headerlink" title="let var const"></a>let var const</h3><p><strong>let</strong></p>
<ul>
<li>允许你声明一个作用域被限制在块级中的变量、语句或者表达式</li>
<li>let绑定不受变量提升的约束，这意味着let声明不会被提升到当前</li>
<li>该变量处于从块开始到初始化处理的“暂存死区”</li>
</ul>
<p><strong>var</strong></p>
<ul>
<li>声明变量的作用域限制在其声明位置的上下文中，而非声明变量总是全局的</li>
<li>由于变量声明（以及其他声明）总是在任意代码执行之前处理的，所以在代码中的任意位置声明变量总是等效于在代码开头声明</li>
</ul>
<p><strong>const</strong></p>
<ul>
<li>声明创建一个值的只读引用 (即指针)</li>
<li>基本数据当值发生改变时，那么其对应的指针也将发生改变，故造成 <code>const</code>申明基本数据类型时</li>
<li>再将其值改变时，将会造成报错， 例如 <code>const a = 3</code> ; <code>a = 5</code>时 将会报错</li>
<li>但是如果是复合类型时，如果只改变复合类型的其中某个<code>Value</code>项时， 将还是正常使用</li>
</ul>
<h3 id="❤-map-与-forEach的区别"><a href="#❤-map-与-forEach的区别" class="headerlink" title="❤ map 与 forEach的区别"></a>❤ map 与 forEach的区别</h3><ul>
<li><code>forEach</code>方法，是最基本的方法，就是遍历与循环，默认有3个传参：分别是遍历的数组内容<code>item</code>、数组索引<code>index</code>、和当前遍历数组<code>Array</code></li>
<li><code>map</code>方法，基本用法与<code>forEach</code>一致，但是不同的，它会返回一个新的数组，所以在callback需要有<code>return</code>值，如果没有，会返回<code>undefined</code></li>
</ul>
<ul>
<li><strong>得分点</strong> map创建新数组、map返回处理后的值、forEach()不修改原数组、forEach()方法返回undefined</li>
<li><strong>标准回答</strong><ul>
<li>map 和 forEach 的<strong>区别</strong>：<ul>
<li>map有返回值，可以开辟新空间，return出来一个length和原数组一致的数组，即便数组元素是undefined或者是null。forEach默认无返回值，返回结果为undefined，可以通过在函数体内部使用索引修改数组元素。</li>
</ul>
</li>
</ul>
</li>
<li><strong>加分回答</strong> map的处理速度比forEach快，而且返回一个新的数组，方便链式调用其他数组新方法，比如filter、reduce</li>
</ul>
<figure class="highlight js"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> arr = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>];</span><br><span class="line"><span class="keyword">let</span> arr2 = arr.map(<span class="function"><span class="params">value</span> =&gt;</span> value * value).filter(<span class="function"><span class="params">value</span> =&gt;</span> value &gt; <span class="number">10</span>);</span><br><span class="line"><span class="comment">// arr2 = [16, 25]</span></span><br></pre></td></tr></tbody></table></figure>



<h3 id="谈一谈你理解的函数式编程"><a href="#谈一谈你理解的函数式编程" class="headerlink" title="谈一谈你理解的函数式编程"></a>谈一谈你理解的函数式编程</h3><ul>
<li>简单说，”函数式编程”是一种”编程范式”（programming paradigm），也就是如何编写程序的方法论</li>
<li>它具有以下特性：闭包和高阶函数、惰性计算、递归、函数是”第一等公民”、只用”表达式”</li>
</ul>
<h3 id="❤-JS-实现异步编程的方法"><a href="#❤-JS-实现异步编程的方法" class="headerlink" title="❤ JS 实现异步编程的方法"></a>❤ JS 实现异步编程的方法</h3><ul>
<li>回调函数<ul>
<li>优点：简单、容易理解</li>
<li>缺点：不利于维护，代码耦合高</li>
</ul>
</li>
<li>事件监听(采用时间驱动模式，取决于某个事件是否发生)：<ul>
<li>优点：容易理解，可以绑定多个事件，每个事件可以指定多个回调函数</li>
<li>缺点：事件驱动型，流程不够清晰</li>
</ul>
</li>
<li>发布/订阅(观察者模式)<ul>
<li>类似于事件监听，但是可以通过‘消息中心’，了解现在有多少发布者，多少订阅者</li>
</ul>
</li>
<li>Promise对象<ul>
<li>优点：可以利用then方法，进行链式写法；可以书写错误时的回调函数；</li>
<li>缺点：编写和理解，相对比较难</li>
</ul>
</li>
<li>Generator函数<ul>
<li>优点：函数体内外的数据交换、错误处理机制</li>
<li>缺点：流程管理不方便</li>
</ul>
</li>
<li>async函数<ul>
<li>优点：内置执行器、更好的语义、更广的适用性、返回的是Promise、结构清晰。</li>
<li>缺点：错误处理机制</li>
</ul>
</li>
</ul>
<ul>
<li><strong>得分点：</strong> 回调函数、事件监听、setTimeout、Promise、生成器Generators/yield、async/awt</li>
<li><strong>标准回答：</strong> 所有异步任务都是在同步任务执行结束之后，从任务队列中依次取出执行。<ul>
<li><strong>回调函数</strong>是异步操作最基本的方法，比如AJAX回调，回调函数的<strong>优点</strong>是简单、容易理解和实现，<strong>缺点</strong>是不利于代码的阅读和维护，各个部分之间高度耦合，使得程序结构混乱、流程难以追踪（尤其是多个回调函数嵌套的情况），而且每个任务只能指定一个回调函数。此外它不能使用 try catch 捕获错误，不能直接 return Promise包装了一个异步调用并生成一个Promise实例，当异步调用返回的时候根据调用的结果分别调用实例化时传入的resolve 和 reject方法，then接收到对应的数据，做出相应的处理。</li>
<li><strong>Promise对象</strong>不仅能够捕获错误，而且也很好地解决了回调地狱的问题，<strong>缺点</strong>是无法取消 Promise，错误需要通过回调函数捕获。</li>
<li><strong>Generator 函数</strong>是 ES6 提供的一种异步编程解决方案，Generator 函数是一个状态机，封装了多个内部状态，可暂停函数, yield可暂停，next方法可启动，每次返回的是yield后的表达式结果。<strong>优点</strong>是异步语义清晰，<strong>缺点</strong>是手动迭代<code>Generator</code> 函数很麻烦，实现逻辑有点绕</li>
<li><strong>async/awt</strong>是基于Promise实现的，async/awt使得异步代码看起来像同步代码，所以<strong>优点</strong>是，使用方法清晰明了，<strong>缺点</strong>是awt 将异步代码改造成了同步代码，如果多个异步代码没有依赖性却使用了 awt 会导致性能上的降低，代码没有依赖性的话，完全可以使用 Promise.all 的方式。</li>
</ul>
</li>
<li><strong>加分回答：</strong> JS 异步编程进化史：callback -&gt; promise -&gt; generator/yield -&gt; async/awt。 async/awt函数对 Generator 函数的改进，体现在以下三点：<ul>
<li> <strong>内置执行器。</strong> Generator 函数的执行必须靠执行器，而 async 函数自带执行器。也就是说，async 函数的执行，与普通函数一模一样，只要一行。</li>
<li> <strong>更广的适用性。</strong> yield 命令后面只能是 Thunk 函数或 Promise 对象，而 async 函数的 awt 命令后面，可以跟 Promise 对象和原始类型的值（数值、字符串和布尔值，但这时等同于同步操作）。</li>
<li> <strong>更好的语义。</strong> async 和 awt，比起星号和 yield，语义更清楚了。async 表示函数里有异步操作，awt 表示紧跟在后面的表达式需要等待结果。 目前使用很广泛的就是promise和async/awt</li>
</ul>
</li>
</ul>
<h3 id="❤-数组去重方法总结"><a href="#❤-数组去重方法总结" class="headerlink" title="❤ 数组去重方法总结"></a>❤ 数组去重方法总结</h3><p><strong>方法一、利用ES6 Set去重（ES6中最常用）</strong></p>
<figure class="highlight js"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">unique</span> (<span class="params">arr</span>) </span>{</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">Array</span>.from(<span class="keyword">new</span> <span class="built_in">Set</span>(arr))</span><br><span class="line">}</span><br><span class="line"><span class="keyword">var</span> arr = [<span class="number">1</span>,<span class="number">1</span>,<span class="string">'true'</span>,<span class="string">'true'</span>,<span class="literal">true</span>,<span class="literal">true</span>,<span class="number">15</span>,<span class="number">15</span>,<span class="literal">false</span>,<span class="literal">false</span>, <span class="literal">undefined</span>,<span class="literal">undefined</span>, <span class="literal">null</span>,<span class="literal">null</span>, <span class="literal">NaN</span>, <span class="literal">NaN</span>,<span class="string">'NaN'</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="string">'a'</span>, <span class="string">'a'</span>,{},{}];</span><br><span class="line"><span class="built_in">console</span>.log(unique(arr))</span><br><span class="line"><span class="comment">//[1, "true", true, 15, false, undefined, null, NaN, "NaN", 0, "a", {}, {}]</span></span><br></pre></td></tr></tbody></table></figure>

<p><strong>方法二、利用for嵌套for，然后splice去重（ES5中最常用）</strong></p>
<figure class="highlight js"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">unique</span>(<span class="params">arr</span>)</span>{</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">var</span> i=<span class="number">0</span>; i&lt;arr.length; i++){</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">var</span> j=i+<span class="number">1</span>; j&lt;arr.length; j++){</span><br><span class="line">                <span class="keyword">if</span>(arr[i]==arr[j]){         <span class="comment">//第一个等同于第二个，splice方法删除第二个</span></span><br><span class="line">                    arr.splice(j,<span class="number">1</span>);</span><br><span class="line">                    j--;</span><br><span class="line">                }</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">	<span class="keyword">return</span> arr;</span><br><span class="line">}</span><br><span class="line"><span class="keyword">var</span> arr = [<span class="number">1</span>,<span class="number">1</span>,<span class="string">'true'</span>,<span class="string">'true'</span>,<span class="literal">true</span>,<span class="literal">true</span>,<span class="number">15</span>,<span class="number">15</span>,<span class="literal">false</span>,<span class="literal">false</span>, <span class="literal">undefined</span>,<span class="literal">undefined</span>, <span class="literal">null</span>,<span class="literal">null</span>, <span class="literal">NaN</span>, <span class="literal">NaN</span>,<span class="string">'NaN'</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="string">'a'</span>, <span class="string">'a'</span>,{},{}];</span><br><span class="line"><span class="built_in">console</span>.log(unique(arr))</span><br><span class="line"><span class="comment">//[1, "true", 15, false, undefined, NaN, NaN, "NaN", "a", {…}, {…}]     //NaN和{}没有去重，两个null直接消失了</span></span><br></pre></td></tr></tbody></table></figure>

<ul>
<li>双层循环，外层循环元素，内层循环时比较值。值相同时，则删去这个值。</li>
<li>想快速学习更多常用的<code>ES6</code>语法</li>
</ul>
<p><strong>方法三、利用indexOf去重</strong></p>
<figure class="highlight js"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">unique</span>(<span class="params">arr</span>) </span>{</span><br><span class="line">    <span class="keyword">if</span> (!<span class="built_in">Array</span>.isArray(arr)) {</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">'type error!'</span>)</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">var</span> array = [];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; arr.length; i++) {</span><br><span class="line">        <span class="keyword">if</span> (array.indexOf(arr[i]) === -<span class="number">1</span>) {</span><br><span class="line">            array.push(arr[i])</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">return</span> array;</span><br><span class="line">}</span><br><span class="line"><span class="keyword">var</span> arr = [<span class="number">1</span>,<span class="number">1</span>,<span class="string">'true'</span>,<span class="string">'true'</span>,<span class="literal">true</span>,<span class="literal">true</span>,<span class="number">15</span>,<span class="number">15</span>,<span class="literal">false</span>,<span class="literal">false</span>, <span class="literal">undefined</span>,<span class="literal">undefined</span>, <span class="literal">null</span>,<span class="literal">null</span>, <span class="literal">NaN</span>, <span class="literal">NaN</span>,<span class="string">'NaN'</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="string">'a'</span>, <span class="string">'a'</span>,{},{}];</span><br><span class="line"><span class="built_in">console</span>.log(unique(arr))</span><br><span class="line"><span class="comment">// [1, "true", true, 15, false, undefined, null, NaN, NaN, "NaN", 0, "a", {…}, {…}]  //NaN、{}没有去重</span></span><br></pre></td></tr></tbody></table></figure>

<blockquote>
<p>新建一个空的结果数组，<code>for</code> 循环原数组，判断结果数组是否存在当前元素，如果有相同的值则跳过，不相同则<code>push</code>进数组</p>
</blockquote>
<p><strong>方法四、利用sort()</strong></p>
<figure class="highlight js"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">unique</span>(<span class="params">arr</span>) </span>{</span><br><span class="line">    <span class="keyword">if</span> (!<span class="built_in">Array</span>.isArray(arr)) {</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">'type error!'</span>)</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    }</span><br><span class="line">    arr = arr.sort()</span><br><span class="line">    <span class="keyword">var</span> arrry= [arr[<span class="number">0</span>]];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">1</span>; i &lt; arr.length; i++) {</span><br><span class="line">        <span class="keyword">if</span> (arr[i] !== arr[i-<span class="number">1</span>]) {</span><br><span class="line">            arrry.push(arr[i]);</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">return</span> arrry;</span><br><span class="line">}</span><br><span class="line"><span class="keyword">var</span> arr = [<span class="number">1</span>,<span class="number">1</span>,<span class="string">'true'</span>,<span class="string">'true'</span>,<span class="literal">true</span>,<span class="literal">true</span>,<span class="number">15</span>,<span class="number">15</span>,<span class="literal">false</span>,<span class="literal">false</span>, <span class="literal">undefined</span>,<span class="literal">undefined</span>, <span class="literal">null</span>,<span class="literal">null</span>, <span class="literal">NaN</span>, <span class="literal">NaN</span>,<span class="string">'NaN'</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="string">'a'</span>, <span class="string">'a'</span>,{},{}];</span><br><span class="line"><span class="built_in">console</span>.log(unique(arr))</span><br><span class="line"><span class="comment">// [0, 1, 15, "NaN", NaN, NaN, {…}, {…}, "a", false, null, true, "true", undefined]      //NaN、{}没有去重</span></span><br></pre></td></tr></tbody></table></figure>

<blockquote>
<p>利用<code>sort()</code>排序方法，然后根据排序后的结果进行遍历及相邻元素比对</p>
</blockquote>
<p><strong>方法五、利用对象的属性不能相同的特点进行去重</strong></p>
<figure class="highlight js"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">unique</span>(<span class="params">arr</span>) </span>{</span><br><span class="line">    <span class="keyword">if</span> (!<span class="built_in">Array</span>.isArray(arr)) {</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">'type error!'</span>)</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">var</span> arrry= [];</span><br><span class="line">     <span class="keyword">var</span>  obj = {};</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; arr.length; i++) {</span><br><span class="line">        <span class="keyword">if</span> (!obj[arr[i]]) {</span><br><span class="line">            arrry.push(arr[i])</span><br><span class="line">            obj[arr[i]] = <span class="number">1</span></span><br><span class="line">        } <span class="keyword">else</span> {</span><br><span class="line">            obj[arr[i]]++</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">return</span> arrry;</span><br><span class="line">}</span><br><span class="line"><span class="keyword">var</span> arr = [<span class="number">1</span>,<span class="number">1</span>,<span class="string">'true'</span>,<span class="string">'true'</span>,<span class="literal">true</span>,<span class="literal">true</span>,<span class="number">15</span>,<span class="number">15</span>,<span class="literal">false</span>,<span class="literal">false</span>, <span class="literal">undefined</span>,<span class="literal">undefined</span>, <span class="literal">null</span>,<span class="literal">null</span>, <span class="literal">NaN</span>, <span class="literal">NaN</span>,<span class="string">'NaN'</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="string">'a'</span>, <span class="string">'a'</span>,{},{}];</span><br><span class="line"><span class="built_in">console</span>.log(unique(arr))</span><br><span class="line"><span class="comment">//[1, "true", 15, false, undefined, null, NaN, 0, "a", {…}]    //两个true直接去掉了，NaN和{}去重</span></span><br></pre></td></tr></tbody></table></figure>

<p><strong>方法六、利用includes</strong></p>
<figure class="highlight js"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">unique</span>(<span class="params">arr</span>) </span>{</span><br><span class="line">    <span class="keyword">if</span> (!<span class="built_in">Array</span>.isArray(arr)) {</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">'type error!'</span>)</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">var</span> array =[];</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; arr.length; i++) {</span><br><span class="line">            <span class="keyword">if</span>( !array.includes( arr[i]) ) {<span class="comment">//includes 检测数组是否有某个值</span></span><br><span class="line">                    array.push(arr[i]);</span><br><span class="line">              }</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">return</span> array</span><br><span class="line">}</span><br><span class="line"><span class="keyword">var</span> arr = [<span class="number">1</span>,<span class="number">1</span>,<span class="string">'true'</span>,<span class="string">'true'</span>,<span class="literal">true</span>,<span class="literal">true</span>,<span class="number">15</span>,<span class="number">15</span>,<span class="literal">false</span>,<span class="literal">false</span>, <span class="literal">undefined</span>,<span class="literal">undefined</span>, <span class="literal">null</span>,<span class="literal">null</span>, <span class="literal">NaN</span>, <span class="literal">NaN</span>,<span class="string">'NaN'</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="string">'a'</span>, <span class="string">'a'</span>,{},{}];</span><br><span class="line"><span class="built_in">console</span>.log(unique(arr))</span><br><span class="line">    <span class="comment">//[1, "true", true, 15, false, undefined, null, NaN, "NaN", 0, "a", {…}, {…}]     //{}没有去重</span></span><br></pre></td></tr></tbody></table></figure>

<p><strong>方法七、利用hasOwnProperty</strong></p>
<figure class="highlight js"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">unique</span>(<span class="params">arr</span>) </span>{</span><br><span class="line">    <span class="keyword">var</span> obj = {};</span><br><span class="line">    <span class="keyword">return</span> arr.filter(<span class="function"><span class="keyword">function</span>(<span class="params">item, index, arr</span>)</span>{</span><br><span class="line">        <span class="keyword">return</span> obj.hasOwnProperty(<span class="keyword">typeof</span> item + item) ? <span class="literal">false</span> : (obj[<span class="keyword">typeof</span> item + item] = <span class="literal">true</span>)</span><br><span class="line">    })</span><br><span class="line">}</span><br><span class="line">    <span class="keyword">var</span> arr = [<span class="number">1</span>,<span class="number">1</span>,<span class="string">'true'</span>,<span class="string">'true'</span>,<span class="literal">true</span>,<span class="literal">true</span>,<span class="number">15</span>,<span class="number">15</span>,<span class="literal">false</span>,<span class="literal">false</span>, <span class="literal">undefined</span>,<span class="literal">undefined</span>, <span class="literal">null</span>,<span class="literal">null</span>, <span class="literal">NaN</span>, <span class="literal">NaN</span>,<span class="string">'NaN'</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="string">'a'</span>, <span class="string">'a'</span>,{},{}];</span><br><span class="line">        <span class="built_in">console</span>.log(unique(arr))</span><br><span class="line"><span class="comment">//[1, "true", true, 15, false, undefined, null, NaN, "NaN", 0, "a", {…}]   //所有的都去重了</span></span><br></pre></td></tr></tbody></table></figure>

<blockquote>
<p>利用<code>hasOwnProperty</code> 判断是否存在对象属性</p>
</blockquote>
<p><strong>方法八、利用filter</strong></p>
<figure class="highlight js"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">unique</span>(<span class="params">arr</span>) </span>{</span><br><span class="line">  <span class="keyword">return</span> arr.filter(<span class="function"><span class="keyword">function</span>(<span class="params">item, index, arr</span>) </span>{</span><br><span class="line">    <span class="comment">//当前元素，在原始数组中的第一个索引==当前索引值，否则返回当前元素</span></span><br><span class="line">    <span class="keyword">return</span> arr.indexOf(item, <span class="number">0</span>) === index;</span><br><span class="line">  });</span><br><span class="line">}</span><br><span class="line"><span class="keyword">var</span> arr = [<span class="number">1</span>,<span class="number">1</span>,<span class="string">'true'</span>,<span class="string">'true'</span>,<span class="literal">true</span>,<span class="literal">true</span>,<span class="number">15</span>,<span class="number">15</span>,<span class="literal">false</span>,<span class="literal">false</span>, <span class="literal">undefined</span>,<span class="literal">undefined</span>, <span class="literal">null</span>,<span class="literal">null</span>, <span class="literal">NaN</span>, <span class="literal">NaN</span>,<span class="string">'NaN'</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="string">'a'</span>, <span class="string">'a'</span>,{},{}];</span><br><span class="line"><span class="built_in">console</span>.log(unique(arr))</span><br><span class="line"><span class="comment">//[1, "true", true, 15, false, undefined, null, "NaN", 0, "a", {…}, {…}]</span></span><br></pre></td></tr></tbody></table></figure>

<p><strong>方法九、利用递归去重</strong></p>
<figure class="highlight js"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">unique</span>(<span class="params">arr</span>) </span>{</span><br><span class="line">    <span class="keyword">var</span> array= arr;</span><br><span class="line">    <span class="keyword">var</span> len = array.length;</span><br><span class="line"></span><br><span class="line">	array.sort(<span class="function"><span class="keyword">function</span>(<span class="params">a,b</span>)</span>{   <span class="comment">//排序后更加方便去重</span></span><br><span class="line">		<span class="keyword">return</span> a - b;</span><br><span class="line">	})</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">function</span> <span class="title">loop</span>(<span class="params">index</span>)</span>{</span><br><span class="line">        <span class="keyword">if</span>(index &gt;= <span class="number">1</span>){</span><br><span class="line">            <span class="keyword">if</span>(array[index] === array[index-<span class="number">1</span>]){</span><br><span class="line">            array.splice(index,<span class="number">1</span>);</span><br><span class="line">            }</span><br><span class="line">            loop(index - <span class="number">1</span>);    <span class="comment">//递归loop，然后数组去重</span></span><br><span class="line">        }</span><br><span class="line">	}</span><br><span class="line">	loop(len-<span class="number">1</span>);</span><br><span class="line">	<span class="keyword">return</span> array;</span><br><span class="line">}</span><br><span class="line"><span class="keyword">var</span> arr = [<span class="number">1</span>,<span class="number">1</span>,<span class="string">'true'</span>,<span class="string">'true'</span>,<span class="literal">true</span>,<span class="literal">true</span>,<span class="number">15</span>,<span class="number">15</span>,<span class="literal">false</span>,<span class="literal">false</span>, <span class="literal">undefined</span>,<span class="literal">undefined</span>, <span class="literal">null</span>,<span class="literal">null</span>, <span class="literal">NaN</span>, <span class="literal">NaN</span>,<span class="string">'NaN'</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="string">'a'</span>, <span class="string">'a'</span>,{},{}];</span><br><span class="line"><span class="built_in">console</span>.log(unique(arr))</span><br><span class="line"><span class="comment">//[1, "a", "true", true, 15, false, 1, {…}, null, NaN, NaN, "NaN", 0, "a", {…}, undefined]</span></span><br></pre></td></tr></tbody></table></figure>

<p><strong>方法十、利用Map数据结构去重</strong></p>
<figure class="highlight js"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">arrayNonRepeatfy</span>(<span class="params">arr</span>) </span>{</span><br><span class="line">	<span class="keyword">let</span> map = <span class="keyword">new</span> <span class="built_in">Map</span>();</span><br><span class="line">		<span class="keyword">let</span> array = <span class="keyword">new</span> <span class="built_in">Array</span>();  <span class="comment">// 数组用于返回结果</span></span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; arr.length; i++) {</span><br><span class="line">			<span class="keyword">if</span>(map .has(arr[i])) {  <span class="comment">// 如果有该key值</span></span><br><span class="line">			map .set(arr[i], <span class="literal">true</span>);</span><br><span class="line">		} <span class="keyword">else</span> {</span><br><span class="line">			map .set(arr[i], <span class="literal">false</span>);   <span class="comment">// 如果没有该key值</span></span><br><span class="line">			array .push(arr[i]);</span><br><span class="line">		}</span><br><span class="line">	}</span><br><span class="line">	<span class="keyword">return</span> array ;</span><br><span class="line">}</span><br><span class="line"> <span class="keyword">var</span> arr = [<span class="number">1</span>,<span class="number">1</span>,<span class="string">'true'</span>,<span class="string">'true'</span>,<span class="literal">true</span>,<span class="literal">true</span>,<span class="number">15</span>,<span class="number">15</span>,<span class="literal">false</span>,<span class="literal">false</span>, <span class="literal">undefined</span>,<span class="literal">undefined</span>, <span class="literal">null</span>,<span class="literal">null</span>, <span class="literal">NaN</span>, <span class="literal">NaN</span>,<span class="string">'NaN'</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="string">'a'</span>, <span class="string">'a'</span>,{},{}];</span><br><span class="line">    <span class="built_in">console</span>.log(unique(arr))</span><br><span class="line"><span class="comment">//[1, "a", "true", true, 15, false, 1, {…}, null, NaN, NaN, "NaN", 0, "a", {…}, undefined]</span></span><br></pre></td></tr></tbody></table></figure>

<blockquote>
<p>创建一个空<code>Map</code>数据结构，遍历需要去重的数组，把数组的每一个元素作为<code>key</code>存到<code>Map</code>中。由于<code>Map</code>中不会出现相同的<code>key</code>值，所以最终得到的就是去重后的结果</p>
</blockquote>
<p><strong>方法十一、利用reduce+includes</strong></p>
<figure class="highlight js"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">unique</span>(<span class="params">arr</span>)</span>{</span><br><span class="line">    <span class="keyword">return</span> arr.reduce(<span class="function">(<span class="params">prev,cur</span>) =&gt;</span> prev.includes(cur) ? prev : [...prev,cur],[]);</span><br><span class="line">}</span><br><span class="line"><span class="keyword">var</span> arr = [<span class="number">1</span>,<span class="number">1</span>,<span class="string">'true'</span>,<span class="string">'true'</span>,<span class="literal">true</span>,<span class="literal">true</span>,<span class="number">15</span>,<span class="number">15</span>,<span class="literal">false</span>,<span class="literal">false</span>, <span class="literal">undefined</span>,<span class="literal">undefined</span>, <span class="literal">null</span>,<span class="literal">null</span>, <span class="literal">NaN</span>, <span class="literal">NaN</span>,<span class="string">'NaN'</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="string">'a'</span>, <span class="string">'a'</span>,{},{}];</span><br><span class="line"><span class="built_in">console</span>.log(unique(arr));</span><br><span class="line"><span class="comment">// [1, "true", true, 15, false, undefined, null, NaN, "NaN", 0, "a", {…}, {…}]</span></span><br></pre></td></tr></tbody></table></figure>

<p><strong>方法十二、[…new Set(arr)]</strong></p>
<figure class="highlight js"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[...new <span class="built_in">Set</span>(arr)]</span><br><span class="line"><span class="comment">//代码就是这么少----（其实，严格来说并不算是一种，相对于第一种方法来说只是简化了代码）</span></span><br></pre></td></tr></tbody></table></figure>



<p><strong>牛客网解释：</strong></p>
<ul>
<li><strong>得分点：</strong> 对象属性、new Set() 、indexOf、hasOwnProperty、reduce+includes、filter</li>
<li><strong>标准回答：</strong><ul>
<li><strong>第一种方法：</strong>利用对象属性key排除重复项：遍历数组，每次判断对象中是否存在该属性，不存在就存储在新数组中，并且把数组元素作为key，设置一个值，存储在对象中，最后返回新数组。这个方法的<strong>优点</strong>是效率较高，<strong>缺点</strong>是占用了较多空间，使用的额外空间有一个查询对象和一个新的数组</li>
<li><strong>第二种方法：</strong>利用Set类型数据无重复项：new 一个 Set，参数为需要去重的数组，Set 会自动删除重复的元素，再将 Set 转为数组返回。这个方法的<strong>优点</strong>是效率更高，代码简单，思路清晰，<strong>缺点</strong>是可能会有兼容性问题</li>
<li><strong>第三种方法：</strong>filter+indexof 去重：这个方法和第一种方法类似，利用 Array 自带的 filter 方法，返回 arr.indexOf(num) 等于 index 的num。原理就是 indexOf 会返回最先找到的数字的索引，假设数组是 [1, 1]，在对第二个1使用 indexOf 方法时，返回的是第一个1的索引0。这个方法的<strong>优点</strong>是可以在去重的时候插入对元素的操作，可拓展性强。</li>
<li><strong>第四种方法：</strong>这个方法比较巧妙，从头遍历数组，如果元素在前面出现过，则将当前元素挪到最后面，继续遍历，直到遍历完所有元素，之后将那些被挪到后面的元素抛弃。这个方法因为是直接操作数组，占用内存较少。</li>
<li><strong>第五种方法：</strong>reduce +includes去重：这个方法就是利用reduce遍历和传入一个空数组作为去重后的新数组，然后内部判断新数组中是否存在当前遍历的元素，不存在就插入到新数组中。这种方法时间消耗多，内存空间也有额外占用。</li>
<li>方法还有很多，常用的、了解的这些就可以</li>
</ul>
</li>
<li><strong>加分回答：</strong> 以上五个方法中，在数据低于10000条的时候没有明显的差别，高于10000条，第一种和第二种的时间消耗最少，后面三种时间消耗依次增加，由于第一种内存空间消耗比较多，且现在很多项目不再考虑低版本浏览器的兼容性问题，所以建议使用第二种去重方法，简洁方便。</li>
</ul>
<h3 id="（设计题）想实现一个对页面某个节点的拖曳？如何做？（使用原生JS）"><a href="#（设计题）想实现一个对页面某个节点的拖曳？如何做？（使用原生JS）" class="headerlink" title="（设计题）想实现一个对页面某个节点的拖曳？如何做？（使用原生JS）"></a>（设计题）想实现一个对页面某个节点的拖曳？如何做？（使用原生JS）</h3><ul>
<li>给需要拖拽的节点绑定<code>mousedown</code>, <code>mousemove</code>, <code>mouseup</code>事件</li>
<li><code>mousedown</code>事件触发后，开始拖拽</li>
<li><code>mousemove</code>时，需要通过<code>event.clientX</code>和<code>clientY</code>获取拖拽位置，并实时更新位置</li>
<li><code>mouseup</code>时，拖拽结束</li>
<li>需要注意浏览器边界的情况</li>
</ul>
<h3 id="❤-JS-全局函数和全局变量"><a href="#❤-JS-全局函数和全局变量" class="headerlink" title="❤ JS 全局函数和全局变量"></a>❤ JS 全局函数和全局变量</h3><p><strong>全局变量</strong></p>
<ul>
<li><code>Infinity</code> 代表正的无穷大的数值。</li>
<li><code>NaN</code> 指示某个值是不是数字值。</li>
<li><code>undefined</code> 指示未定义的值。</li>
</ul>
<p><strong>全局函数</strong></p>
<ul>
<li><code>decodeURI()</code> 解码某个编码的 <code>URI</code>。</li>
<li><code>decodeURIComponent()</code> 解码一个编码的 <code>URI</code> 组件。</li>
<li><code>encodeURI()</code> 把字符串编码为 URI。</li>
<li><code>encodeURIComponent()</code> 把字符串编码为 <code>URI</code> 组件。</li>
<li><code>escape()</code> 对字符串进行编码。</li>
<li><code>eval()</code> 计算 <code>JavaScript</code> 字符串，并把它作为脚本代码来执行。</li>
<li><code>isFinite()</code> 检查某个值是否为有穷大的数。</li>
<li><code>isNaN()</code> 检查某个值是否是数字。</li>
<li><code>Number()</code> 把对象的值转换为数字。</li>
<li><code>parseFloat()</code> 解析一个字符串并返回一个浮点数。</li>
<li><code>parseInt()</code> 解析一个字符串并返回一个整数。</li>
<li><code>String()</code> 把对象的值转换为字符串。</li>
<li><code>unescape()</code> 对由<code>escape()</code> 编码的字符串进行解码</li>
</ul>
<h3 id="❤-深浅拷贝"><a href="#❤-深浅拷贝" class="headerlink" title="❤ 深浅拷贝"></a>❤ 深浅拷贝</h3><p><span class="exturl" data-url="aHR0cHM6Ly9pbnRlcnZpZXcyLnBvZXRyaWVzLnRvcC9kb2NzL2Jhc2UvaW1wcm92ZS5odG1sI18yMS0lRTYlQjclQjElRTYlQjUlODUlRTYlOEIlQjclRTglQjQlOUQ=">参考链接<i class="fa fa-external-link-alt"></i></span></p>
<h4 id="浅拷贝"><a href="#浅拷贝" class="headerlink" title="浅拷贝"></a><strong>浅拷贝</strong></h4><ul>
<li><p><code>Object.assign(target, ...sources)</code> 是 ES6 中 <code>object</code> 的一个方法</p>
<ul>
<li>不会拷贝对象的继承属性；</li>
<li>不会拷贝对象的不可枚举的属性；</li>
<li>可以拷贝 <code>Symbol</code> 类型的属性。</li>
</ul>
<figure class="highlight js"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> target = {};</span><br><span class="line"><span class="keyword">let</span> source = { <span class="attr">a</span>: { <span class="attr">b</span>: <span class="number">1</span> } };</span><br><span class="line"><span class="built_in">Object</span>.assign(target, source);</span><br><span class="line"><span class="built_in">console</span>.log(target); <span class="comment">// { a: { b: 1 } };</span></span><br></pre></td></tr></tbody></table></figure>

<p>依旧存在着访问<strong>共同堆内存</strong>的问题，也就是说<strong>这种方法还不能进一步复制，而只是完成了浅拷贝的功能</strong></p>
</li>
<li><p><strong>扩展运算符方式</strong></p>
<ul>
<li>利用 JS 的扩展运算符，在构造对象的同时完成浅拷贝的功能。</li>
<li>扩展运算符的语法为：<code>let cloneObj = { ...obj };</code></li>
</ul>
<figure class="highlight js"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 对象的拷贝 */</span></span><br><span class="line"><span class="keyword">let</span> obj = {<span class="attr">a</span>:<span class="number">1</span>,<span class="attr">b</span>:{<span class="attr">c</span>:<span class="number">1</span>}}</span><br><span class="line"><span class="keyword">let</span> obj2 = {...obj}</span><br><span class="line">obj.a = <span class="number">2</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">'obj'</span>, obj)  <span class="comment">//{a:2,b:{c:1}} </span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">'obj2'</span>, obj2); <span class="comment">//{a:1,b:{c:1}}</span></span><br><span class="line">obj.b.c = <span class="number">2</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">'obj'</span>, obj)  <span class="comment">//{a:2,b:{c:2}} </span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">'obj2'</span>, obj2); <span class="comment">//{a:1,b:{c:2}}</span></span><br><span class="line"><span class="comment">/* 数组的拷贝 */</span></span><br><span class="line"><span class="keyword">let</span> arr = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>];</span><br><span class="line"><span class="keyword">let</span> newArr = [...arr]; <span class="comment">//跟arr.slice()是一样的效果</span></span><br></pre></td></tr></tbody></table></figure>

<blockquote>
<p>扩展运算符 和 <code>object.assign</code> 有同样的缺陷，也就是<code>实现的浅拷贝的功能差不多</code>，但是如果属性都是<code>基本类型的值，使用扩展运算符进行浅拷贝会更加方便</code></p>
</blockquote>
</li>
<li><p><strong>concat 拷贝数组</strong></p>
<blockquote>
<p>数组的 <code>concat</code> 方法其实也是浅拷贝，所以连接一个含有引用类型的数组时，需要注意修改原数组中的元素的属性，因为它会影响拷贝之后连接的数组。不过 <code>concat</code> 只能用于数组的浅拷贝，使用场景比较局限。</p>
</blockquote>
<figure class="highlight js"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> arr = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>];</span><br><span class="line"><span class="keyword">let</span> newArr = arr.concat();</span><br><span class="line">newArr[<span class="number">1</span>] = <span class="number">100</span>;</span><br><span class="line"><span class="built_in">console</span>.log(arr);    <span class="comment">// [ 1, 2, 3 ]</span></span><br><span class="line"><span class="built_in">console</span>.log(newArr); <span class="comment">// [ 1, 100, 3 ]</span></span><br></pre></td></tr></tbody></table></figure></li>
<li><p><strong>slice 拷贝数组</strong></p>
<blockquote>
<p><code>slice</code> 方法也比较有局限性，因为<code>它仅仅针对数组类型</code>。<code>slice方法会返回一个新的数组对象</code>，这一对象由该方法的前两个参数来决定原数组截取的开始和结束时间，是不会影响和改变原始数组的。</p>
<p>slice 的语法为：<code>arr.slice(begin, end);</code></p>
</blockquote>
<figure class="highlight js"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> arr = [<span class="number">1</span>, <span class="number">2</span>, {<span class="attr">val</span>: <span class="number">4</span>}];</span><br><span class="line"><span class="keyword">let</span> newArr = arr.slice();</span><br><span class="line">newArr[<span class="number">2</span>].val = <span class="number">1000</span>;</span><br><span class="line"><span class="built_in">console</span>.log(arr);     <span class="comment">//[ 1, 2, { val: 1000 } ]</span></span><br><span class="line"><span class="built_in">console</span>.log(newArr);  <span class="comment">//[ 1, 2, { val: 1000 } ]</span></span><br></pre></td></tr></tbody></table></figure></li>
</ul>
<blockquote>
<p>从上面的代码中可以看出，这就是<code>浅拷贝的限制所在了——它只能拷贝一层对象</code>。如果<code>存在对象的嵌套，那么浅拷贝将无能为力</code>。因此深拷贝就是为了解决这个问题而生的，它能解决多层对象嵌套问题，彻底实现拷贝</p>
</blockquote>
<p><strong>手工实现一个浅拷贝</strong></p>
<ul>
<li>暂时不写</li>
</ul>
<h4 id="深拷贝"><a href="#深拷贝" class="headerlink" title="深拷贝"></a><strong>深拷贝</strong></h4><blockquote>
<p><code>浅拷贝只是创建了一个新的对象，复制了原有对象的基本类型的值，而引用数据类型只拷贝了一层属性，再深层的还是无法进行拷贝</code>。深拷贝则不同，对于复杂引用数据类型，其在堆内存中完全开辟了一块内存地址，并将原有的对象完全复制过来存放。</p>
<p>这两个对象是相互独立、不受影响的，彻底实现了内存上的分离。总的来说，<code>深拷贝的原理可以总结如下</code>：</p>
<p>将一个对象从内存中完整地拷贝出来一份给目标对象，并从堆内存中开辟一个全新的空间存放新对象，且新对象的修改并不会改变原对象，二者实现真正的分离。</p>
</blockquote>
<ul>
<li><p><strong>乞丐版（<code>JSON.stringify</code>）</strong></p>
<blockquote>
<p><code>JSON.stringify()</code> 是目前开发过程中最简单的深拷贝方法，其实就是把一个对象序列化成为 <code>JSON</code> 的字符串，并将对象里面的内容转换成字符串，最后再用 <code>JSON.parse()</code> 的方法将 <code>JSON</code> 字符串生成一个新的对象</p>
</blockquote>
<figure class="highlight js"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> a = {</span><br><span class="line">    age: <span class="number">1</span>,</span><br><span class="line">    jobs: {<span class="attr">first</span>: <span class="string">'FE'</span>}</span><br><span class="line">}</span><br><span class="line"><span class="keyword">let</span> b = <span class="built_in">JSON</span>.parse(<span class="built_in">JSON</span>.stringify(a))</span><br><span class="line">a.jobs.first = <span class="string">'native'</span></span><br><span class="line"><span class="built_in">console</span>.log(b.jobs.first) <span class="comment">// FE</span></span><br></pre></td></tr></tbody></table></figure>

<p><strong>该方法也是有局限性的</strong></p>
<ul>
<li>会忽略 <code>undefined</code></li>
<li>会忽略 <code>symbol</code></li>
<li>不能序列化函数</li>
<li>无法拷贝不可枚举的属性</li>
<li>无法拷贝对象的原型链</li>
<li>拷贝 <code>RegExp</code> 引用类型会变成空对象</li>
<li>拷贝 <code>Date</code> 引用类型会变成字符串</li>
<li>对象中含有 <code>NaN</code>、<code>Infinity</code> 以及 <code>-Infinity</code>，<code>JSON</code> 序列化的结果会变成 <code>null</code></li>
<li>不能解决循环引用的对象，即对象成环 (<code>obj[key] = obj</code>)</li>
</ul>
<blockquote>
<p>使用 <code>JSON.stringify</code> 方法实现深拷贝对象，虽然到目前为止还有很多无法实现的功能，但是这种方法足以满足日常的开发需求，并且是最简单和快捷的。而对于其他的也要实现深拷贝的，比较麻烦的属性对应的数据类型，<code>JSON.stringify</code> 暂时还是无法满足的，那么就需要下面的几种方法了</p>
</blockquote>
</li>
<li><p><strong>基础版（手写递归实现）</strong></p>
<blockquote>
<p>下面是一个实现 deepClone 函数封装的例子，通过 <code>for in</code> 遍历传入参数的属性值，如果值是引用类型则再次递归调用该函数，如果是基础数据类型就直接复制</p>
</blockquote>
<figure class="highlight js"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> obj1 = {<span class="attr">a</span>:{<span class="attr">b</span>:<span class="number">1</span>}}</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">deepClone</span>(<span class="params">obj</span>) </span>{ </span><br><span class="line">  <span class="keyword">let</span> cloneObj = {}</span><br><span class="line">  <span class="keyword">for</span>(<span class="keyword">let</span> key <span class="keyword">in</span> obj) {                 <span class="comment">//遍历</span></span><br><span class="line">    <span class="keyword">if</span>(<span class="keyword">typeof</span> obj[key] ===<span class="string">'object'</span>) { </span><br><span class="line">      cloneObj[key] = deepClone(obj[key])  <span class="comment">//是对象就再次调用该函数递归</span></span><br><span class="line">    } <span class="keyword">else</span> {</span><br><span class="line">      cloneObj[key] = obj[key]  <span class="comment">//基本类型的话直接复制值</span></span><br><span class="line">    }</span><br><span class="line">  }</span><br><span class="line">  <span class="keyword">return</span> cloneObj</span><br><span class="line">}</span><br><span class="line"><span class="keyword">let</span> obj2 = deepClone(obj1);</span><br><span class="line">obj1.a.b = <span class="number">2</span>;</span><br><span class="line"><span class="built_in">console</span>.log(obj2);   <span class="comment">//  {a:{b:1}}</span></span><br></pre></td></tr></tbody></table></figure>

<p>虽然利用递归能实现一个深拷贝，但是同上面的 <code>JSON.stringify</code> 一样，还是有一些问题没有完全解决，例如：</p>
<ul>
<li>这个深拷贝函数并不能复制不可枚举的属性以及 <code>Symbol</code> 类型；</li>
<li>这种方法<code>只是针对普通的引用类型的值做递归复制</code>，而对于 <code>Array、Date、RegExp、Error、Function</code> 这样的引用类型并不能正确地拷贝；</li>
<li>对象的属性里面成环，即<code>循环引用没有解决</code>。</li>
</ul>
<p>这种基础版本的写法也比较简单，可以应对大部分的应用情况。但是你在面试的过程中，如果只能写出这样的一个有缺陷的深拷贝方法，有可能不会通过。</p>
<p>所以为了“拯救”这些缺陷，下面我带你一起看看改进的版本，以便于你可以在面试种呈现出更好的深拷贝方法，赢得面试官的青睐。</p>
</li>
<li><p><strong>改进版（改进后递归实现）</strong></p>
<blockquote>
<p>针对上面几个待解决问题，我先通过四点相关的理论告诉你分别应该怎么做。</p>
</blockquote>
<ul>
<li>针对能够遍历对象的不可枚举属性以及 <code>Symbol</code> 类型，我们可以使用 <code>Reflect.ownKeys</code> 方法；</li>
<li>当参数为 <code>Date、RegExp</code> 类型，则直接生成一个新的实例返回；</li>
<li>利用 <code>Object</code> 的 <code>getOwnPropertyDescriptors</code> 方法可以获得对象的所有属性，以及对应的特性，顺便结合 <code>Object.create</code> 方法创建一个新对象，并继承传入原对象的原型链；</li>
<li>利用 <code>WeakMap</code> 类型作为 <code>Hash</code> 表，因为 <code>WeakMap</code> 是弱引用类型，可以有效防止内存泄漏（你可以关注一下 <code>Map</code> 和 <code>weakMap</code> 的关键区别，这里要用 <code>weakMap</code>），作为检测循环引用很有帮助，如果存在循环，则引用直接返回 <code>WeakMap</code> 存储的值</li>
</ul>
<p>如果你在考虑到循环引用的问题之后，还能用 <code>WeakMap</code> 来很好地解决，并且向面试官解释这样做的目的，那么你所展示的代码，以及你对问题思考的全面性，在面试官眼中应该算是合格的了</p>
<p><strong>实现深拷贝</strong></p>
<figure class="highlight js"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> isComplexDataType = <span class="function"><span class="params">obj</span> =&gt;</span> (<span class="keyword">typeof</span> obj === <span class="string">'object'</span> || <span class="keyword">typeof</span> obj === <span class="string">'function'</span>) &amp;&amp; (obj !== <span class="literal">null</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> deepClone = <span class="function"><span class="keyword">function</span> (<span class="params">obj, hash = <span class="keyword">new</span> <span class="built_in">WeakMap</span>()</span>) </span>{</span><br><span class="line">  <span class="keyword">if</span> (obj.constructor === <span class="built_in">Date</span>) {</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Date</span>(obj)       <span class="comment">// 日期对象直接返回一个新的日期对象</span></span><br><span class="line">  }</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">if</span> (obj.constructor === <span class="built_in">RegExp</span>){</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">RegExp</span>(obj)     <span class="comment">//正则对象直接返回一个新的正则对象</span></span><br><span class="line">  }</span><br><span class="line">  </span><br><span class="line">  <span class="comment">//如果循环引用了就用 weakMap 来解决</span></span><br><span class="line">  <span class="keyword">if</span> (hash.has(obj)) {</span><br><span class="line">    <span class="keyword">return</span> hash.get(obj)</span><br><span class="line">  }</span><br><span class="line">  <span class="keyword">let</span> allDesc = <span class="built_in">Object</span>.getOwnPropertyDescriptors(obj)</span><br><span class="line"></span><br><span class="line">  <span class="comment">//遍历传入参数所有键的特性</span></span><br><span class="line">  <span class="keyword">let</span> cloneObj = <span class="built_in">Object</span>.create(<span class="built_in">Object</span>.getPrototypeOf(obj), allDesc)</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 把cloneObj原型复制到obj上</span></span><br><span class="line">  hash.set(obj, cloneObj)</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> key <span class="keyword">of</span> <span class="built_in">Reflect</span>.ownKeys(obj)) { </span><br><span class="line">    cloneObj[key] = (isComplexDataType(obj[key]) &amp;&amp; <span class="keyword">typeof</span> obj[key] !== <span class="string">'function'</span>) ? deepClone(obj[key], hash) : obj[key]</span><br><span class="line">  }</span><br><span class="line">  <span class="keyword">return</span> cloneObj</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure></li>
</ul>
<h3 id="❤-防抖-节流"><a href="#❤-防抖-节流" class="headerlink" title="❤ 防抖/节流"></a>❤ 防抖/节流</h3><h4 id="防抖"><a href="#防抖" class="headerlink" title="防抖"></a>防抖</h4><blockquote>
<p>在滚动事件中需要做个复杂计算或者实现一个按钮的防二次点击操作。可以通过函数防抖动来实现</p>
</blockquote>
<figure class="highlight js"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 函数防抖的实现 最后一次实现</span></span><br><span class="line"><span class="comment">// 应用场景：</span></span><br><span class="line"><span class="comment">// 登录、发短信等按钮避免用户点击太快，以致于发送了多次请求，需要防抖</span></span><br><span class="line"><span class="comment">// 文本编辑器实时保存，当无任何更改操作一秒后进行保存</span></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* <span class="doctag">@description</span>:</span></span><br><span class="line"><span class="comment">* <span class="doctag">@param <span class="type">{Function}</span> <span class="variable">fn</span></span></span></span><br><span class="line"><span class="comment">* <span class="doctag">@param <span class="type">{number}</span> <span class="variable">wait</span></span></span></span><br><span class="line"><span class="comment">* <span class="doctag">@return <span class="type">{*}</span></span></span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">debounce</span> (<span class="params">fn, wait</span>) </span>{</span><br><span class="line">    <span class="keyword">let</span> timer = <span class="literal">null</span></span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>{</span><br><span class="line">        <span class="keyword">var</span> context = <span class="built_in">this</span>,</span><br><span class="line">            args = <span class="built_in">arguments</span></span><br><span class="line">        <span class="comment">// 如果此时存在定时器的话，则取消之前的定时器重新记时</span></span><br><span class="line">        <span class="keyword">if</span> (timer) {</span><br><span class="line">            <span class="built_in">clearTimeout</span>(timer)</span><br><span class="line">            timer = <span class="literal">null</span></span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 设置定时器，使事件间隔指定事件后执行</span></span><br><span class="line">        timer = <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> {</span><br><span class="line">            fn.apply(context, args)</span><br><span class="line">        }, wait)</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>对于按钮防点击来说的实现</p>
<ul>
<li>开始一个定时器，只要我定时器还在，不管你怎么点击都不会执行回调函数。一旦定时器结束并设置为 null，就可以再次点击了</li>
<li>对于<strong>延时执行函数</strong>来说的实现：每次调用防抖动函数都会判断本次调用和之前的时间间隔，如果小于需要的时间间隔，就会重新创建一个定时器，并且定时器的延时为设定时间减去之前的时间间隔。一旦时间到了，就会执行相应的回调函数</li>
</ul>
<h4 id="节流"><a href="#节流" class="headerlink" title="节流"></a>节流</h4><blockquote>
<p>防抖动和节流本质是不一样的。防抖动是将多次执行变为最后一次执行，节流是将多次执行变成每隔一段时间执行</p>
<p>函数节流(<code>throttle</code>)是指阻止一个函数在很短时间间隔内连续调用。 只有当上一次函数执行后达到规定的时间间隔，才能进行下一次调用。 但要保证一个累计最小调用间隔（否则拖拽类的节流都将无连续效果）</p>
<p>函数节流的原理：使用定时器做时间节流。 当触发一个事件时，先用 <code>setTimout</code> 让这个事件延迟一小段时间再执行。 如果在这个时间间隔内又触发了事件，就 <code>clearTimeout</code> 原来的定时器， 再 <code>setTimeout</code> 一个新的定时器重复以上流程。</p>
</blockquote>
<figure class="highlight js"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 节流：我们这里的节流指的就是在自定义的一段时间内让事件进行触发</span></span><br><span class="line"><span class="comment">// 应用场景：用于 `onresize`, `onscroll` 等短时间内会多次触发的事件</span></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* <span class="doctag">@description</span>:</span></span><br><span class="line"><span class="comment">* <span class="doctag">@param <span class="type">{*}</span> </span>fn 中间体</span></span><br><span class="line"><span class="comment">* <span class="doctag">@param <span class="type">{*}</span> </span>delay 间隔一段时间执行</span></span><br><span class="line"><span class="comment">* <span class="doctag">@return <span class="type">{*}</span></span></span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">throttle</span> (<span class="params">fn, delay</span>) </span>{</span><br><span class="line">    <span class="keyword">let</span> timer = <span class="literal">null</span></span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>{</span><br><span class="line">        <span class="keyword">var</span> context = <span class="built_in">this</span>,</span><br><span class="line">            args = <span class="built_in">arguments</span></span><br><span class="line">        <span class="keyword">if</span> (timer) {</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        }</span><br><span class="line">        timer = <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> {</span><br><span class="line">            timer = <span class="literal">null</span></span><br><span class="line">            fn.apply(context, args)</span><br><span class="line">        }, delay)</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>



<h3 id="❤-事件循环Event-loop，宏任务与微任务"><a href="#❤-事件循环Event-loop，宏任务与微任务" class="headerlink" title="❤ 事件循环Event loop，宏任务与微任务"></a>❤ 事件循环<code>Event loop</code>，宏任务与微任务</h3><blockquote>
<p>首先，<code>js</code>是单线程的，主要的任务是处理用户的交互，而用户的交互无非就是响应<code>DOM</code>的增删改，使用事件队列的形式，一次事件循环只处理一个事件响应，使得脚本执行相对连续，所以有了事件队列，用来储存待执行的事件，那么事件队列的事件从哪里被<code>push</code>进来的呢。那就是另外一个线程叫事件触发线程做的事情了，他的作用主要是在定时触发器线程、异步<code>HTTP</code>请求线程满足特定条件下的回调函数<code>push</code>到事件队列中，等待<code>js</code>引擎空闲的时候去执行，当然js引擎执行过程中有优先级之分，首先js引擎在一次事件循环中，会先执行js线程的主任务，然后会去查找是否有微任务<code>microtask（promise）</code>，如果有那就优先执行微任务，如果没有，在去查找宏任务<code>macrotask（setTimeout、setInterval）</code>进行执行</p>
</blockquote>
<blockquote>
<p>众所周知 <code>JS</code> 是门非阻塞单线程语言，因为在最初 <code>JS</code> 就是为了和浏览器交互而诞生的。如果 <code>JS</code> 是门多线程的语言话，我们在多个线程中处理 <code>DOM</code> 就可能会发生问题（一个线程中新加节点，另一个线程中删除节点）</p>
</blockquote>
<ul>
<li><code>JS</code> 在执行的过程中会产生执行环境，这些执行环境会被顺序的加入到执行栈中。如果遇到异步的代码，会被挂起并加入到 <code>Task</code>（有多种 <code>task</code>） 队列中。一旦执行栈为空，<code>Event</code> <code>Loop</code> 就会从 <code>Task</code> 队列中拿出需要执行的代码并放入执行栈中执行，所以本质上来说 <code>JS</code> 中的异步还是同步行为</li>
</ul>
<p><img data-src="https://s.poetries.work/gitee/2020/09/101.png" alt="img"></p>
<figure class="highlight js"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(<span class="string">'script start'</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">setTimeout</span>(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>{</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'setTimeout'</span>);</span><br><span class="line">}, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">'script end'</span>);</span><br></pre></td></tr></tbody></table></figure>

<blockquote>
<p>不同的任务源会被分配到不同的 <code>Task</code> 队列中，任务源可以分为 微任务（<code>microtask</code>） 和 宏任务（<code>macrotask</code>）。在 <code>ES6</code> 规范中，<code>microtask</code> 称为 <code>jobs</code>，<code>macrotask</code> 称为 <code>task</code></p>
</blockquote>
<figure class="highlight javascript"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(<span class="string">'script start'</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">setTimeout</span>(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>{</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'setTimeout'</span>);</span><br><span class="line">}, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve</span>) =&gt;</span> {</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'Promise'</span>)</span><br><span class="line">    resolve()</span><br><span class="line">}).then(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>{</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'promise1'</span>);</span><br><span class="line">}).then(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>{</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'promise2'</span>);</span><br><span class="line">});</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">'script end'</span>);</span><br><span class="line"><span class="comment">// script start =&gt; Promise =&gt; script end =&gt; promise1 =&gt; promise2 =&gt; setTimeout</span></span><br></pre></td></tr></tbody></table></figure>

<blockquote>
<p>以上代码虽然 <code>setTimeout</code> 写在 <code>Promise</code> 之前，但是因为 <code>Promise</code> 属于微任务而 <code>setTimeout</code> 属于宏任务</p>
</blockquote>
<p><strong>微任务</strong></p>
<ul>
<li><code>process.nextTick</code></li>
<li><code>promise</code></li>
<li><code>Object.observe</code></li>
<li><code>MutationObserver</code></li>
</ul>
<p><strong>宏任务</strong></p>
<ul>
<li><code>script</code></li>
<li><code>setTimeout</code></li>
<li><code>setInterval</code></li>
<li><code>setImmediate</code></li>
<li><code>I/O</code></li>
<li><code>UI rendering</code></li>
</ul>
<blockquote>
<p>宏任务中包括了 <code>script</code> ，浏览器会先执行一个宏任务，接下来有异步代码的话就先执行微任务</p>
</blockquote>
<p><strong>所以正确的一次 Event loop 顺序是这样的</strong></p>
<ul>
<li>执行同步代码，这属于宏任务</li>
<li>执行栈为空，查询是否有微任务需要执行</li>
<li>执行所有微任务</li>
<li>必要的话渲染 UI</li>
<li>然后开始下一轮 <code>Event loop</code>，执行宏任务中的异步代码</li>
</ul>
<blockquote>
<p>通过上述的 <code>Event loop</code> 顺序可知，如果宏任务中的异步代码有大量的计算并且需要操作 <code>DOM</code> 的话，为了更快的响应界面响应，我们可以把操作 <code>DOM</code> 放入微任务中</p>
</blockquote>
<p><strong>牛客网解释：</strong></p>
<ul>
<li><strong>得分点</strong> 任务挂起、同步任务执行结束执行队列中的异步任务、执行script标签内部代码、setTimeout/setInterval、ajax请、postMessageMessageChannel、setImmediate、I/O（Node.js）Promise、MutonObserver、Object.observe、process.nextTick（Node.js）每个宏任务中都包含了一个微任务队列</li>
<li><strong>标准回答</strong> 浏览器的事件循环：执行js代码的时候，遇见同步任务，直接推入调用栈中执行，遇到异步任务，将该任务挂起，等到异步任务有返回之后推入到任务队列中，当调用栈中的所有同步任务全部执行完成，将任务队列中的任务按顺序一个一个的推入并执行，重复执行这一系列的行为。<ul>
<li>异步任务又分为宏任务和微任务。</li>
<li>宏任务：任务队列中的任务称为宏任务，每个宏任务中都包含了一个微任务队列。</li>
<li>微任务：等宏任务中的主要功能都完成后，渲染引擎不急着去执行下一个宏任务，而是执行当前宏任务中的微任务</li>
<li>宏任务包含：执行script标签内部代码、setTimeout/setInterval、ajax请、postMessageMessageChannel、setImmediate，I/O（Node.js）</li>
<li>微任务包含：Promise、MutonObserver、Object.observe、process.nextTick（Node.js）</li>
</ul>
</li>
<li><strong>加分回答</strong> 浏览器和Node 环境下，microtask 任务队列的执行时机不同<ul>
<li>Node端，microtask 在事件循环的各个阶段之间执行</li>
<li>浏览器端，microtask 在事件循环的 macrotask 执行完之后执行</li>
</ul>
</li>
</ul>
<h3 id="说说事件流"><a href="#说说事件流" class="headerlink" title="说说事件流"></a>说说事件流</h3><p><strong>事件流分为两种，捕获事件流和冒泡事件流</strong></p>
<ul>
<li>捕获事件流从根节点开始执行，一直往子节点查找执行，直到查找执行到目标节点</li>
<li>冒泡事件流从目标节点开始执行，一直往父节点冒泡查找执行，直到查到到根节点</li>
</ul>
<blockquote>
<p>事件流分为三个阶段，一个是捕获节点，一个是处于目标节点阶段，一个是冒泡阶段</p>
</blockquote>
<h3 id="说说从输入URL到看到页面发生的全过程，越详细越好"><a href="#说说从输入URL到看到页面发生的全过程，越详细越好" class="headerlink" title="说说从输入URL到看到页面发生的全过程，越详细越好"></a>说说从输入URL到看到页面发生的全过程，越详细越好</h3><ul>
<li>首先浏览器主进程接管，开了一个下载线程。</li>
<li>然后进行HTTP请求（DNS查询、IP寻址等等），中间会有三次捂手，等待响应，开始下载响应报文。</li>
<li>将下载完的内容转交给Renderer进程管理。</li>
<li>Renderer进程开始解析css rule tree和dom tree，这两个过程是并行的，所以一般我会把link标签放在页面顶部。</li>
<li>解析绘制过程中，当浏览器遇到link标签或者script、img等标签，浏览器会去下载这些内容，遇到时候缓存的使用缓存，不适用缓存的重新下载资源。</li>
<li>css rule tree和dom tree生成完了之后，开始合成render tree，这个时候浏览器会进行layout，开始计算每一个节点的位置，然后进行绘制。</li>
<li>绘制结束后，关闭TCP连接，过程有四次挥手</li>
</ul>
<h3 id="现在要你完成一个Dialog组件，说说你设计的思路？它应该有什么功能？"><a href="#现在要你完成一个Dialog组件，说说你设计的思路？它应该有什么功能？" class="headerlink" title="现在要你完成一个Dialog组件，说说你设计的思路？它应该有什么功能？"></a>现在要你完成一个Dialog组件，说说你设计的思路？它应该有什么功能？</h3><ul>
<li>该组件需要提供<code>hook</code>指定渲染位置，默认渲染在body下面。</li>
<li>然后改组件可以指定外层样式，如宽度等</li>
<li>组件外层还需要一层<code>mask</code>来遮住底层内容，点击<code>mask</code>可以执行传进来的<code>onCancel</code>函数关闭<code>Dialog</code>。</li>
<li>另外组件是可控的，需要外层传入<code>visible</code>表示是否可见。</li>
<li>然后<code>Dialog</code>可能需要自定义头head和底部<code>footer</code>，默认有头部和底部，底部有一个确认按钮和取消按钮，确认按钮会执行外部传进来的<code>onOk</code>事件，然后取消按钮会执行外部传进来的<code>onCancel</code>事件。</li>
<li>当组件的<code>visible</code>为<code>true</code>时候，设置<code>body</code>的<code>overflow</code>为<code>hidden</code>，隐藏<code>body</code>的滚动条，反之显示滚动条。</li>
<li>组件高度可能大于页面高度，组件内部需要滚动条。</li>
<li>只有组件的<code>visible</code>有变化且为<code>ture</code>时候，才重渲染组件内的所有内容</li>
</ul>
<h3 id="caller和callee的区别"><a href="#caller和callee的区别" class="headerlink" title="caller和callee的区别"></a><code>caller</code>和<code>callee</code>的区别</h3><p><strong>callee</strong></p>
<blockquote>
<p><code>caller</code>返回一个函数的引用，这个函数调用了当前的函数。</p>
</blockquote>
<p><strong>使用这个属性要注意</strong></p>
<ul>
<li>这个属性只有当函数在执行时才有用</li>
<li>如果在<code>javascript</code>程序中，函数是由顶层调用的，则返回<code>null</code></li>
</ul>
<blockquote>
<p><code>functionName.caller: functionName</code>是当前正在执行的函数。</p>
</blockquote>
<figure class="highlight js"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">a</span>(<span class="params"></span>) </span>{</span><br><span class="line">  <span class="built_in">console</span>.log(a.caller)</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p><strong>callee</strong></p>
<blockquote>
<p><code>callee</code>放回正在执行的函数本身的引用，它是<code>arguments</code>的一个属性</p>
</blockquote>
<blockquote>
<p>使用callee时要注意:</p>
</blockquote>
<ul>
<li>这个属性只有在函数执行时才有效</li>
<li>它有一个<code>length</code>属性，可以用来获得形参的个数，因此可以用来比较形参和实参个数是否一致，即比较<code>arguments.length</code>是否等于<code>arguments.callee.length</code></li>
<li>它可以用来递归匿名函数。</li>
</ul>
<figure class="highlight js"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">a</span>(<span class="params"></span>) </span>{</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="built_in">arguments</span>.callee)</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<h3 id="ajax、axios、fetch区别"><a href="#ajax、axios、fetch区别" class="headerlink" title="ajax、axios、fetch区别"></a>ajax、axios、fetch区别</h3><p><strong>jQuery ajax</strong></p>
<figure class="highlight js"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">$.ajax({</span><br><span class="line">   type: <span class="string">'POST'</span>,</span><br><span class="line">   url: url,</span><br><span class="line">   data: data,</span><br><span class="line">   dataType: dataType,</span><br><span class="line">   success: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>{},</span><br><span class="line">   error: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>{}</span><br><span class="line">});</span><br></pre></td></tr></tbody></table></figure>

<p>优缺点：</p>
<ul>
<li>本身是针对<code>MVC</code>的编程,不符合现在前端<code>MVVM</code>的浪潮</li>
<li>基于原生的<code>XHR</code>开发，<code>XHR</code>本身的架构不清晰，已经有了<code>fetch</code>的替代方案</li>
<li><code>JQuery</code>整个项目太大，单纯使用<code>ajax</code>却要引入整个<code>JQuery</code>非常的不合理（采取个性化打包的方案又不能享受CDN服务）</li>
</ul>
<p><strong>axios</strong></p>
<figure class="highlight js"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">axios({</span><br><span class="line">    method: <span class="string">'post'</span>,</span><br><span class="line">    url: <span class="string">'/user/12345'</span>,</span><br><span class="line">    data: {</span><br><span class="line">        firstName: <span class="string">'Fred'</span>,</span><br><span class="line">        lastName: <span class="string">'Flintstone'</span></span><br><span class="line">    }</span><br><span class="line">})</span><br><span class="line">.then(<span class="function"><span class="keyword">function</span> (<span class="params">response</span>) </span>{</span><br><span class="line">    <span class="built_in">console</span>.log(response);</span><br><span class="line">})</span><br><span class="line">.catch(<span class="function"><span class="keyword">function</span> (<span class="params">error</span>) </span>{</span><br><span class="line">    <span class="built_in">console</span>.log(error);</span><br><span class="line">});</span><br></pre></td></tr></tbody></table></figure>

<p>优缺点：</p>
<ul>
<li>从浏览器中创建 <code>XMLHttpRequest</code></li>
<li>从 <code>node.js</code> 发出 <code>http</code> 请求</li>
<li>支持 <code>Promise API</code></li>
<li>拦截请求和响应</li>
<li>转换请求和响应数据</li>
<li>取消请求</li>
<li>自动转换<code>JSON</code>数据</li>
<li>客户端支持防止<code>CSRF/XSRF</code></li>
</ul>
<p><strong>fetch</strong></p>
<figure class="highlight js"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span> {</span><br><span class="line">  <span class="keyword">let</span> response = <span class="keyword">await</span> fetch(url);</span><br><span class="line">  <span class="keyword">let</span> data = response.json();</span><br><span class="line">  <span class="built_in">console</span>.log(data);</span><br><span class="line">} <span class="keyword">catch</span>(e) {</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">"Oops, error"</span>, e);</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>优缺点：</p>
<ul>
<li><code>fetcht</code>只对网络请求报错，对<code>400</code>，<code>500</code>都当做成功的请求，需要封装去处理</li>
<li><code>fetch</code>默认不会带<code>cookie</code>，需要添加配置项</li>
<li><code>fetch</code>不支持<code>abort</code>，不支持超时控制，使用<code>setTimeout</code>及<code>Promise.reject</code>的实现的超时控制并不能阻止请求过程继续在后台运行，造成了量的浪费</li>
<li><code>fetch</code>没有办法原生监测请求的进度，而XHR可以</li>
</ul>
<h4 id="❤-axios-的拦截器原理及应用"><a href="#❤-axios-的拦截器原理及应用" class="headerlink" title="❤ axios 的拦截器原理及应用"></a>❤ axios 的拦截器原理及应用</h4><ul>
<li><strong>得分点</strong> 请求（request）拦截器、响应（response）拦截器、Promise控制执行顺序、每个请求带上相应的参数、返回的状态进行判断（token是否过期）</li>
<li><strong>标准回答</strong><ul>
<li>axios的拦截器的<strong>应用场景</strong>： 请求拦截器用于在接口请求之前做的处理，比如为每个请求带上相应的参数（token，时间戳等）。 返回拦截器用于在接口返回之后做的处理，比如对返回的状态进行判断（token是否过期）。 axios为开发者提供了这样一个API：拦截器。拦截器分为 请求（request）拦截器和 响应（response）拦截器。</li>
<li>拦截器<strong>原理</strong>：创建一个chn数组，数组中保存了拦截器相应方法以及<code>dispatchRequest</code>（dispatchRequest这个函数调用才会真正的开始下发请求），把请求拦截器的方法放到chn数组中<code>dispatchRequest</code>的前面，把响应拦截器的方法放到chn数组中<code>dispatchRequest</code>的后面，把请求拦截器和相应拦截器<code>forEach</code>将它们分<code>unshift</code>,<code>push</code>到chn数组中，为了保证它们的执行顺序，需要使用<code>promise</code>，以出队列的方式对chn数组中的方法挨个执行。</li>
</ul>
</li>
<li><strong>加分回答</strong><ul>
<li>Axios 是一个基于 promise 的 HTTP 库，可以用在浏览器和 node.js 中。从浏览器中创建 <code>XMLHttpRequests</code>,从 node.js 创建 http 请求,支持 Promise API,可拦截请求和响应，可转换请求数据和响应数据，可取消请求，可自动转换 JSON 数据，客户端支持防御 XSRF</li>
</ul>
</li>
</ul>
<h4 id="❤-fetch-请求方式"><a href="#❤-fetch-请求方式" class="headerlink" title="❤ fetch 请求方式"></a>❤ fetch 请求方式</h4><ul>
<li><strong>得分点</strong> Fetch函数就是原生js、没有使用<code>XMLHttpRequest</code>对象、头部信息、请求信息、响应信息等均分布到不同的对象</li>
<li><strong>标准回答</strong><ul>
<li>fetch是一种HTTP数据请求的方式，是<code>XMLHttpRequest</code>的一种替代方案。<code>Fetch</code>函数就是原生js，没有使用<code>XMLHttpRequest</code>对象。<code>fetch()</code>方法返回一个<code>Promise</code>解析<code>Response</code>来自<code>Request</code>显示状态（成功与否）的方法。</li>
</ul>
</li>
<li><strong>加分回答</strong><ul>
<li>XMLHttpRequest的问题<ul>
<li>所有的功能全部集中在一个对象上, 容易书写出混乱而且不容易维护的代码 -采用传统的事件驱动模式, 无法适配新的 Promise API Fetch API的特点</li>
<li>精细的功能分割: 头部信息, 请求信息, 响应信息等均分布到不同的对象, 更利于处理各种复杂的数据交互场景</li>
<li>使用Promise API, 更利于异步代码的书写</li>
<li>同源请求也可以自定义不带 cookie，某些服务不需要 cookie 场景下能少些流量</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="❤-JS-继承的方法和优缺点？"><a href="#❤-JS-继承的方法和优缺点？" class="headerlink" title="❤ JS 继承的方法和优缺点？"></a>❤ JS 继承的方法和优缺点？</h3><blockquote>
<p>构造函数绑定：使用 <code>call</code> 或 <code>apply</code> 方法，将父对象的构造函数绑定在子对象上</p>
</blockquote>
<figure class="highlight js"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Cat</span>(<span class="params">name,color</span>)</span>{</span><br><span class="line"> 　Animal.apply(<span class="built_in">this</span>, <span class="built_in">arguments</span>);</span><br><span class="line"> 　<span class="built_in">this</span>.name = name;</span><br><span class="line"> 　<span class="built_in">this</span>.color = color;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<ul>
<li>实例继承：将子对象的 prototype 指向父对象的一个实例</li>
</ul>
<figure class="highlight javascript"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Cat.prototype = <span class="keyword">new</span> Animal();</span><br><span class="line">Cat.prototype.constructor = Cat;</span><br></pre></td></tr></tbody></table></figure>

<blockquote>
<p>拷贝继承：如果把父对象的所有属性和方法，拷贝进子对象</p>
</blockquote>
<figure class="highlight js"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">extend</span>(<span class="params">Child, Parent</span>) </span>{</span><br><span class="line">　　　<span class="keyword">var</span> p = Parent.prototype;</span><br><span class="line">　　　<span class="keyword">var</span> c = Child.prototype;</span><br><span class="line">　　　<span class="keyword">for</span> (<span class="keyword">var</span> i <span class="keyword">in</span> p) {</span><br><span class="line">　　　   c[i] = p[i];</span><br><span class="line">　　　}</span><br><span class="line">　　　c.uber = p;</span><br><span class="line">　 }</span><br></pre></td></tr></tbody></table></figure>

<blockquote>
<p>原型继承：将子对象的 <code>prototype</code> 指向父对象的 <code>prototype</code></p>
</blockquote>
<figure class="highlight js"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">extend</span>(<span class="params">Child, Parent</span>) </span>{</span><br><span class="line">    <span class="keyword">var</span> F = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>{};</span><br><span class="line">  　F.prototype = Parent.prototype;</span><br><span class="line">  　Child.prototype = <span class="keyword">new</span> F();</span><br><span class="line">  　Child.prototype.constructor = Child;</span><br><span class="line">  　Child.uber = Parent.prototype;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<blockquote>
<figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ES6` 语法糖 `extends：class ColorPoint extends Point {}</span><br></pre></td></tr></tbody></table></figure>
</blockquote>
<figure class="highlight js"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ColorPoint</span> <span class="keyword">extends</span> <span class="title">Point</span> </span>{</span><br><span class="line">    <span class="function"><span class="title">constructor</span>(<span class="params">x, y, color</span>)</span> {</span><br><span class="line">      <span class="built_in">super</span>(x, y); <span class="comment">// 调用父类的constructor(x, y)</span></span><br><span class="line">      <span class="built_in">this</span>.color = color;</span><br><span class="line">    }</span><br><span class="line">    <span class="function"><span class="title">toString</span>(<span class="params"></span>)</span> {</span><br><span class="line">      <span class="keyword">return</span> <span class="built_in">this</span>.color + <span class="string">' '</span> + <span class="built_in">super</span>.toString(); <span class="comment">// 调用父类的toString()</span></span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>



<p><strong>牛客网解释：</strong></p>
<ul>
<li><strong>得分点</strong> 原型链继承、借用构造函数继承、组合继承、原型式继承、寄生式继承、寄生组合式继承、ES6 Class</li>
<li><strong>标准回答</strong><ul>
<li><strong>原型链继承：</strong>让一个构造函数的原型是另一个类型的实例，那么这个构造函数new出来的实例就具有该实例的属性，原型链继承的。优点：写法方便简洁，容易理解。缺点：在父类型构造函数中定义的引用类型值的实例属性，会在子类型原型上变成原型属性被所有子类型实例所共享。同时在创建子类型的实例时，不能向超类型的构造函数中传递参数。</li>
<li><strong>借用构造函数继承：</strong>在子类型构造函数的内部调用父类型构造函数；使用 apply() 或 call() 方法将父对象的构造函数绑定在子对象上。优点：解决了原型链实现继承的不能传参的问题和父类的原型共享的问题。缺点：借用构造函数的缺点是方法都在构造函数中定义，因此无法实现函数复用。在父类型的原型中定义的方法，对子类型而言也是不可见的，结果所有类型都只能使用构造函数模式。</li>
<li><strong>组合继承：</strong>将原型链和借用构造函数的组合到一块。使用原型链实现对原型属性和方法的继承，而通过借用构造函数来实现对实例属性的继承。这样，既通过在原型上定义方法实现了函数复用，又能够保证每个实例都有自己的属性。优点就是解决了原型链继承和借用构造函数继承造成的影响。缺点是无论在什么情况下，都会调用两次超类型构造函数：一次是在创建子类型原型的时候，另一次是在子类型构造函数内部</li>
<li><strong>原型式继承：</strong>在一个函数A内部创建一个临时性的构造函数，然后将传入的对象作为这个构造函数的原型，最后返回这个临时类型的一个新实例。本质上，函数A是对传入的对象执行了一次浅复制。ECMAScript 5通过增加Object.create()方法将原型式继承的概念规范化了。这个方法接收两个参数：作为新对象原型的对象，以及给新对象定义额外属性的对象（第二个可选）。在只有一个参数时，Object.create()与这里的函数A方法效果相同。优点是：不需要单独创建构造函数。缺点是：属性中包含的引用值始终会在相关对象间共享</li>
<li><strong>寄生式继承：</strong>寄生式继承背后的思路类似于寄生构造函数和工厂模式：创建一个实现继承的函数，以某种方式增强对象，然后返回这个对象。优点：写法简单，不需要单独创建构造函数。缺点：通过寄生式继承给对象添加函数会导致函数难以重用。</li>
<li><strong>寄生组合式继承：</strong>通过借用构造函数来继承属性，通过原型链的混成形式来继承方法。本质上，就是使用寄生式继承来继承超类型的原型，然后再将结果指定给子类型的原型。优点是：高效率只调用一次父构造函数，并且因此避免了在子原型上面创建不必要，多余的属性。与此同时，原型链还能保持不变；缺点是：代码复杂</li>
</ul>
</li>
<li><strong>加分回答</strong><ul>
<li>ES6 Class实现继承。</li>
<li>原理：原理ES5 的继承，实质是先创造子类的实例对象this，然后再将父类的方法添加到this上面（Parent.apply(this)）。 ES6 的继承机制完全不同，实质是先将父类实例对象的属性和方法，加到this上面（所以必须先调用super方法），然后再用子类的构造函数修改this。需要注意的是，class关键字只是原型的语法糖，JavaScript继承仍然是基于原型实现的。 优点：语法简单易懂,操作更方便。缺点：并不是所有的浏览器都支持class关键字</li>
</ul>
</li>
</ul>
<figure class="highlight js"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span> </span>{</span><br><span class="line">    <span class="comment">//调用类的构造方法</span></span><br><span class="line">    <span class="function"><span class="title">constructor</span>(<span class="params">name, age</span>)</span> {</span><br><span class="line">        <span class="built_in">this</span>.name = name</span><br><span class="line">        <span class="built_in">this</span>.age = age</span><br><span class="line">    } <span class="comment">//定义一般的方法</span></span><br><span class="line">    <span class="function"><span class="title">showName</span>(<span class="params"></span>)</span> {</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">"调用父类的方法"</span>)</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="built_in">this</span>.name, <span class="built_in">this</span>.age);</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"><span class="keyword">let</span> p1 = <span class="keyword">new</span> Person(<span class="string">'kobe'</span>, <span class="number">39</span>)</span><br><span class="line"><span class="built_in">console</span>.log(p1)</span><br><span class="line"><span class="comment">//定义一个子类</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Student</span> <span class="keyword">extends</span> <span class="title">Person</span> </span>{</span><br><span class="line">    <span class="function"><span class="title">constructor</span>(<span class="params">name, age, salary</span>)</span> {</span><br><span class="line">        <span class="built_in">super</span>(name, age)</span><br><span class="line">        <span class="comment">//通过super调用父类的构造方法</span></span><br><span class="line">        <span class="built_in">this</span>.salary = salary</span><br><span class="line">    }</span><br><span class="line">    <span class="function"><span class="title">showName</span>(<span class="params"></span>)</span> {</span><br><span class="line">        <span class="comment">//在子类自身定义方法</span></span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">"调用子类的方法"</span>)</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="built_in">this</span>.name, <span class="built_in">this</span>.age, <span class="built_in">this</span>.salary);</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"><span class="keyword">let</span> s1 = <span class="keyword">new</span> Student(<span class="string">'wade'</span>, <span class="number">38</span>, <span class="number">1000000000</span>)</span><br><span class="line"><span class="built_in">console</span>.log(s1)</span><br><span class="line">s1.showName()</span><br></pre></td></tr></tbody></table></figure>





<h3 id="数组相关："><a href="#数组相关：" class="headerlink" title="数组相关："></a>数组相关：</h3><h4 id="❤-JS-数组常用方法"><a href="#❤-JS-数组常用方法" class="headerlink" title="❤ JS 数组常用方法"></a>❤ JS 数组常用方法</h4><ol>
<li><code>join()</code> 通过指定连接符生成字符串</li>
<li><code>push()</code> 和 <code>pop()</code> 末尾推入和弹出，改变原数组， 返回推入/弹出项</li>
<li><code>shift()</code> 和 <code>unshift()</code> 头部推入和弹出，改变原数组，返回操作项</li>
<li><code>sort()</code> 排序，改变原数组</li>
<li><code>reverse()</code> 反转，改变原数组</li>
<li><code>concat() </code> 连接数组，不影响原数组， 浅拷贝</li>
<li><code>slice(start, end)</code> 返回截断后的新数组，不改变原数组</li>
<li><code>splice(start, number, value...)</code> 返回删除元素组成的数组，<code>value</code>为插入项，改变原数组</li>
<li><code>indexOf(value, fromIndex)</code>  和  <code>lastIndexOf(value, fromIndex)</code> 查找数组项，返回对应的下标</li>
<li><code>forEach()</code> 无法<code>break</code>，可以用<code>try/catch</code>中<code>throw new Error</code>来停止</li>
<li><code>filter()</code> 过滤</li>
<li><code>every()</code> 有一项返回<code>false</code>，则整体为<code>false</code></li>
<li><code>some()</code> 有一项返回<code>true</code>，则整体为<code>true</code></li>
<li><code>toString()</code></li>
<li><code>map()</code> 遍历数组，返回回调返回值组成的新数组</li>
<li><code>reduce() / reduceRight(fn(prev, cur)</code>， <code>defaultPrev)</code>: 两两执行，<code>prev</code> 为上次化简函数的<code>return</code>值，<code>cur</code>为当前值(从第二项开始)</li>
</ol>
<ol>
<li><p><code>join()</code></p>
<p>把数组转换成字符串，然后给他规定个连接字符，默认的是逗号( ，)</p>
<p>书写格式：join(“ “)，括号里面写字符串 (“要加引号”),</p>
<figure class="highlight js"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> arr = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>];</span><br><span class="line"><span class="built_in">console</span>.log(arr.join()); 　　　　<span class="comment">// 1,2,3</span></span><br><span class="line"><span class="built_in">console</span>.log(arr.join(<span class="string">"-"</span>)); 　　<span class="comment">// 1-2-3</span></span><br><span class="line"><span class="built_in">console</span>.log(arr); 　　　　　　　　<span class="comment">// [1, 2, 3]（原数组不变）</span></span><br></pre></td></tr></tbody></table></figure></li>
<li><p><code>push()</code> 和 <code>pop()</code></p>
<p><code>push()</code>: 把里面的内容添加到数组末尾，并返回修改后的长度。</p>
<p><code>pop()</code>：移除数组最后一项，返回移除的那个值，减少数组的length。</p>
<p>​        书写格式：<code>arr.push(" ")</code>，括号里面写内容 (“字符串要加引号”),</p>
<p>​        书写格式：<code>arr.pop( )</code></p>
<figure class="highlight js"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> arr = [<span class="string">"Lily"</span>,<span class="string">"lucy"</span>,<span class="string">"Tom"</span>];</span><br><span class="line"><span class="keyword">var</span> count = arr.push(<span class="string">"Jack"</span>,<span class="string">"Sean"</span>);</span><br><span class="line"><span class="built_in">console</span>.log(count); 　　　　　　　　　　<span class="comment">// 5</span></span><br><span class="line"><span class="built_in">console</span>.log(arr); 　　　　　　　　　　　<span class="comment">// ["Lily", "lucy", "Tom", "Jack", "Sean"]</span></span><br><span class="line"><span class="keyword">var</span> item = arr.pop();</span><br><span class="line"><span class="built_in">console</span>.log(item); 　　　　　　　　　　 <span class="comment">// Sean</span></span><br><span class="line"><span class="built_in">console</span>.log(arr); 　　　　　　　　　　  <span class="comment">// ["Lily", "lucy", "Tom", "Jack"]</span></span><br></pre></td></tr></tbody></table></figure></li>
<li><p><code>shift()</code> 和 <code>unshift()</code></p>
<p><code>shift()</code>：删除原数组第一项，并返回删除元素的值；如果数组为空则返回<code>undefined</code> 。 </p>
<p><code>unshift()</code>：将参数添加到原数组开头，并返回数组的长度 。</p>
<p>　　书写格式：<code>arr.shift(" ")</code>，括号里面写内容 (“字符串要加引号”)</p>
<figure class="highlight js"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> arr = [<span class="string">"Lily"</span>,<span class="string">"lucy"</span>,<span class="string">"Tom"</span>];</span><br><span class="line"><span class="keyword">var</span> count = arr.unshift(<span class="string">"Jack"</span>,<span class="string">"Sean"</span>);</span><br><span class="line"><span class="built_in">console</span>.log(count); 　　　　　　　　　　　　　　<span class="comment">// 5</span></span><br><span class="line"><span class="built_in">console</span>.log(arr); 　　　　　　　　　　　　　　　<span class="comment">//["Jack", "Sean", "Lily", "lucy", "Tom"]</span></span><br><span class="line"><span class="keyword">var</span> item = arr.shift();</span><br><span class="line"><span class="built_in">console</span>.log(item); 　　　　　　　　　　　　　　<span class="comment">// Jack</span></span><br><span class="line"><span class="built_in">console</span>.log(arr); 　　　　　　　　　　　　　　 <span class="comment">// ["Sean", "Lily", "lucy", "Tom"]</span></span><br></pre></td></tr></tbody></table></figure></li>
<li><p><code>sort()</code></p>
<p><code>sort()</code>：将数组里的项从小到大排序</p>
<figure class="highlight js"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> arr1 = [<span class="string">"a"</span>, <span class="string">"d"</span>, <span class="string">"c"</span>, <span class="string">"b"</span>];</span><br><span class="line"><span class="built_in">console</span>.log(arr1.sort()); 　　　　　　　　　　<span class="comment">// ["a", "b", "c", "d"</span></span><br></pre></td></tr></tbody></table></figure></li>
<li><p><code>reverse()</code></p>
<p><code>reverse()</code>：反转数组项的顺序。</p>
<figure class="highlight js"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> arr = [<span class="number">13</span>, <span class="number">24</span>, <span class="number">51</span>, <span class="number">3</span>];</span><br><span class="line"><span class="built_in">console</span>.log(arr.reverse()); 　　　　　　　　<span class="comment">//[3, 51, 24, 13]</span></span><br><span class="line"><span class="built_in">console</span>.log(arr); 　　　　　　　　　　　　　　<span class="comment">//[3, 51, 24, 13](原数组改变)</span></span><br></pre></td></tr></tbody></table></figure></li>
<li><p><code>concat() </code></p>
<p><code>concat() </code>：将参数添加到原数组中。这个方法会先创建当前数组一个副本，然后将接收到的参数添加到这个副本的末尾，最后返回新构建的数组。在没有给 concat()方法传递参数的情况下，它只是复制当前数组并返回副本。</p>
<p>　　书写格式：arr.concat()，括号里面写内容  (“字符串要加引号”)</p>
<figure class="highlight js"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> arr = [<span class="number">1</span>,<span class="number">3</span>,<span class="number">5</span>,<span class="number">7</span>];</span><br><span class="line"><span class="keyword">var</span> arrCopy = arr.concat(<span class="number">9</span>,[<span class="number">11</span>,<span class="number">13</span>]);</span><br><span class="line"><span class="built_in">console</span>.log(arrCopy); 　　　　　　　　　　　　<span class="comment">//[1, 3, 5, 7, 9, 11, 13]</span></span><br><span class="line"><span class="built_in">console</span>.log(arr); 　　　　　　　　　　　　　　<span class="comment">// [1, 3, 5, 7](原数组未被修改)</span></span><br></pre></td></tr></tbody></table></figure></li>
<li><p><code>slice()</code></p>
<p><code>slice()</code>：返回从原数组中指定开始下标到结束下标之间的项组成的新数组。slice()方法可以接受一或两个参数，即要返回项的起始和结束位置。在只有一个参数的情况下， slice()方法返回从该参数指定位置开始到当前数组末尾的所有项。如果有两个参数，该方法返回起始和结束位置之间的项——但不包括结束位置的项。</p>
<p>　　书写格式：arr.slice( 1 , 3  )</p>
<figure class="highlight js"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> arr = [<span class="number">1</span>,<span class="number">3</span>,<span class="number">5</span>,<span class="number">7</span>,<span class="number">9</span>,<span class="number">11</span>];</span><br><span class="line"><span class="keyword">var</span> arrCopy = arr.slice(<span class="number">1</span>);</span><br><span class="line"><span class="keyword">var</span> arrCopy2 = arr.slice(<span class="number">1</span>,<span class="number">4</span>);</span><br><span class="line"><span class="keyword">var</span> arrCopy3 = arr.slice(<span class="number">1</span>,-<span class="number">2</span>);</span><br><span class="line"><span class="keyword">var</span> arrCopy4 = arr.slice(-<span class="number">4</span>,-<span class="number">1</span>);</span><br><span class="line"><span class="built_in">console</span>.log(arr); 　　　　　　　　　　　　　　<span class="comment">//[1, 3, 5, 7, 9, 11](原数组没变)</span></span><br><span class="line"><span class="built_in">console</span>.log(arrCopy); 　　　　　　　　　　　 <span class="comment">//[3, 5, 7, 9, 11]</span></span><br><span class="line"><span class="built_in">console</span>.log(arrCopy2); 　　　　　　　　　　　<span class="comment">//[3, 5, 7]</span></span><br><span class="line"><span class="built_in">console</span>.log(arrCopy3); 　　　　　　　　　　　<span class="comment">//[3, 5, 7]</span></span><br><span class="line"><span class="built_in">console</span>.log(arrCopy4); 　　　　　　　　　　　<span class="comment">//[5, 7, 9]</span></span><br></pre></td></tr></tbody></table></figure></li>
<li><p><code>splice()</code></p>
<p>splice()：删除、插入和替换。</p>
<p>删除：指定 2 个参数：要删除的第一项的位置和要删除的项数。</p>
<p>　　书写格式：arr.splice( 1 , 3  )</p>
<p>插入：可以向指定位置插入任意数量的项，只需提供 3 个参数：起始位置、 0（要删除的项数）和要插入的项。</p>
<p>　　书写格式：arr.splice(  2,0,4,6  )<br>替换：可以向指定位置插入任意数量的项，且同时删除任意数量的项，只需指定 3 个参数：起始位置、要删除的项数和要插入的任意数量的项。插入的项数不必与删除的项数相等。</p>
<p>　　书写格式：arr.splice(  2,0,4,6  )</p>
<figure class="highlight js"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> arr = [<span class="number">1</span>,<span class="number">3</span>,<span class="number">5</span>,<span class="number">7</span>,<span class="number">9</span>,<span class="number">11</span>];</span><br><span class="line"><span class="keyword">var</span> arrRemoved = arr.splice(<span class="number">0</span>,<span class="number">2</span>);</span><br><span class="line"><span class="built_in">console</span>.log(arr); 　　　　　　　　　　　　　　　<span class="comment">//[5, 7, 9, 11]</span></span><br><span class="line"><span class="built_in">console</span>.log(arrRemoved); 　　　　　　　　　　　<span class="comment">//[1, 3]</span></span><br><span class="line"><span class="keyword">var</span> arrRemoved2 = arr.splice(<span class="number">2</span>,<span class="number">0</span>,<span class="number">4</span>,<span class="number">6</span>);</span><br><span class="line"><span class="built_in">console</span>.log(arr); 　　　　　　　　　　　　　　　<span class="comment">// [5, 7, 4, 6, 9, 11]</span></span><br><span class="line"><span class="built_in">console</span>.log(arrRemoved2); 　　　　　　　　　　<span class="comment">// []</span></span><br><span class="line"><span class="keyword">var</span> arrRemoved3 = arr.splice(<span class="number">1</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">4</span>);</span><br><span class="line"><span class="built_in">console</span>.log(arr); 　　　　　　　　　　　　　　　<span class="comment">// [5, 2, 4, 4, 6, 9, 11]</span></span><br><span class="line"><span class="built_in">console</span>.log(arrRemoved3); 　　　　　　　　　　<span class="comment">//[7]</span></span><br></pre></td></tr></tbody></table></figure></li>
<li><p><code>indexOf()</code>  VS  <code>lastIndexOf()</code></p>
<p><code>indexOf()</code>：接收两个参数：要查找的项和（可选的）表示查找起点位置的索引。其中， 从数组的开头（位置 0）开始向后查找。</p>
<p>　　　　书写格式：arr.indexof( 5 )</p>
<p><code>lastIndexOf</code>：接收两个参数：要查找的项和（可选的）表示查找起点位置的索引。其中， 从数组的末尾开始向前查找。 </p>
<p>　　　　书写格式：arr.lastIndexOf(  5,4  )</p>
<figure class="highlight js"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> arr = [<span class="number">1</span>,<span class="number">3</span>,<span class="number">5</span>,<span class="number">7</span>,<span class="number">7</span>,<span class="number">5</span>,<span class="number">3</span>,<span class="number">1</span>];</span><br><span class="line"><span class="built_in">console</span>.log(arr.indexOf(<span class="number">5</span>)); 　　　　　　<span class="comment">// 2</span></span><br><span class="line"><span class="built_in">console</span>.log(arr.lastIndexOf(<span class="number">5</span>)); 　　　 <span class="comment">// 5</span></span><br><span class="line"><span class="built_in">console</span>.log(arr.indexOf(<span class="number">5</span>,<span class="number">2</span>)); 　　　　 <span class="comment">// 2</span></span><br><span class="line"><span class="built_in">console</span>.log(arr.lastIndexOf(<span class="number">5</span>,<span class="number">4</span>)); 　　<span class="comment">// 2</span></span><br><span class="line"><span class="built_in">console</span>.log(arr.indexOf(<span class="string">"5"</span>)); 　　　　 <span class="comment">// -1</span></span><br></pre></td></tr></tbody></table></figure></li>
<li><p><code>forEach()</code></p>
<p><code>forEach()</code>：对数组进行遍历循环，对数组中的每一项运行给定函数。这个方法没有返回值。参数都是function类型，默认有传参，参数分别为：遍历的数组内容；第对应的数组索引，数组本身。</p>
<p>　　　　书写格式：arr.forEach()</p>
<figure class="highlight js"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> arr = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>];</span><br><span class="line">arr.forEach(<span class="function"><span class="keyword">function</span>(<span class="params">x, index, a</span>)</span>{</span><br><span class="line">	<span class="built_in">console</span>.log(x + <span class="string">'|'</span> + index + <span class="string">'|'</span> + (a === arr));</span><br><span class="line">});</span><br><span class="line"><span class="comment">// 输出为：</span></span><br><span class="line"><span class="comment">// 1|0|true</span></span><br><span class="line"><span class="comment">// 2|1|true</span></span><br><span class="line"><span class="comment">// 3|2|true</span></span><br><span class="line"><span class="comment">// 4|3|true</span></span><br><span class="line"><span class="comment">// 5|4|true</span></span><br></pre></td></tr></tbody></table></figure></li>
<li><p><code>filter()</code></p>
<p>filter()：“过滤”功能，数组中的每一项运行给定函数，返回满足过滤条件组成的数组。</p>
<p>　　　　书写格式：arr.filter()</p>
<figure class="highlight js"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> arr = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>, <span class="number">10</span>];</span><br><span class="line"><span class="keyword">var</span> arr2 = arr.filter(<span class="function"><span class="keyword">function</span>(<span class="params">x, index</span>) </span>{</span><br><span class="line">	<span class="keyword">return</span> index % <span class="number">3</span> === <span class="number">0</span> || x &gt;= <span class="number">8</span>;</span><br><span class="line">}); </span><br><span class="line"><span class="built_in">console</span>.log(arr2); 　　　　　　　　<span class="comment">//[1, 4, 7, 8, 9, 10]</span></span><br></pre></td></tr></tbody></table></figure></li>
<li><p><code>every()</code></p>
<p>every()：判断数组中每一项都是否满足条件，只有所有项都满足条件，才会返回true。</p>
<p>　　　　书写格式：arr.every()</p>
<figure class="highlight js"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> arr = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>];</span><br><span class="line"><span class="keyword">var</span> arr2 = arr.every(<span class="function"><span class="keyword">function</span>(<span class="params">x</span>) </span>{</span><br><span class="line">	<span class="keyword">return</span> x &lt; <span class="number">10</span>;</span><br><span class="line">}); </span><br><span class="line"><span class="built_in">console</span>.log(arr2); 　　　　　　　　<span class="comment">//true</span></span><br><span class="line"><span class="keyword">var</span> arr3 = arr.every(<span class="function"><span class="keyword">function</span>(<span class="params">x</span>) </span>{</span><br><span class="line">	<span class="keyword">return</span> x &lt; <span class="number">3</span>;</span><br><span class="line">}); </span><br><span class="line"><span class="built_in">console</span>.log(arr3); 　　　　　　　　<span class="comment">// false</span></span><br></pre></td></tr></tbody></table></figure></li>
<li><p><code>some()</code></p>
<p>some()：判断数组中是否存在满足条件的项，只要有一项满足条件，就会返回true。</p>
<p>　　　　书写格式：arr.some()</p>
<figure class="highlight js"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> arr = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>];</span><br><span class="line"><span class="keyword">var</span> arr2 = arr.some(<span class="function"><span class="keyword">function</span>(<span class="params">x</span>) </span>{</span><br><span class="line">	<span class="keyword">return</span> x &lt; <span class="number">3</span>;</span><br><span class="line">}); </span><br><span class="line"><span class="built_in">console</span>.log(arr2); 　　　　　　　　<span class="comment">//true</span></span><br><span class="line"><span class="keyword">var</span> arr3 = arr.some(<span class="function"><span class="keyword">function</span>(<span class="params">x</span>) </span>{</span><br><span class="line">	<span class="keyword">return</span> x &lt; <span class="number">1</span>;</span><br><span class="line">}); </span><br><span class="line"><span class="built_in">console</span>.log(arr3); 　　　　　　　　<span class="comment">// false</span></span><br></pre></td></tr></tbody></table></figure></li>
<li><p><code>toString()</code></p>
<p>toString()：将数组转换成字符串，并用“，”连接，类似于array.join(“,”);</p>
<p>​                书写格式：arr.toString()</p>
<figure class="highlight js"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> arr = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>];</span><br><span class="line">arr.toString()  <span class="comment">// "1,2,3,4,5"</span></span><br></pre></td></tr></tbody></table></figure></li>
<li><p><code>map()</code></p>
<p>map()：将数组映射为想要的数组并返回新数组；map回调方法有两个参数，第一个参数：数组的每一项；</p>
<p>第二个参数为索引；</p>
<p>​                    书写格式：<code>arr.map((item, index) =&gt; ......)</code> 或者 <code>arr.map(function (item, index){......})</code></p>
<figure class="highlight js"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> arr = [<span class="string">'a'</span>, <span class="string">'b'</span>, <span class="string">'c'</span>, <span class="string">'d'</span>, <span class="string">'e'</span>];</span><br><span class="line"><span class="keyword">var</span> arr1 = arr.map(<span class="function"><span class="keyword">function</span> (<span class="params">item, index</span>) </span>{</span><br><span class="line">    <span class="keyword">return</span> item + index</span><br><span class="line">});</span><br><span class="line">arr1;   <span class="comment">//['a0', 'b1', 'c2', 'd3', 'c4'];</span></span><br><span class="line"><span class="comment">//  以上方法可以改写为： var arr1 = arr.map((item, index) =&gt; item + index);</span></span><br></pre></td></tr></tbody></table></figure></li>
<li><p><code>reduce()</code></p>
</li>
</ol>
<p><strong>数组乱序：</strong></p>
<figure class="highlight js"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> arr = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>, <span class="number">10</span>];</span><br><span class="line">arr.sort(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>{</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">Math</span>.random() - <span class="number">0.5</span>;</span><br><span class="line">});</span><br></pre></td></tr></tbody></table></figure>



<p><strong>数组拆解: flat: [1,[2,3]] –&gt; [1, 2, 3]</strong></p>
<figure class="highlight js"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Array</span>.prototype.flat = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>{</span><br><span class="line">    <span class="built_in">this</span>.toString().split(<span class="string">','</span>).map(<span class="function"><span class="params">item</span> =&gt;</span> +item )</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>



<p><strong>Array(3) 和 Array(3, 4)的区别</strong></p>
<figure class="highlight js"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Array</span>(<span class="number">3</span>)) <span class="comment">// [empty x 3]</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Array</span>(<span class="number">3</span>, <span class="number">4</span>)) <span class="comment">// [3, 4]</span></span><br></pre></td></tr></tbody></table></figure>



<p><strong>请创建一个长度为100，值都为1的数组</strong></p>
<figure class="highlight js"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">new</span> <span class="built_in">Array</span>(<span class="number">100</span>).fill(<span class="number">1</span>)</span><br></pre></td></tr></tbody></table></figure>



<p><strong>请创建一个长度为100，值为对应下标的数组</strong></p>
<figure class="highlight js"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// cool的写法：</span></span><br><span class="line">[...Array(<span class="number">100</span>).keys()]</span><br><span class="line"></span><br><span class="line"><span class="comment">// 其他方法：</span></span><br><span class="line"><span class="built_in">Array</span>(<span class="number">100</span>).join(<span class="string">","</span>).split(<span class="string">","</span>).map(<span class="function">(<span class="params">v, i</span>) =&gt;</span> i)</span><br><span class="line"><span class="built_in">Array</span>(<span class="number">100</span>).fill().map(<span class="function">(<span class="params">v, i</span>) =&gt;</span> i)</span><br></pre></td></tr></tbody></table></figure>



<h4 id="列举-JS-数组和对象有哪些原生方法？"><a href="#列举-JS-数组和对象有哪些原生方法？" class="headerlink" title="列举 JS 数组和对象有哪些原生方法？"></a>列举 JS 数组和对象有哪些原生方法？</h4><p><strong>数组：</strong></p>
<ul>
<li><code>arr.concat(arr1, arr2, arrn);</code></li>
<li><code>arr.join(",");</code></li>
<li><code>arr.sort(func);</code></li>
<li><code>arr.pop();</code></li>
<li><code>arr.push(e1, e2, en);</code></li>
<li><code>arr.shift();</code></li>
<li><code>arr.unshift(e1, e2, en);</code></li>
<li><code>arr.reverse();</code></li>
<li><code>arr.slice(start, end);</code></li>
<li><code>arr.splice(index, count, e1, e2, en);</code></li>
<li><code>arr.indexOf(el);</code></li>
<li><code>arr.includes(el);</code> // ES6</li>
</ul>
<p><strong>对象：</strong></p>
<ul>
<li><code>object.hasOwnProperty(prop);</code></li>
<li><code>object.propertyIsEnumerable(prop);</code></li>
<li><code>object.valueOf();</code></li>
<li><code>object.toString();</code></li>
<li><code>object.toLocaleString();</code></li>
<li><code>Class.prototype.isPropertyOf(object);</code></li>
</ul>
<h4 id="❤-判断数组的方法"><a href="#❤-判断数组的方法" class="headerlink" title="❤ 判断数组的方法"></a>❤ 判断数组的方法</h4><ul>
<li><code>instanceof</code>方法<ul>
<li><code>instanceof</code> 运算符是用来测试一个对象是否在其原型链原型构造函数的属性</li>
</ul>
</li>
</ul>
<figure class="highlight javascript"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> arr = [];</span><br><span class="line">arr <span class="keyword">instanceof</span> <span class="built_in">Array</span>; <span class="comment">// true</span></span><br></pre></td></tr></tbody></table></figure>

<ul>
<li><code>constructor</code>方法<ul>
<li><code>constructor</code>属性返回对创建此对象的数组函数的引用，就是返回对象相对应的构造函数</li>
</ul>
</li>
</ul>
<figure class="highlight javascript"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> arr = [];</span><br><span class="line">arr.constructor == <span class="built_in">Array</span>; <span class="comment">//true</span></span><br></pre></td></tr></tbody></table></figure>

<ul>
<li>最简单的方法</li>
</ul>
<figure class="highlight javascript"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Object</span>.prototype.toString.call(value) == <span class="string">'[object Array]'</span></span><br><span class="line"><span class="comment">// 利用这个方法，可以写一个返回数据类型的方法</span></span><br><span class="line"><span class="keyword">var</span> isType = <span class="function"><span class="keyword">function</span> (<span class="params">obj</span>) </span>{</span><br><span class="line">     <span class="keyword">return</span> <span class="built_in">Object</span>.prototype.toString.call(obj).slice(<span class="number">8</span>,-<span class="number">1</span>);</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<ul>
<li><code>ES6</code>新增方法<code>isArray()</code></li>
</ul>
<figure class="highlight javascript"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a = <span class="keyword">new</span> <span class="built_in">Array</span>(<span class="number">123</span>);</span><br><span class="line"><span class="keyword">var</span> b = <span class="keyword">new</span> <span class="built_in">Date</span>();</span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Array</span>.isArray(a)); <span class="comment">//true</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Array</span>.isArray(b)); <span class="comment">//false</span></span><br></pre></td></tr></tbody></table></figure>

<ul>
<li>原型链方法</li>
</ul>
<figure class="highlight js"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> arr = [];</span><br><span class="line">arr.__proto__ === <span class="built_in">Array</span>.prototype;</span><br></pre></td></tr></tbody></table></figure>





<h4 id="slice-与-splice-的区别"><a href="#slice-与-splice-的区别" class="headerlink" title="slice() 与 splice() 的区别"></a>slice() 与 splice() 的区别</h4><p><strong>slice</strong></p>
<blockquote>
<p>“读取”数组指定的元素，不会对原数组进行修改</p>
</blockquote>
<ul>
<li>语法：<code>arr.slice(start, end)</code></li>
<li><code>start</code> 指定选取开始位置（含）</li>
<li><code>end</code> 指定选取结束位置（不含）</li>
</ul>
<p><strong>splice</strong></p>
<blockquote>
<p>“操作”数组指定的元素，会修改原数组，返回被删除的元素  可以 删除 新增  替换</p>
</blockquote>
<ul>
<li>语法：<code>arr.splice(index, count, [insert Elements])</code></li>
<li><code>index</code> 是操作的起始位置</li>
<li><code>count = 0</code> 插入元素，<code>count &gt; 0</code> 删除元素</li>
<li><code>[insert Elements]</code> 向数组新插入的元素</li>
</ul>
<h4 id="删除指定-index-的数组元素"><a href="#删除指定-index-的数组元素" class="headerlink" title="删除指定 index 的数组元素"></a>删除指定 index 的数组元素</h4><ul>
<li><p>splice 删除</p>
<figure class="highlight js"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> delete_index = <span class="number">2</span></span><br><span class="line"><span class="keyword">var</span> arr = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>]</span><br><span class="line"><span class="comment">// arr =&gt; [1,2,3,4,5]</span></span><br><span class="line"><span class="keyword">var</span> new_arr = arr.splice(delete_index, <span class="number">1</span>)</span><br><span class="line"><span class="comment">// new_arr =&gt; [3]</span></span><br><span class="line"><span class="comment">// arr =&gt; [1,2,4,5]</span></span><br><span class="line">arr.splice(arr.indexOf(<span class="number">2</span>), <span class="number">1</span>) <span class="comment">// 这种好用</span></span><br></pre></td></tr></tbody></table></figure></li>
<li><p>for 删除</p>
<figure class="highlight js"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> delete_index = <span class="number">2</span>,</span><br><span class="line">    arr = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>],</span><br><span class="line">    new_arr = []</span><br><span class="line"> </span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>, len = arr.length; i &lt; len; i++) {</span><br><span class="line">    <span class="keyword">if</span> (i != delete_index) {</span><br><span class="line">        new_arr.push(arr[i])</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"> </span><br><span class="line"><span class="comment">// arr =&gt; [1,2,3,4,5]</span></span><br><span class="line"><span class="comment">// new_arr =&gt; [1,2,4,5]</span></span><br></pre></td></tr></tbody></table></figure></li>
</ul>
<blockquote>
<p>注意：</p>
<ol>
<li><p>不可以使用 delete 方式删除数组中某个元素，此操作会造成稀疏数组，被删除的元素的为位置依然存在为empty，且数组的长度不变</p>
</li>
<li><p>不可以使用 forEach 方法比对数组下标值，因为 forEach 在循环的时候是无序的</p>
</li>
</ol>
</blockquote>
<h4 id="判断数组中是否包含某个值"><a href="#判断数组中是否包含某个值" class="headerlink" title="判断数组中是否包含某个值"></a>判断数组中是否包含某个值</h4><p><strong>方法一：<code>array.indexOf()</code></strong></p>
<blockquote>
<p>此方法判断数组中是否存在某个值，如果存在，则返回数组元素的下标，否则返回<code>-1</code>。</p>
</blockquote>
<figure class="highlight js"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> arr=[<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>];</span><br><span class="line"><span class="keyword">var</span> index=arr.indexOf(<span class="number">3</span>);</span><br><span class="line"><span class="built_in">console</span>.log(index);</span><br></pre></td></tr></tbody></table></figure>

<p><strong>方法二：<code>array.includes(searcElement[,fromIndex])</code></strong></p>
<blockquote>
<p>此方法判断数组中是否存在某个值，如果存在返回<code>true</code>，否则返回<code>false</code></p>
</blockquote>
<figure class="highlight js"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> arr=[<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>];</span><br><span class="line"><span class="keyword">if</span>(arr.includes(<span class="number">3</span>))</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">"存在"</span>);</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">"不存在"</span>);</span><br></pre></td></tr></tbody></table></figure>

<p><strong>方法三：<code>array.find(callback[,thisArg])</code></strong></p>
<blockquote>
<p>返回数组中满足条件的第一个元素的值，如果没有，返回<code>undefined</code></p>
</blockquote>
<figure class="highlight js"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> arr=[<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>];</span><br><span class="line"><span class="keyword">var</span> result = arr.find(<span class="function"><span class="params">item</span> =&gt;</span>{</span><br><span class="line">    <span class="keyword">return</span> item &gt; <span class="number">3</span></span><br><span class="line">});</span><br><span class="line"><span class="built_in">console</span>.log(result);</span><br></pre></td></tr></tbody></table></figure>

<p><strong>方法四：<code>array.findeIndex(callback[,thisArg])</code></strong></p>
<blockquote>
<p>返回数组中满足条件的第一个元素的下标，如果没有找到，返回<code>-1</code></p>
</blockquote>
<figure class="highlight js"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> arr=[<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>];</span><br><span class="line"><span class="keyword">var</span> result = arr.findIndex(<span class="function"><span class="params">item</span> =&gt;</span>{</span><br><span class="line">    <span class="keyword">return</span> item &gt; <span class="number">3</span></span><br><span class="line">});</span><br><span class="line"><span class="built_in">console</span>.log(result);</span><br></pre></td></tr></tbody></table></figure>





<h3 id="MVVM"><a href="#MVVM" class="headerlink" title="MVVM"></a>MVVM</h3><p><strong>MVVM 由以下三个内容组成</strong></p>
<ul>
<li><code>View</code>：界面</li>
<li><code>Model</code>：数据模型</li>
<li><code>ViewModel</code>：作为桥梁负责沟通 <code>View</code> 和 <code>Model</code></li>
</ul>
<blockquote>
<ul>
<li>在 JQuery 时期，如果需要刷新 UI 时，需要先取到对应的 DOM 再更新 UI，这样数据和业务的逻辑就和页面有强耦合</li>
<li>在 MVVM 中，UI 是通过数据驱动的，数据一旦改变就会相应的刷新对应的 UI，UI 如果改变，也会改变对应的数据。这种方式就可以在业务处理中只关心数据的流转，而无需直接和页面打交道。ViewModel 只关心数据和业务的处理，不关心 View 如何处理数据，在这种情况下，View 和 Model 都可以独立出来，任何一方改变了也不一定需要改变另一方，并且可以将一些可复用的逻辑放在一个 ViewModel 中，让多个 View 复用这个 ViewModel</li>
</ul>
</blockquote>
<ul>
<li>在 MVVM 中，最核心的也就是数据双向绑定，例如 Angluar 的脏数据检测，Vue 中的数据劫持</li>
</ul>
<p><strong>脏数据检测</strong></p>
<ul>
<li>当触发了指定事件后会进入脏数据检测，这时会调用 $digest 循环遍历所有的数据观察者，判断当前值是否和先前的值有区别，如果检测到变化的话，会调用 $watch 函数，然后再次调用 $digest 循环直到发现没有变化。循环至少为二次 ，至多为十次</li>
<li>脏数据检测虽然存在低效的问题，但是不关心数据是通过什么方式改变的，都可以完成任务，但是这在 Vue 中的双向绑定是存在问题的。并且脏数据检测可以实现批量检测出更新的值，再去统一更新 UI，大大减少了操作 DOM 的次数</li>
</ul>
<p><strong>数据劫持</strong></p>
<ul>
<li><code>Vue</code> 内部使用了 <code>Obeject.defineProperty()</code> 来实现双向绑定，通过这个函数可以监听到 <code>set</code> 和 <code>get</code>的事件</li>
</ul>
<figure class="highlight javascript"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> data = { <span class="attr">name</span>: <span class="string">'yck'</span> }</span><br><span class="line">observe(data)</span><br><span class="line"><span class="keyword">let</span> name = data.name <span class="comment">// -&gt; get value</span></span><br><span class="line">data.name = <span class="string">'yyy'</span> <span class="comment">// -&gt; change value</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">observe</span>(<span class="params">obj</span>) </span>{</span><br><span class="line">  <span class="comment">// 判断类型</span></span><br><span class="line">  <span class="keyword">if</span> (!obj || <span class="keyword">typeof</span> obj !== <span class="string">'object'</span>) {</span><br><span class="line">    <span class="keyword">return</span></span><br><span class="line">  }</span><br><span class="line">  <span class="built_in">Object</span>.keys(data).forEach(<span class="function"><span class="params">key</span> =&gt;</span> {</span><br><span class="line">    defineReactive(data, key, data[key])</span><br><span class="line">  })</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">defineReactive</span>(<span class="params">obj, key, val</span>) </span>{</span><br><span class="line">  <span class="comment">// 递归子属性</span></span><br><span class="line">  observe(val)</span><br><span class="line">  <span class="built_in">Object</span>.defineProperty(obj, key, {</span><br><span class="line">    enumerable: <span class="literal">true</span>,</span><br><span class="line">    configurable: <span class="literal">true</span>,</span><br><span class="line">    get: <span class="function"><span class="keyword">function</span> <span class="title">reactiveGetter</span>(<span class="params"></span>) </span>{</span><br><span class="line">      <span class="built_in">console</span>.log(<span class="string">'get value'</span>)</span><br><span class="line">      <span class="keyword">return</span> val</span><br><span class="line">    },</span><br><span class="line">    set: <span class="function"><span class="keyword">function</span> <span class="title">reactiveSetter</span>(<span class="params">newVal</span>) </span>{</span><br><span class="line">      <span class="built_in">console</span>.log(<span class="string">'change value'</span>)</span><br><span class="line">      val = newVal</span><br><span class="line">    }</span><br><span class="line">  })</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<blockquote>
<p>以上代码简单的实现了如何监听数据的 set 和 get 的事件，但是仅仅如此是不够的，还需要在适当的时候给属性添加发布订阅</p>
</blockquote>
<figure class="highlight html"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span>&gt;</span></span><br><span class="line">    {{name}}</span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></tbody></table></figure>

<blockquote>
<p>在解析如上模板代码时，遇到 <code>{name}</code> 就会给属性 <code>name</code> 添加发布订阅</p>
</blockquote>
<figure class="highlight javascript"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 通过 Dep 解耦</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Dep</span> </span>{</span><br><span class="line">  <span class="function"><span class="title">constructor</span>(<span class="params"></span>)</span> {</span><br><span class="line">    <span class="built_in">this</span>.subs = []</span><br><span class="line">  }</span><br><span class="line">  <span class="function"><span class="title">addSub</span>(<span class="params">sub</span>)</span> {</span><br><span class="line">    <span class="comment">// sub 是 Watcher 实例</span></span><br><span class="line">    <span class="built_in">this</span>.subs.push(sub)</span><br><span class="line">  }</span><br><span class="line">  <span class="function"><span class="title">notify</span>(<span class="params"></span>)</span> {</span><br><span class="line">    <span class="built_in">this</span>.subs.forEach(<span class="function"><span class="params">sub</span> =&gt;</span> {</span><br><span class="line">      sub.update()</span><br><span class="line">    })</span><br><span class="line">  }</span><br><span class="line">}</span><br><span class="line"><span class="comment">// 全局属性，通过该属性配置 Watcher</span></span><br><span class="line">Dep.target = <span class="literal">null</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">update</span>(<span class="params">value</span>) </span>{</span><br><span class="line">  <span class="built_in">document</span>.querySelector(<span class="string">'div'</span>).innerText = value</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Watcher</span> </span>{</span><br><span class="line">  <span class="function"><span class="title">constructor</span>(<span class="params">obj, key, cb</span>)</span> {</span><br><span class="line">    <span class="comment">// 将 Dep.target 指向自己</span></span><br><span class="line">    <span class="comment">// 然后触发属性的 getter 添加监听</span></span><br><span class="line">    <span class="comment">// 最后将 Dep.target 置空</span></span><br><span class="line">    Dep.target = <span class="built_in">this</span></span><br><span class="line">    <span class="built_in">this</span>.cb = cb</span><br><span class="line">    <span class="built_in">this</span>.obj = obj</span><br><span class="line">    <span class="built_in">this</span>.key = key</span><br><span class="line">    <span class="built_in">this</span>.value = obj[key]</span><br><span class="line">    Dep.target = <span class="literal">null</span></span><br><span class="line">  }</span><br><span class="line">  <span class="function"><span class="title">update</span>(<span class="params"></span>)</span> {</span><br><span class="line">    <span class="comment">// 获得新值</span></span><br><span class="line">    <span class="built_in">this</span>.value = <span class="built_in">this</span>.obj[<span class="built_in">this</span>.key]</span><br><span class="line">    <span class="comment">// 调用 update 方法更新 Dom</span></span><br><span class="line">    <span class="built_in">this</span>.cb(<span class="built_in">this</span>.value)</span><br><span class="line">  }</span><br><span class="line">}</span><br><span class="line"><span class="keyword">var</span> data = { <span class="attr">name</span>: <span class="string">'yck'</span> }</span><br><span class="line">observe(data)</span><br><span class="line"><span class="comment">// 模拟解析到 `{{name}}` 触发的操作</span></span><br><span class="line"><span class="keyword">new</span> Watcher(data, <span class="string">'name'</span>, update)</span><br><span class="line"><span class="comment">// update Dom innerText</span></span><br><span class="line">data.name = <span class="string">'yyy'</span></span><br></pre></td></tr></tbody></table></figure>

<blockquote>
<p>接下来,对 defineReactive 函数进行改造</p>
</blockquote>
<figure class="highlight javascript"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">defineReactive</span>(<span class="params">obj, key, val</span>) </span>{</span><br><span class="line">  <span class="comment">// 递归子属性</span></span><br><span class="line">  observe(val)</span><br><span class="line">  <span class="keyword">let</span> dp = <span class="keyword">new</span> Dep()</span><br><span class="line">  <span class="built_in">Object</span>.defineProperty(obj, key, {</span><br><span class="line">    enumerable: <span class="literal">true</span>,</span><br><span class="line">    configurable: <span class="literal">true</span>,</span><br><span class="line">    get: <span class="function"><span class="keyword">function</span> <span class="title">reactiveGetter</span>(<span class="params"></span>) </span>{</span><br><span class="line">      <span class="built_in">console</span>.log(<span class="string">'get value'</span>)</span><br><span class="line">      <span class="comment">// 将 Watcher 添加到订阅</span></span><br><span class="line">      <span class="keyword">if</span> (Dep.target) {</span><br><span class="line">        dp.addSub(Dep.target)</span><br><span class="line">      }</span><br><span class="line">      <span class="keyword">return</span> val</span><br><span class="line">    },</span><br><span class="line">    set: <span class="function"><span class="keyword">function</span> <span class="title">reactiveSetter</span>(<span class="params">newVal</span>) </span>{</span><br><span class="line">      <span class="built_in">console</span>.log(<span class="string">'change value'</span>)</span><br><span class="line">      val = newVal</span><br><span class="line">      <span class="comment">// 执行 watcher 的 update 方法</span></span><br><span class="line">      dp.notify()</span><br><span class="line">    }</span><br><span class="line">  })</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<blockquote>
<p>以上实现了一个简易的双向绑定，核心思路就是手动触发一次属性的 getter 来实现发布订阅的添加</p>
</blockquote>
<p><strong>Proxy 与 Obeject.defineProperty 对比</strong></p>
<ul>
<li><code>Obeject.defineProperty</code>虽然已经能够实现双向绑定了，但是他还是有缺陷的。<ul>
<li>只能对属性进行数据劫持，所以需要深度遍历整个对象</li>
<li>对于数组不能监听到数据的变化</li>
</ul>
</li>
</ul>
<blockquote>
<p>虽然 <code>Vue</code> 中确实能检测到数组数据的变化，但是其实是使用了 <code>hack</code> 的办法，并且也是有缺陷的</p>
</blockquote>
<h3 id="继承"><a href="#继承" class="headerlink" title="继承"></a>继承</h3><ul>
<li><strong>原型链继承</strong>，将父类的实例作为子类的原型，他的特点是实例是子类的实例也是父类的实例，父类新增的原型方法/属性，子类都能够访问，并且原型链继承简单易于实现，缺点是来自原型对象的所有属性被所有实例共享，无法实现多继承，无法向父类构造函数传参。</li>
<li><strong>构造继承</strong>，使用父类的构造函数来增强子类实例，即复制父类的实例属性给子类，构造继承可以向父类传递参数，可以实现多继承，通过<code>call</code>多个父类对象。但是构造继承只能继承父类的实例属性和方法，不能继承原型属性和方法，无法实现函数服用，每个子类都有父类实例函数的副本，影响性能</li>
<li><strong>实例继承</strong>，为父类实例添加新特性，作为子类实例返回，实例继承的特点是不限制调用方法，不管是new 子类（）还是子类（）返回的对象具有相同的效果，缺点是实例是父类的实例，不是子类的实例，不支持多继承</li>
<li><strong>拷贝继承</strong>：特点：支持多继承，缺点：效率较低，内存占用高（因为要拷贝父类的属性）无法获取父类不可枚举的方法（不可枚举方法，不能使用<code>for in</code>访问到）</li>
<li><strong>组合继承</strong>：通过调用父类构造，继承父类的属性并保留传参的优点，然后通过将父类实例作为子类原型，实现函数复用</li>
<li><strong>寄生组合继承</strong>：通过寄生方式，砍掉父类的实例属性，这样，在调用两次父类的构造的时候，就不会初始化两次实例方法/属性，避免的组合继承的缺点</li>
</ul>
<h3 id="加载"><a href="#加载" class="headerlink" title="加载"></a>加载</h3><p><strong>1. 异步加载js的方法</strong></p>
<ul>
<li><code>defer</code>：只支持IE如果您的脚本不会改变文档的内容，可将 <code>defer</code> 属性加入到<code>&lt;script&gt;</code>标签中，以便加快处理文档的速度。因为浏览器知道它将能够安全地读取文档的剩余部分而不用执行脚本，它将推迟对脚本的解释，直到文档已经显示给用户为止</li>
<li><code>async</code>：<code>HTML5</code> 属性，仅适用于外部脚本；并且如果在IE中，同时存在<code>defer</code>和<code>async</code>，那么<code>defer</code>的优先级比较高；脚本将在页面完成时执行</li>
</ul>
<p><strong>2. 图片的懒加载和预加载</strong></p>
<ul>
<li>预加载：提前加载图片，当用户需要查看时可直接从本地缓存中渲染。</li>
<li>懒加载：懒加载的主要目的是作为服务器前端的优化，减少请求数或延迟请求数</li>
</ul>
<blockquote>
<p>两种技术的本质：两者的行为是相反的，一个是提前加载，一个是迟缓甚至不加载。懒加载对服务器前端有一定的缓解压力作用，预加载则会增加服务器前端压力。</p>
</blockquote>
<h3 id="有四个操作会忽略enumerable为false的属性"><a href="#有四个操作会忽略enumerable为false的属性" class="headerlink" title="有四个操作会忽略enumerable为false的属性"></a>有四个操作会忽略enumerable为false的属性</h3><ul>
<li><code>for...in</code>循环：只遍历对象自身的和继承的可枚举的属性。</li>
<li><code>Object.keys()</code>：返回对象自身的所有可枚举的属性的键名。</li>
<li><code>JSON.stringify()</code>：只串行化对象自身的可枚举的属性。</li>
<li><code>Object.assign()</code>： 忽略<code>enumerable</code>为<code>false</code>的属性，只拷贝对象自身的可枚举的属性。</li>
</ul>
<h3 id="属性的遍历"><a href="#属性的遍历" class="headerlink" title="属性的遍历"></a>属性的遍历</h3><blockquote>
<p>ES6 一共有 5 种方法可以遍历对象的属性。</p>
</blockquote>
<p><strong>（1）for…in</strong></p>
<blockquote>
<p><code>for...in</code>循环遍历对象自身的和继承的可枚举属性（不含 Symbol 属性）。</p>
</blockquote>
<p><strong>（2）Object.keys(obj)</strong></p>
<blockquote>
<p><code>Object.keys</code>返回一个数组，包括对象自身的（不含继承的）所有可枚举属性（不含 Symbol 属性）的键名。</p>
</blockquote>
<p><strong>（3）Object.getOwnPropertyNames(obj)</strong></p>
<blockquote>
<p><code>Object.getOwnPropertyNames</code>返回一个数组，包含对象自身的所有属性（不含 Symbol 属性，但是包括不可枚举属性）的键名。</p>
</blockquote>
<p><strong>（4）Object.getOwnPropertySymbols(obj)</strong></p>
<blockquote>
<p><code>Object.getOwnPropertySymbols</code>返回一个数组，包含对象自身的所有 Symbol 属性的键名。</p>
</blockquote>
<p><strong>（5）Reflect.ownKeys(obj)</strong></p>
<blockquote>
<p><code>Reflect.ownKeys</code>返回一个数组，包含对象自身的（不含继承的）所有键名，不管键名是 Symbol 或字符串，也不管是否可枚举。</p>
</blockquote>
<blockquote>
<p>以上的 5 种方法遍历对象的键名，都遵守同样的属性遍历的次序规则。</p>
</blockquote>
<ul>
<li>首先遍历所有数值键，按照数值升序排列。</li>
<li>其次遍历所有字符串键，按照加入时间升序排列。</li>
<li>最后遍历所有 Symbol 键，按照加入时间升序排列。</li>
</ul>
<figure class="highlight text"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Reflect.ownKeys({ [Symbol()]:0, b:0, 10:0, 2:0, a:0 })</span><br><span class="line">// ['2', '10', 'b', 'a', Symbol()]</span><br></pre></td></tr></tbody></table></figure>

<blockquote>
<p>上面代码中，<code>Reflect.ownKeys</code>方法返回一个数组，包含了参数对象的所有属性。这个数组的属性次序是这样的，首先是数值属性2和10，其次是字符串属性b和a，最后是 <code>Symbol</code> 属性。</p>
</blockquote>
<h3 id="为什么通常在发送数据埋点请求的时候使用的是-1x1-像素的透明-gif-图片"><a href="#为什么通常在发送数据埋点请求的时候使用的是-1x1-像素的透明-gif-图片" class="headerlink" title="为什么通常在发送数据埋点请求的时候使用的是 1x1 像素的透明 gif 图片"></a>为什么通常在发送数据埋点请求的时候使用的是 1x1 像素的透明 gif 图片</h3><ul>
<li>能够完成整个 HTTP 请求+响应（尽管不需要响应内容）</li>
<li>触发 GET 请求之后不需要获取和处理数据、服务器也不需要发送数据</li>
<li>跨域友好</li>
<li>执行过程无阻塞</li>
<li>相比 XMLHttpRequest 对象发送 GET 请求，性能上更好</li>
<li>GIF的最低合法体积最小（最小的BMP文件需要74个字节，PNG需要67个字节，而合法的GIF，只需要43个字节）</li>
</ul>
<h3 id="对原生Javascript了解程度"><a href="#对原生Javascript了解程度" class="headerlink" title="对原生Javascript了解程度"></a>对原生Javascript了解程度</h3><ul>
<li>数据类型、运算、对象、Function、继承、闭包、作用域、原型链、事件、<code>RegExp</code>、<code>JSON</code>、<code>Ajax</code>、<code>DOM</code>、<code>BOM</code>、内存泄漏、跨域、异步装载、模板引擎、前端<code>MVC</code>、路由、模块化、<code>Canvas</code>、<code>ECMAScript</code></li>
</ul>
<h3 id="Js动画与CSS动画区别及相应实现"><a href="#Js动画与CSS动画区别及相应实现" class="headerlink" title="Js动画与CSS动画区别及相应实现"></a>Js动画与CSS动画区别及相应实现</h3><ul>
<li><code>CSS3</code>的动画的优点<ul>
<li>在性能上会稍微好一些，浏览器会对<code>CSS3</code>的动画做一些优化</li>
<li>代码相对简单</li>
</ul>
</li>
<li>缺点<ul>
<li>在动画控制上不够灵活</li>
<li>兼容性不好</li>
</ul>
</li>
<li><code>JavaScript</code>的动画正好弥补了这两个缺点，控制能力很强，可以单帧的控制、变换，同时写得好完全可以兼容<code>IE6</code>，并且功能强大。对于一些复杂控制的动画，使用<code>javascript</code>会比较靠谱。而在实现一些小的交互动效的时候，就多考虑考虑<code>CSS</code>吧</li>
</ul>
<h3 id="JS-数组和对象的遍历方式，以及几种方式的比较"><a href="#JS-数组和对象的遍历方式，以及几种方式的比较" class="headerlink" title="JS 数组和对象的遍历方式，以及几种方式的比较"></a>JS 数组和对象的遍历方式，以及几种方式的比较</h3><blockquote>
<p>通常我们会用循环的方式来遍历数组。但是循环是 导致js 性能问题的原因之一。一般我们会采用下几种方式来进行数组的遍历</p>
</blockquote>
<ul>
<li><code>for in</code>循环</li>
<li><code>for</code>循环</li>
<li><code>forEach</code><ul>
<li>这里的 <code>forEach</code>回调中两个参数分别为 <code>value</code>，<code>index</code></li>
<li><code>forEach</code> 无法遍历对象</li>
<li>IE不支持该方法；<code>Firefox</code> 和 <code>chrome</code> 支持</li>
<li><code>forEach</code> 无法使用 <code>break</code>，<code>continue</code> 跳出循环，且使用 <code>return</code> 是跳过本次循环</li>
</ul>
</li>
<li>这两种方法应该非常常见且使用很频繁。但实际上，这两种方法都存在性能问题</li>
<li>在方式一中，<code>for-in</code>需要分析出<code>array</code>的每个属性，这个操作性能开销很大。用在 <code>key</code> 已知的数组上是非常不划算的。所以尽量不要用<code>for-in</code>，除非你不清楚要处理哪些属性，例如 <code>JSON</code>对象这样的情况</li>
<li>在方式2中，循环每进行一次，就要检查一下数组长度。读取属性（数组长度）要比读局部变量慢，尤其是当 <code>array</code> 里存放的都是 <code>DOM</code> 元素，因为每次读取都会扫描一遍页面上的选择器相关元素，速度会大大降低</li>
</ul>
<h3 id="事件的各个阶段"><a href="#事件的各个阶段" class="headerlink" title="事件的各个阶段"></a>事件的各个阶段</h3><ul>
<li>1：捕获阶段 —&gt; 2：目标阶段 —&gt; 3：冒泡阶段</li>
<li><code>document</code> —&gt; <code>target</code>目标 —-&gt; <code>document</code></li>
<li>由此，<code>addEventListener</code>的第三个参数设置为<code>true</code>和<code>false</code>的区别已经非常清晰了<ul>
<li><code>true</code>表示该元素在事件的“捕获阶段”（由外往内传递时）响应事件</li>
<li><code>false</code>表示该元素在事件的“冒泡阶段”（由内向外传递时）响应事件</li>
</ul>
</li>
</ul>
<h3 id="如何渲染几万条数据并不卡住界面"><a href="#如何渲染几万条数据并不卡住界面" class="headerlink" title="如何渲染几万条数据并不卡住界面"></a>如何渲染几万条数据并不卡住界面</h3><blockquote>
<p>这道题考察了如何在不卡住页面的情况下渲染数据，也就是说不能一次性将几万条都渲染出来，而应该一次渲染部分 <code>DOM</code>，那么就可以通过 <code>requestAnimationFrame</code> 来每 <code>16 ms</code> 刷新一次</p>
</blockquote>
<figure class="highlight html"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="meta-keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">"en"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">"UTF-8"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">"viewport"</span> <span class="attr">content</span>=<span class="string">"width=device-width, initial-scale=1.0"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">meta</span> <span class="attr">http-equiv</span>=<span class="string">"X-UA-Compatible"</span> <span class="attr">content</span>=<span class="string">"ie=edge"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">title</span>&gt;</span>Document<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">ul</span>&gt;</span>控件<span class="tag">&lt;/<span class="name">ul</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="javascript">    <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> {</span></span><br><span class="line"><span class="javascript">      <span class="comment">// 插入十万条数据</span></span></span><br><span class="line"><span class="javascript">      <span class="keyword">const</span> total = <span class="number">100000</span></span></span><br><span class="line"><span class="javascript">      <span class="comment">// 一次插入 20 条，如果觉得性能不好就减少</span></span></span><br><span class="line"><span class="javascript">      <span class="keyword">const</span> once = <span class="number">20</span></span></span><br><span class="line"><span class="javascript">      <span class="comment">// 渲染数据总共需要几次</span></span></span><br><span class="line"><span class="javascript">      <span class="keyword">const</span> loopCount = total / once</span></span><br><span class="line"><span class="javascript">      <span class="keyword">let</span> countOfRender = <span class="number">0</span></span></span><br><span class="line"><span class="javascript">      <span class="keyword">let</span> ul = <span class="built_in">document</span>.querySelector(<span class="string">"ul"</span>);</span></span><br><span class="line"><span class="javascript">      <span class="function"><span class="keyword">function</span> <span class="title">add</span>(<span class="params"></span>) </span>{</span></span><br><span class="line"><span class="javascript">        <span class="comment">// 优化性能，插入不会造成回流</span></span></span><br><span class="line"><span class="javascript">        <span class="keyword">const</span> fragment = <span class="built_in">document</span>.createDocumentFragment();</span></span><br><span class="line"><span class="javascript">        <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; once; i++) {</span></span><br><span class="line"><span class="javascript">          <span class="keyword">const</span> li = <span class="built_in">document</span>.createElement(<span class="string">"li"</span>);</span></span><br><span class="line"><span class="javascript">          li.innerText = <span class="built_in">Math</span>.floor(<span class="built_in">Math</span>.random() * total);</span></span><br><span class="line">          fragment.appendChild(li);</span><br><span class="line">        }</span><br><span class="line">        ul.appendChild(fragment);</span><br><span class="line">        countOfRender += 1;</span><br><span class="line">        loop();</span><br><span class="line">      }</span><br><span class="line"><span class="javascript">      <span class="function"><span class="keyword">function</span> <span class="title">loop</span>(<span class="params"></span>) </span>{</span></span><br><span class="line">        if (countOfRender &lt; loopCount) {</span><br><span class="line"><span class="javascript">          <span class="built_in">window</span>.requestAnimationFrame(add);</span></span><br><span class="line">        }</span><br><span class="line">      }</span><br><span class="line">      loop();</span><br><span class="line">    }, 0);</span><br><span class="line">  <span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></tbody></table></figure>

<h3 id="希望获取到页面中所有的checkbox怎么做？"><a href="#希望获取到页面中所有的checkbox怎么做？" class="headerlink" title="希望获取到页面中所有的checkbox怎么做？"></a>希望获取到页面中所有的checkbox怎么做？</h3><blockquote>
<p>不使用第三方框架</p>
</blockquote>
<figure class="highlight js"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> domList = <span class="built_in">document</span>.getElementsByTagName(‘input’)</span><br><span class="line"><span class="keyword">var</span> checkBoxList = [];</span><br><span class="line"><span class="keyword">var</span> len = domList.length;　　<span class="comment">//缓存到局部变量</span></span><br><span class="line"><span class="keyword">while</span> (len--) {　　<span class="comment">//使用while的效率会比for循环更高</span></span><br><span class="line">　　<span class="keyword">if</span> (domList[len].type == ‘checkbox’) {</span><br><span class="line">    　　checkBoxList.push(domList[len]);</span><br><span class="line">　　}</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<h3 id="JS-添加、移除、移动、复制、创建和查找节点"><a href="#JS-添加、移除、移动、复制、创建和查找节点" class="headerlink" title="JS 添加、移除、移动、复制、创建和查找节点"></a>JS 添加、移除、移动、复制、创建和查找节点</h3><p><strong>创建新节点</strong></p>
<figure class="highlight js"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">createDocumentFragment()    <span class="comment">//创建一个DOM片段</span></span><br><span class="line">createElement()   <span class="comment">//创建一个具体的元素</span></span><br><span class="line">createTextNode()   <span class="comment">//创建一个文本节点</span></span><br></pre></td></tr></tbody></table></figure>

<p><strong>添加、移除、替换、插入</strong></p>
<figure class="highlight js"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">appendChild()      <span class="comment">//添加</span></span><br><span class="line">removeChild()      <span class="comment">//移除</span></span><br><span class="line">replaceChild()      <span class="comment">//替换</span></span><br><span class="line">insertBefore()      <span class="comment">//插入</span></span><br></pre></td></tr></tbody></table></figure>

<p><strong>查找</strong></p>
<figure class="highlight js"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">getElementsByTagName()    <span class="comment">//通过标签名称</span></span><br><span class="line">getElementsByName()     <span class="comment">//通过元素的Name属性的值</span></span><br><span class="line">getElementById()        <span class="comment">//通过元素Id，唯一性</span></span><br></pre></td></tr></tbody></table></figure>

<h3 id="正则表达式"><a href="#正则表达式" class="headerlink" title="正则表达式"></a>正则表达式</h3><blockquote>
<p>正则表达式构造函数<code>var reg=new RegExp(“xxx”)</code>与正则表达字面量<code>var reg=//</code>有什么不同？匹配邮箱的正则表达式？</p>
</blockquote>
<ul>
<li>当使用<code>RegExp()</code>构造函数的时候，不仅需要转义引号（即<code>\</code>”表示”），并且还需要双反斜杠（即<code>\\</code>表示一个<code>\</code>）。使用正则表达字面量的效率更高</li>
</ul>
<p>邮箱的正则匹配：</p>
<figure class="highlight js"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> regMail = <span class="regexp">/^([a-zA-Z0-9_-])+@([a-zA-Z0-9_-])+((.[a-zA-Z0-9_-]{2,3}){1,2})$/</span>;</span><br></pre></td></tr></tbody></table></figure>

<h3 id="JS-中-callee-和-caller-的作用？"><a href="#JS-中-callee-和-caller-的作用？" class="headerlink" title="JS 中 callee 和 caller 的作用？"></a>JS 中 callee 和 caller 的作用？</h3><ul>
<li><code>caller</code>是返回一个对函数的引用，该函数调用了当前函数；</li>
<li><code>callee</code>是返回正在被执行的<code>function</code>函数，也就是所指定的<code>function</code>对象的正文</li>
</ul>
<blockquote>
<p>那么问题来了？如果一对兔子每月生一对兔子；一对新生兔，从第二个月起就开始生兔子；假定每对兔子都是一雌一雄，试问一对兔子，第n个月能繁殖成多少对兔子？（使用<code>callee</code>完成）</p>
</blockquote>
<figure class="highlight js"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> result=[];</span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">fn</span>(<span class="params">n</span>)</span>{  <span class="comment">//典型的斐波那契数列</span></span><br><span class="line">     <span class="keyword">if</span>(n==<span class="number">1</span>){</span><br><span class="line">          <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">     }<span class="keyword">else</span> <span class="keyword">if</span>(n==<span class="number">2</span>){</span><br><span class="line">             <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">     }<span class="keyword">else</span>{</span><br><span class="line">          <span class="keyword">if</span>(result[n]){</span><br><span class="line">                  <span class="keyword">return</span> result[n];</span><br><span class="line">         }<span class="keyword">else</span>{</span><br><span class="line">                 <span class="comment">//argument.callee()表示fn()</span></span><br><span class="line">                 result[n]=<span class="built_in">arguments</span>.callee(n-<span class="number">1</span>)+<span class="built_in">arguments</span>.callee(n-<span class="number">2</span>);</span><br><span class="line">                 <span class="keyword">return</span> result[n];</span><br><span class="line">         }</span><br><span class="line">    }</span><br><span class="line"> }</span><br></pre></td></tr></tbody></table></figure>

<h3 id="window-onload和-document-ready"><a href="#window-onload和-document-ready" class="headerlink" title="window.onload和$(document).ready"></a>window.onload和$(document).ready</h3><blockquote>
<p>原生<code>JS</code>的<code>window.onload</code>与<code>Jquery</code>的<code>$(document).ready(function(){})</code>有什么不同？如何用原生JS实现Jq的<code>ready</code>方法？</p>
</blockquote>
<ul>
<li><code>window.onload()</code>方法是必须等到页面内包括图片的所有元素加载完毕后才能执行。</li>
<li><code>$(document).ready()</code>是<code>DOM</code>结构绘制完毕后就执行，不必等到加载完毕</li>
</ul>
<figure class="highlight js"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">ready</span>(<span class="params">fn</span>)</span>{</span><br><span class="line">      <span class="keyword">if</span>(<span class="built_in">document</span>.addEventListener) {        <span class="comment">//标准浏览器</span></span><br><span class="line">          <span class="built_in">document</span>.addEventListener(<span class="string">'DOMContentLoaded'</span>, <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>{</span><br><span class="line">              <span class="comment">//注销事件, 避免反复触发</span></span><br><span class="line">              <span class="built_in">document</span>.removeEventListener(<span class="string">'DOMContentLoaded'</span>,<span class="built_in">arguments</span>.callee, <span class="literal">false</span>);</span><br><span class="line">              fn();            <span class="comment">//执行函数</span></span><br><span class="line">          }, <span class="literal">false</span>);</span><br><span class="line">      }<span class="keyword">else</span> <span class="keyword">if</span>(<span class="built_in">document</span>.attachEvent) {        <span class="comment">//IE</span></span><br><span class="line">          <span class="built_in">document</span>.attachEvent(<span class="string">'onreadystatechange'</span>, <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>{</span><br><span class="line">             <span class="keyword">if</span>(<span class="built_in">document</span>.readyState == <span class="string">'complete'</span>) {</span><br><span class="line">                 <span class="built_in">document</span>.detachEvent(<span class="string">'onreadystatechange'</span>, <span class="built_in">arguments</span>.callee);</span><br><span class="line">                 fn();        <span class="comment">//函数执行</span></span><br><span class="line">             }</span><br><span class="line">         });</span><br><span class="line">     }</span><br><span class="line"> };</span><br></pre></td></tr></tbody></table></figure>

<h3 id="addEventListener-和attachEvent-的区别"><a href="#addEventListener-和attachEvent-的区别" class="headerlink" title="addEventListener()和attachEvent()的区别"></a>addEventListener()和attachEvent()的区别</h3><ul>
<li><code>addEventListener()</code>是符合W3C规范的标准方法; <code>attachEvent()</code>是IE低版本的非标准方法</li>
<li><code>addEventListener()</code>支持事件冒泡和事件捕获; - 而<code>attachEvent()</code>只支持事件冒泡</li>
<li><code>addEventListener()</code>的第一个参数中,事件类型不需要添加<code>on</code>; <code>attachEvent()</code>需要添加<code>'on'</code></li>
<li>如果为同一个元素绑定多个事件, <code>addEventListener()</code>会按照事件绑定的顺序依次执行, <code>attachEvent()</code>会按照事件绑定的顺序倒序执行</li>
</ul>
<h3 id="获取页面所有的checkbox"><a href="#获取页面所有的checkbox" class="headerlink" title="获取页面所有的checkbox"></a>获取页面所有的checkbox</h3><figure class="highlight js"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> resultArr= [];</span><br><span class="line"><span class="keyword">var</span> input = <span class="built_in">document</span>.querySelectorAll(<span class="string">'input'</span>);</span><br><span class="line"><span class="keyword">for</span>( <span class="keyword">var</span> i = <span class="number">0</span>; i &lt; input.length; i++ ) {</span><br><span class="line">    <span class="keyword">if</span>( input[i].type == <span class="string">'checkbox'</span> ) {</span><br><span class="line">        resultArr.push( input[i] );</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"><span class="comment">//resultArr即中获取到了页面中的所有checkbox</span></span><br></pre></td></tr></tbody></table></figure>



<h3 id="JavaScript-对象生命周期的理解"><a href="#JavaScript-对象生命周期的理解" class="headerlink" title="JavaScript 对象生命周期的理解"></a>JavaScript 对象生命周期的理解</h3><ul>
<li>当创建一个对象时，<code>JavaScript</code> 会自动为该对象分配适当的内存</li>
<li>垃圾回收器定期扫描对象，并计算引用了该对象的其他对象的数量</li>
<li>如果被引用数量为 <code>0</code>，或惟一引用是循环的，那么该对象的内存即可回收</li>
</ul>
<h3 id="我现在有一个canvas，上面随机布着一些黑块，请实现方法，计算canvas上有多少个黑块"><a href="#我现在有一个canvas，上面随机布着一些黑块，请实现方法，计算canvas上有多少个黑块" class="headerlink" title="我现在有一个canvas，上面随机布着一些黑块，请实现方法，计算canvas上有多少个黑块"></a>我现在有一个<code>canvas</code>，上面随机布着一些黑块，请实现方法，计算canvas上有多少个黑块</h3><blockquote>
<p><span class="exturl" data-url="aHR0cHM6Ly93d3cuamlhbnNodS5jb20vcC9mNTRkMjY1ZjdhYTQ=">https://www.jianshu.com/p/f54d265f7aa4<i class="fa fa-external-link-alt"></i></span></p>
</blockquote>
<h3 id="介绍-DOM-的发展"><a href="#介绍-DOM-的发展" class="headerlink" title="介绍 DOM 的发展"></a>介绍 DOM 的发展</h3><ul>
<li><code>DOM</code>：文档对象模型（<code>Document Object Model</code>），定义了访问HTML和XML文档的标准，与编程语言及平台无关</li>
<li><code>DOM0</code>：提供了查询和操作Web文档的内容API。未形成标准，实现混乱。如：<code>document.forms['login']</code></li>
<li><code>DOM1</code>：W3C提出标准化的DOM，简化了对文档中任意部分的访问和操作。如：<code>JavaScript中的Document</code>对象</li>
<li><code>DOM2</code>：原来DOM基础上扩充了鼠标事件等细分模块，增加了对CSS的支持。如：<code>getComputedStyle(elem, pseudo)</code></li>
<li><code>DOM3</code>：增加了XPath模块和加载与保存（<code>Load and Save</code>）模块。如：<code>XPathEvaluator</code></li>
</ul>
<h3 id="介绍DOM0，DOM2，DOM3事件处理方式区别"><a href="#介绍DOM0，DOM2，DOM3事件处理方式区别" class="headerlink" title="介绍DOM0，DOM2，DOM3事件处理方式区别"></a>介绍DOM0，DOM2，DOM3事件处理方式区别</h3><ul>
<li>DOM0级事件处理方式：<ul>
<li><code>btn.onclick = func;</code></li>
<li><code>btn.onclick = null;</code></li>
</ul>
</li>
<li>DOM2级事件处理方式：<ul>
<li><code>btn.addEventListener('click', func, false);</code></li>
<li><code>btn.removeEventListener('click', func, false);</code></li>
<li><code>btn.attachEvent("onclick", func);</code></li>
<li><code>btn.detachEvent("onclick", func);</code></li>
</ul>
</li>
<li>DOM3级事件处理方式：<ul>
<li><code>eventUtil.addListener(input, "textInput", func);</code></li>
<li><code>eventUtil</code> 是自定义对象，<code>textInput</code> 是DOM3级事件</li>
</ul>
</li>
</ul>
<p><strong>事件的三个阶段</strong></p>
<ul>
<li>捕获、目标、冒泡</li>
</ul>
<h3 id="介绍事件“捕获”和“冒泡”执行顺序和事件的执行次数"><a href="#介绍事件“捕获”和“冒泡”执行顺序和事件的执行次数" class="headerlink" title="介绍事件“捕获”和“冒泡”执行顺序和事件的执行次数"></a>介绍事件“捕获”和“冒泡”执行顺序和事件的执行次数</h3><ul>
<li>按照W3C标准的事件：首是进入捕获阶段，直到达到目标元素，再进入冒泡阶段</li>
<li>事件执行次数（DOM2-addEventListener）：元素上绑定事件的个数<ul>
<li>注意1：前提是事件被确实触发</li>
<li>注意2：事件绑定几次就算几个事件，即使类型和功能完全一样也不会“覆盖”</li>
</ul>
</li>
<li>事件执行顺序：判断的关键是否目标元素<ul>
<li>非目标元素：根据W3C的标准执行：捕获-&gt;目标元素-&gt;冒泡（不依据事件绑定顺序）</li>
<li>目标元素：依据事件绑定顺序：先绑定的事件先执行（不依据捕获冒泡标准）</li>
<li>最终顺序：父元素捕获-&gt;目标元素事件1-&gt;目标元素事件2-&gt;子元素捕获-&gt;子元素冒泡-&gt;父元素冒泡</li>
<li>注意：子元素事件执行前提 事件确实“落”到子元素布局区域上，而不是简单的具有嵌套关系</li>
</ul>
</li>
</ul>
<p><strong>在一个DOM上同时绑定两个点击事件：一个用捕获，一个用冒泡。事件会执行几次，先执行冒泡还是捕获？</strong></p>
<ul>
<li>该DOM上的事件如果被触发，会执行两次（执行次数等于绑定次数）</li>
<li>如果该DOM是目标元素，则按事件绑定顺序执行，不区分冒泡/捕获</li>
<li>如果该DOM是处于事件流中的非目标元素，则先执行捕获，后执行冒泡</li>
</ul>
<p><strong>事件的代理/委托</strong></p>
<ul>
<li>事件委托是指将事件绑定目标元素的到父元素上，利用冒泡机制触发该事件<ul>
<li>优点：<ul>
<li>可以减少事件注册，节省大量内存占用</li>
<li>可以将事件应用于动态添加的子元素上</li>
</ul>
</li>
<li>缺点： 使用不当会造成事件在不应该触发时触发</li>
<li>示例：</li>
</ul>
</li>
</ul>
<figure class="highlight text"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">ulEl.addEventListener('click', function(e){</span><br><span class="line">    var target = event.target || event.srcElement;</span><br><span class="line">    if(!!target &amp;&amp; target.nodeName.toUpperCase() === "LI"){</span><br><span class="line">        console.log(target.innerHTML);</span><br><span class="line">    }</span><br><span class="line">}, false);</span><br></pre></td></tr></tbody></table></figure>

<p><strong>W3C事件的 target 与 currentTarget 的区别？</strong></p>
<ul>
<li><code>target</code> 只会出现在事件流的目标阶段</li>
<li><code>currentTarget</code> 可能出现在事件流的任何阶段</li>
<li>当事件流处在目标阶段时，二者的指向相同</li>
<li>当事件流处于捕获或冒泡阶段时：<code>currentTarget</code> 指向当前事件活动的对象(一般为父级)</li>
</ul>
<p><strong>如何派发事件(dispatchEvent)？（如何进行事件广播？）</strong></p>
<ul>
<li>W3C: 使用 <code>dispatchEvent</code> 方法</li>
<li>IE: 使用 <code>fireEvent</code> 方法</li>
</ul>
<figure class="highlight js"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> fireEvent = <span class="function"><span class="keyword">function</span>(<span class="params">element, event</span>)</span>{</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">document</span>.createEventObject){</span><br><span class="line">        <span class="keyword">var</span> mockEvent = <span class="built_in">document</span>.createEventObject();</span><br><span class="line">        <span class="keyword">return</span> element.fireEvent(<span class="string">'on'</span> + event, mockEvent)</span><br><span class="line">    }<span class="keyword">else</span>{</span><br><span class="line">        <span class="keyword">var</span> mockEvent = <span class="built_in">document</span>.createEvent(<span class="string">'HTMLEvents'</span>);</span><br><span class="line">        mockEvent.initEvent(event, <span class="literal">true</span>, <span class="literal">true</span>);</span><br><span class="line">        <span class="keyword">return</span> !element.dispatchEvent(mockEvent);</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>



<h3 id="区分“客户区坐标”、“页面坐标”、“屏幕坐标”"><a href="#区分“客户区坐标”、“页面坐标”、“屏幕坐标”" class="headerlink" title="区分“客户区坐标”、“页面坐标”、“屏幕坐标”"></a>区分“客户区坐标”、“页面坐标”、“屏幕坐标”</h3><ul>
<li>客户区坐标：鼠标指针在可视区中的水平坐标(<code>clientX</code>)和垂直坐标(<code>clientY</code>)</li>
<li>页面坐标：鼠标指针在页面布局中的水平坐标(<code>pageX</code>)和垂直坐标(<code>pageY</code>)</li>
<li>屏幕坐标：设备物理屏幕的水平坐标(<code>screenX</code>)和垂直坐标(<code>screenY</code>)</li>
</ul>
<p><strong>如何获得一个DOM元素的绝对位置？</strong></p>
<ul>
<li><code>elem.offsetLef</code>t：返回元素相对于其定位父级左侧的距离</li>
<li><code>elem.offsetTop</code>：返回元素相对于其定位父级顶部的距离</li>
<li><code>elem.getBoundingClientRect()</code>：返回一个<code>DOMRect</code>对象，包含一组描述边框的只读属性，单位像素</li>
</ul>
<h3 id="解释一下这段代码的意思"><a href="#解释一下这段代码的意思" class="headerlink" title="解释一下这段代码的意思"></a>解释一下这段代码的意思</h3><figure class="highlight js"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[].forEach.call($$(<span class="string">"*"</span>), <span class="function"><span class="keyword">function</span>(<span class="params">el</span>)</span>{</span><br><span class="line">    el.style.outline = <span class="string">"1px solid #"</span> + (~~(<span class="built_in">Math</span>.random()*(<span class="number">1</span>&lt;&lt;<span class="number">24</span>))).toString(<span class="number">16</span>);</span><br><span class="line">})</span><br></pre></td></tr></tbody></table></figure>

<ul>
<li>解释：获取页面所有的元素，遍历这些元素，为它们添加1像素随机颜色的轮廓(outline)</li>
<li><ol>
<li><code>$$(sel)</code> // $$函数被许多现代浏览器命令行支持，等价于 document.querySelectorAll(sel)</li>
</ol>
</li>
<li><ol>
<li><code>[].forEach.call(NodeLists)</code> // 使用 call 函数将数组遍历函数 forEach 应到节点元素列表</li>
</ol>
</li>
<li><ol>
<li><code>el.style.outline = "1px solid #333"</code> // 样式 outline 位于盒模型之外，不影响元素布局位置</li>
</ol>
</li>
<li><ol>
<li><code>(1&lt;&lt;24)</code> // parseInt(“ffffff”, 16) == 16777215 == 2^24 - 1 // 1&lt;&lt;24 == 2^24 == 16777216</li>
</ol>
</li>
<li><ol>
<li><code>Math.random()*(1&lt;&lt;24)</code> // 表示一个位于 0 到 16777216 之间的随机浮点数</li>
</ol>
</li>
<li><ol>
<li><code>~~Math.random()*(1&lt;&lt;24)</code> // <code>~~</code> 作用相当于 parseInt 取整</li>
</ol>
</li>
<li><ol>
<li><code>(~~(Math.random()*(1&lt;&lt;24))).toString(16)</code> // 转换为一个十六进制</li>
</ol>
</li>
</ul>
<h3 id="请解释一下-JS-的同源策略"><a href="#请解释一下-JS-的同源策略" class="headerlink" title="请解释一下 JS 的同源策略"></a>请解释一下 JS 的同源策略</h3><ul>
<li>概念:同源策略是客户端脚本（尤其是Javascript）的重要的安全度量标准。它最早出自Netscape Navigator2.0，其目的是防止某个文档或脚本从多个不同源装载。这里的同源策略指的是：协议，域名，端口相同，同源策略是一种安全协议</li>
<li>指一段脚本只能读取来自同一来源的窗口和文档的属性</li>
</ul>
<p><strong>为什么要有同源限制？</strong></p>
<ul>
<li>我们举例说明：比如一个黑客程序，他利用Iframe把真正的银行登录页面嵌到他的页面上，当你使用真实的用户名，密码登录时，他的页面就可以通过Javascript读取到你的表单中input中的内容，这样用户名，密码就轻松到手了。</li>
<li>缺点<ul>
<li>现在网站的JS都会进行压缩，一些文件用了严格模式，而另一些没有。这时这些本来是严格模式的文件，被 merge后，这个串就到了文件的中间，不仅没有指示严格模式，反而在压缩后浪费了字节</li>
</ul>
</li>
</ul>
<h3 id="如何删除一个cookie"><a href="#如何删除一个cookie" class="headerlink" title="如何删除一个cookie"></a>如何删除一个cookie</h3><ul>
<li>将时间设为当前时间往前一点</li>
</ul>
<figure class="highlight js"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> date = <span class="keyword">new</span> <span class="built_in">Date</span>();</span><br><span class="line"></span><br><span class="line">date.setDate(date.getDate() - <span class="number">1</span>);<span class="comment">//真正的删除</span></span><br></pre></td></tr></tbody></table></figure>

<blockquote>
<p><code>setDate()</code>方法用于设置一个月的某一天</p>
</blockquote>
<ul>
<li><code>expires</code>的设置</li>
</ul>
<figure class="highlight js"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">document</span>.cookie = <span class="string">'user='</span>+ <span class="built_in">encodeURIComponent</span>(<span class="string">'name'</span>)  + <span class="string">';expires = '</span> + <span class="keyword">new</span> <span class="built_in">Date</span>(<span class="number">0</span>)</span><br></pre></td></tr></tbody></table></figure>

<h3 id="页面编码和被请求的资源编码如果不一致如何处理"><a href="#页面编码和被请求的资源编码如果不一致如何处理" class="headerlink" title="页面编码和被请求的资源编码如果不一致如何处理"></a>页面编码和被请求的资源编码如果不一致如何处理</h3><ul>
<li>后端响应头设置 <code>charset</code></li>
<li>前端页面<code>&lt;meta&gt;</code>设置 <code>charset</code></li>
</ul>
<h3 id="把-lt-script-gt-放在-lt-body-gt-之前和之后有什么区别？浏览器会如何解析它们？"><a href="#把-lt-script-gt-放在-lt-body-gt-之前和之后有什么区别？浏览器会如何解析它们？" class="headerlink" title="把<script>放在</body>之前和之后有什么区别？浏览器会如何解析它们？"></a>把<code>&lt;script&gt;</code>放在<code>&lt;/body&gt;</code>之前和之后有什么区别？浏览器会如何解析它们？</h3><ul>
<li>按照HTML标准，在<code>&lt;/body&gt;</code>结束后出现<code>&lt;script&gt;</code>或任何元素的开始标签，都是解析错误</li>
<li>虽然不符合HTML标准，但浏览器会自动容错，使实际效果与写在<code>&lt;/body&gt;</code>之前没有区别</li>
<li>浏览器的容错机制会忽略<code>&lt;script&gt;</code>之前的<code>&lt;/body&gt;</code>，视作<code>&lt;script&gt;</code>仍在 body 体内。省略<code>&lt;/body&gt;</code>和<code>&lt;/html&gt;</code>闭合标签符合HTML标准，服务器可以利用这一标准尽可能少输出内容</li>
</ul>
<h3 id="JS-中，调用函数有哪几种方式"><a href="#JS-中，调用函数有哪几种方式" class="headerlink" title="JS 中，调用函数有哪几种方式"></a>JS 中，调用函数有哪几种方式</h3><ul>
<li>方法调用模式 <code>Foo.foo(arg1, arg2);</code></li>
<li>函数调用模式 <code>foo(arg1, arg2);</code></li>
<li>构造器调用模式 <code>(new Foo())(arg1, arg2);</code></li>
<li><code>call/applay</code>调用模式 <code>Foo.foo.call(that, arg1, arg2);</code></li>
<li><code>bind</code>调用模式 <code>Foo.foo.bind(that)(arg1, arg2)();</code></li>
</ul>
<h3 id="简单实现-Function-bind-函数"><a href="#简单实现-Function-bind-函数" class="headerlink" title="简单实现 Function.bind 函数"></a>简单实现 Function.bind 函数</h3><figure class="highlight js"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (!<span class="built_in">Function</span>.prototype.bind) {</span><br><span class="line">  <span class="built_in">Function</span>.prototype.bind = <span class="function"><span class="keyword">function</span>(<span class="params">that</span>) </span>{</span><br><span class="line">    <span class="keyword">var</span> func = <span class="built_in">this</span>, args = <span class="built_in">arguments</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>{</span><br><span class="line">      <span class="keyword">return</span> func.apply(that, <span class="built_in">Array</span>.prototype.slice.call(args, <span class="number">1</span>));</span><br><span class="line">    }</span><br><span class="line">  }</span><br><span class="line">}</span><br><span class="line"><span class="comment">// 只支持 bind 阶段的默认参数：</span></span><br><span class="line">func.bind(that, arg1, arg2)();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 不支持以下调用阶段传入的参数：</span></span><br><span class="line">func.bind(that)(arg1, arg2);</span><br></pre></td></tr></tbody></table></figure>



<h3 id="什么是单线程，和异步的关系"><a href="#什么是单线程，和异步的关系" class="headerlink" title="什么是单线程，和异步的关系"></a>什么是单线程，和异步的关系</h3><ul>
<li>单线程 - 只有一个线程，只能做一件事</li>
<li>原因 - 避免<code>DOM</code>渲染的冲突<ul>
<li>浏览器需要渲染 <code>DOM</code></li>
<li><code>JS</code> 可以修改 <code>DOM</code> 结构</li>
<li><code>JS</code> 执行的时候，浏览器 <code>DOM</code> 渲染会暂停</li>
<li>两段 JS 也不能同时执行（都修改 <code>DOM</code> 就冲突了）</li>
<li><code>webworker</code> 支持多线程，但是不能访问 <code>DOM</code></li>
</ul>
</li>
<li>解决方案 - 异步</li>
</ul>
<h3 id="是否用过-jQuery-的-Deferred"><a href="#是否用过-jQuery-的-Deferred" class="headerlink" title="是否用过 jQuery 的 Deferred"></a>是否用过 jQuery 的 Deferred</h3><p><img data-src="https://raw.githubusercontent.com/henfy233/picgo/main/img/7.png" alt="img"> <img data-src="https://s.poetries.work/gitee/2020/07/8.png" alt="img"> <img data-src="https://s.poetries.work/gitee/2020/07/9.png" alt="img"> <img data-src="https://s.poetries.work/gitee/2020/07/10.png" alt="img"> <img data-src="https://s.poetries.work/gitee/2020/07/11.png" alt="img"> <img data-src="https://s.poetries.work/gitee/2020/07/12.png" alt="img"> <img data-src="https://s.poetries.work/gitee/2020/07/13.png" alt="img"> <img data-src="https://s.poetries.work/gitee/2020/07/14.png" alt="img"> <img data-src="https://s.poetries.work/gitee/2020/07/15.png" alt="img"> <img data-src="https://s.poetries.work/gitee/2020/07/16.png" alt="img"></p>
<h3 id="前端面试之hybrid"><a href="#前端面试之hybrid" class="headerlink" title="前端面试之hybrid"></a>前端面试之hybrid</h3><blockquote>
<p><span class="exturl" data-url="aHR0cDovL2Jsb2cucG9ldHJpZXMudG9wLzIwMTgvMTAvMjAvZmUtaW50ZXJ2aWV3LWh5YnJpZC8=">http://blog.poetries.top/2018/10/20/fe-interview-hybrid/(opens new window)<i class="fa fa-external-link-alt"></i></span></p>
</blockquote>
<h3 id="前端面试之组件化"><a href="#前端面试之组件化" class="headerlink" title="前端面试之组件化"></a>前端面试之组件化</h3><blockquote>
<p><span class="exturl" data-url="aHR0cDovL2Jsb2cucG9ldHJpZXMudG9wLzIwMTgvMTAvMjAvZmUtaW50ZXJ2aWV3LWNvbXBvbmVudC8=">http://blog.poetries.top/2018/10/20/fe-interview-component/(opens new window)<i class="fa fa-external-link-alt"></i></span></p>
</blockquote>
<h3 id="前端面试之MVVM浅析"><a href="#前端面试之MVVM浅析" class="headerlink" title="前端面试之MVVM浅析"></a>前端面试之MVVM浅析</h3><blockquote>
<p><span class="exturl" data-url="aHR0cDovL2Jsb2cucG9ldHJpZXMudG9wLzIwMTgvMTAvMjAvZmUtaW50ZXJ2aWV3LW12dm0v">http://blog.poetries.top/2018/10/20/fe-interview-mvvm/(opens new window)<i class="fa fa-external-link-alt"></i></span></p>
</blockquote>
<h3 id="实现效果，点击容器内的图标，图标边框变成border-1px-solid-red，点击空白处重置"><a href="#实现效果，点击容器内的图标，图标边框变成border-1px-solid-red，点击空白处重置" class="headerlink" title="实现效果，点击容器内的图标，图标边框变成border 1px solid red，点击空白处重置"></a>实现效果，点击容器内的图标，图标边框变成border 1px solid red，点击空白处重置</h3><figure class="highlight js"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> box = <span class="built_in">document</span>.getElementById(<span class="string">'box'</span>);</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">isIcon</span>(<span class="params">target</span>) </span>{</span><br><span class="line">  <span class="keyword">return</span> target.className.includes(<span class="string">'icon'</span>);</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">box.onClick = <span class="function"><span class="keyword">function</span>(<span class="params">e</span>) </span>{</span><br><span class="line">  e.stopPropagation();</span><br><span class="line">  <span class="keyword">const</span> target = e.target;</span><br><span class="line">  <span class="keyword">if</span> (isIcon(target)) {</span><br><span class="line">    target.style.border = <span class="string">'1px solid red'</span>;</span><br><span class="line">  }</span><br><span class="line">}</span><br><span class="line"><span class="keyword">const</span> doc = <span class="built_in">document</span>;</span><br><span class="line">doc.onclick = <span class="function"><span class="keyword">function</span>(<span class="params">e</span>) </span>{</span><br><span class="line">  <span class="keyword">const</span> children = box.children;</span><br><span class="line">  <span class="keyword">for</span>(<span class="keyword">let</span> i; i &lt; children.length; i++) {</span><br><span class="line">    <span class="keyword">if</span> (isIcon(children[i])) {</span><br><span class="line">      children[i].style.border = <span class="string">'none'</span>;</span><br><span class="line">    }</span><br><span class="line">  }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>



<h3 id="JavaScript的组成"><a href="#JavaScript的组成" class="headerlink" title="JavaScript的组成"></a>JavaScript的组成</h3><ul>
<li><code>JavaScript</code>由以下三部分组成：<ul>
<li><code>ECMAScript（核心）：</code>JavaScript` 语言基础</li>
<li><code>DOM</code>（文档对象模型）：规定了访问<code>HTML</code>和<code>XML</code>的接口</li>
<li><code>BOM</code>（浏览器对象模型）：提供了浏览器窗口之间进行交互的对象和方法</li>
</ul>
</li>
</ul>
<h3 id="说几条写JavaScript的基本规范"><a href="#说几条写JavaScript的基本规范" class="headerlink" title="说几条写JavaScript的基本规范"></a>说几条写JavaScript的基本规范</h3><ul>
<li>代码缩进，建议使用“四个空格”缩进</li>
<li>代码段使用花括号<code>{}</code>包裹</li>
<li>语句结束使用分号;</li>
<li>变量和函数在使用前进行声明</li>
<li>以大写字母开头命名构造函数，全大写命名常量</li>
<li>规范定义<code>JSON</code>对象，补全双引号</li>
<li>用<code>{}</code>和<code>[]</code>声明对象和数组</li>
</ul>
<h3 id="如何编写高性能的JavaScript"><a href="#如何编写高性能的JavaScript" class="headerlink" title="如何编写高性能的JavaScript"></a>如何编写高性能的JavaScript</h3><ul>
<li>遵循严格模式：<code>"use strict";</code></li>
<li>将js脚本放在页面底部，加快渲染页面</li>
<li>将js脚本将脚本成组打包，减少请求</li>
<li>使用非阻塞方式下载js脚本</li>
<li>尽量使用局部变量来保存全局变量</li>
<li>尽量减少使用闭包</li>
<li>使用 <code>window</code> 对象属性方法时，省略 <code>window</code></li>
<li>尽量减少对象成员嵌套</li>
<li>缓存 <code>DOM</code> 节点的访问</li>
<li>通过避免使用 <code>eval()</code> 和 <code>Function()</code> 构造器</li>
<li>给 <code>setTimeout()</code> 和 <code>setInterval()</code> 传递函数而不是字符串作为参数</li>
<li>尽量使用直接量创建对象和数组</li>
<li>最小化重绘(<code>repaint</code>)和回流(<code>reflow</code>)</li>
</ul>
<h3 id="script-的位置是否会影响首屏显示时间"><a href="#script-的位置是否会影响首屏显示时间" class="headerlink" title="script 的位置是否会影响首屏显示时间"></a>script 的位置是否会影响首屏显示时间</h3><ul>
<li>在解析 <code>HTML</code> 生成 <code>DOM</code> 过程中，<code>js</code> 文件的下载是并行的，不需要 <code>DOM</code> 处理到 <code>script</code> 节点。因此，<code>script</code>的位置不影响首屏显示的开始时间。</li>
<li>浏览器解析 <code>HTML</code> 是自上而下的线性过程，<code>script</code>作为 <code>HTML</code> 的一部分同样遵循这个原则</li>
<li>因此，<code>script</code> 会延迟 <code>DomContentLoad</code>，只显示其上部分首屏内容，从而影响首屏显示的完成时间</li>
</ul>
<h3 id="解释-JS-中的作用域与变量声明提升"><a href="#解释-JS-中的作用域与变量声明提升" class="headerlink" title="解释 JS 中的作用域与变量声明提升"></a>解释 JS 中的作用域与变量声明提升</h3><ul>
<li><code>JavaScript</code>作用域：<ul>
<li>在<code>Java</code>、<code>C</code>等语言中，作用域为for语句、<code>if</code>语句或<code>{}</code>内的一块区域，称为作用域；</li>
<li>而在 <code>JavaScript</code> 中，作用域为<code>function(){}</code>内的区域，称为函数作用域。</li>
</ul>
</li>
<li><code>JavaScript</code>变量声明提升：<ul>
<li>在<code>JavaScript</code>中，函数声明与变量声明经常被<code>JavaScript</code>引擎隐式地提升到当前作用域的顶部。</li>
<li>声明语句中的赋值部分并不会被提升，只有名称被提升</li>
<li>函数声明的优先级高于变量，如果变量名跟函数名相同且未赋值，则函数声明会覆盖变量声明</li>
<li>如果函数有多个同名参数，那么最后一个参数（即使没有定义）会覆盖前面的同名参数</li>
</ul>
</li>
</ul>
<h3 id="JS-实现一个类，实例化这个类"><a href="#JS-实现一个类，实例化这个类" class="headerlink" title="JS 实现一个类，实例化这个类"></a>JS 实现一个类，实例化这个类</h3><ul>
<li>构造函数法（<code>this</code>+<code>prototype</code>） – 用<code>new</code>关键字 生成实例对象<ul>
<li>缺点：用到了 <code>this</code> 和 <code>prototype</code>，编写复杂，可读性差</li>
</ul>
</li>
</ul>
<figure class="highlight js"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Mobile</span>(<span class="params">name, price</span>)</span>{</span><br><span class="line">  <span class="built_in">this</span>.name = name;</span><br><span class="line">  <span class="built_in">this</span>.price = price;</span><br><span class="line">}</span><br><span class="line">Mobile.prototype.sell = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>{</span><br><span class="line">  alert(<span class="built_in">this</span>.name + <span class="string">"，售价 $"</span> + <span class="built_in">this</span>.price);</span><br><span class="line">}</span><br><span class="line"><span class="keyword">var</span> iPhone7 = <span class="keyword">new</span> Mobile(<span class="string">"iPhone7"</span>, <span class="number">1000</span>);</span><br><span class="line">iPhone7.sell();</span><br></pre></td></tr></tbody></table></figure>

<ul>
<li><code>Object.create</code> 法 – 用 <code>Object.create()</code> 生成实例对象</li>
<li>缺点：不能实现私有属性和私有方法，实例对象之间也不能共享数据</li>
</ul>
<figure class="highlight js"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> Person = {</span><br><span class="line">    firstname: <span class="string">"Mark"</span>,</span><br><span class="line">    lastname: <span class="string">"Yun"</span>,</span><br><span class="line">    age: <span class="number">25</span>,</span><br><span class="line">    introduce: <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>{</span><br><span class="line">        alert(<span class="string">'I am '</span> + Person.firstname + <span class="string">' '</span> + Person.lastname);</span><br><span class="line">    }</span><br><span class="line">};</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> person = <span class="built_in">Object</span>.create(Person);</span><br><span class="line">person.introduce();</span><br><span class="line"></span><br><span class="line"><span class="comment">// Object.create 要求 IE9+，低版本浏览器可以自行部署：</span></span><br><span class="line"><span class="keyword">if</span> (!<span class="built_in">Object</span>.create) {</span><br><span class="line">　   <span class="built_in">Object</span>.create = <span class="function"><span class="keyword">function</span> (<span class="params">o</span>) </span>{</span><br><span class="line">　　　 <span class="function"><span class="keyword">function</span> <span class="title">F</span>(<span class="params"></span>) </span>{}</span><br><span class="line">　　　 F.prototype = o;</span><br><span class="line">　　　 <span class="keyword">return</span> <span class="keyword">new</span> F();</span><br><span class="line">　　};</span><br><span class="line">　}</span><br></pre></td></tr></tbody></table></figure>

<ul>
<li>极简主义法（消除<code>this</code>和 <code>prototype</code>） – 调用<code>createNew()</code> 得到实例对象<ul>
<li>优点：容易理解，结构清晰优雅，符合传统的”面向对象编程”的构造</li>
</ul>
</li>
</ul>
<figure class="highlight js"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> Cat = {</span><br><span class="line">  age: <span class="number">3</span>, <span class="comment">// 共享数据 -- 定义在类对象内，createNew() 外</span></span><br><span class="line">  createNew: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>{</span><br><span class="line">    <span class="keyword">var</span> cat = {};</span><br><span class="line">    <span class="comment">// var cat = Animal.createNew(); // 继承 Animal 类</span></span><br><span class="line">    cat.name = <span class="string">"小咪"</span>;</span><br><span class="line">    <span class="keyword">var</span> sound = <span class="string">"喵喵喵"</span>; <span class="comment">// 私有属性--定义在 createNew() 内，输出对象外</span></span><br><span class="line">    cat.makeSound = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>{</span><br><span class="line">      alert(sound);  <span class="comment">// 暴露私有属性</span></span><br><span class="line">    };</span><br><span class="line">    cat.changeAge = <span class="function"><span class="keyword">function</span>(<span class="params">num</span>)</span>{</span><br><span class="line">      Cat.age = num; <span class="comment">// 修改共享数据</span></span><br><span class="line">    };</span><br><span class="line">    <span class="keyword">return</span> cat; <span class="comment">// 输出对象</span></span><br><span class="line">  }</span><br><span class="line">};</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> cat = Cat.createNew();</span><br><span class="line">cat.makeSound();</span><br></pre></td></tr></tbody></table></figure>

<blockquote>
<p><code>ES6</code> 语法糖 <code>class</code> – 用 <code>new</code> 关键字 生成实例对象</p>
</blockquote>
<figure class="highlight js"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Point</span> </span>{</span><br><span class="line">  <span class="function"><span class="title">constructor</span>(<span class="params">x, y</span>)</span> {</span><br><span class="line">    <span class="built_in">this</span>.x = x;</span><br><span class="line">    <span class="built_in">this</span>.y = y;</span><br><span class="line">  }</span><br><span class="line">  <span class="function"><span class="title">toString</span>(<span class="params"></span>)</span> {</span><br><span class="line">    <span class="keyword">return</span> <span class="string">'('</span> + <span class="built_in">this</span>.x + <span class="string">', '</span> + <span class="built_in">this</span>.y + <span class="string">')'</span>;</span><br><span class="line">  }</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> point = <span class="keyword">new</span> Point(<span class="number">2</span>, <span class="number">3</span>);</span><br></pre></td></tr></tbody></table></figure>



<h3 id="“1”-“2”-“3”-map-parseInt"><a href="#“1”-“2”-“3”-map-parseInt" class="headerlink" title="[“1”, “2”, “3”].map(parseInt)"></a>[“1”, “2”, “3”].map(parseInt)</h3><ul>
<li><code>[1, NaN, NaN]</code>因为 <code>parseInt</code> 需要两个参数 <code>(val, radix)</code>，其中<code>radix</code> 表示解析时用的基数。</li>
<li><code>map</code>传了 <code>3</code>个<code>(element, index, array)</code>，对应的 <code>radix</code> 不合法导致解析失败。</li>
</ul>
<h3 id="说说严格模式的限制"><a href="#说说严格模式的限制" class="headerlink" title="说说严格模式的限制"></a>说说严格模式的限制</h3><ul>
<li>变量必须声明后再使用</li>
<li>函数的参数不能有同名属性，否则报错</li>
<li>不能使用with语句</li>
<li>不能对只读属性赋值，否则报错</li>
<li>不能使用前缀0表示八进制数，否则报错</li>
<li>不能删除不可删除的属性，否则报错</li>
<li>不能删除变量<code>delete prop</code>，会报错，只能删除属性<code>delete global[prop]</code></li>
<li><code>eval</code>不会在它的外层作用域引入变量</li>
<li><code>eval</code>和<code>arguments</code>不能被重新赋值</li>
<li><code>arguments</code>不会自动反映函数参数的变化</li>
<li>不能使用<code>arguments.callee</code></li>
<li>不能使用<code>arguments.caller</code></li>
<li>禁止<code>this</code>指向全局对象</li>
<li>不能使用<code>fn.caller</code>和<code>fn.arguments</code>获取函数调用的堆栈</li>
<li>增加了保留字（比如<code>protected</code>、<code>static</code>和<code>interface</code>）</li>
</ul>
<h3 id="“use-strict”-是什么意思"><a href="#“use-strict”-是什么意思" class="headerlink" title="“use strict”;是什么意思"></a>“use strict”;是什么意思</h3><ul>
<li><code>use strict</code>是一种<code>ECMAscript 5</code> 添加的（严格）运行模式,这种模式使得 Javascript 在更严格的条件下运行,使<code>JS</code>编码更加规范化的模式,消除<code>Javascript</code>语法的一些不合理、不严谨之处，减少一些怪异行为</li>
</ul>
<h3 id="JSON-的了解"><a href="#JSON-的了解" class="headerlink" title="JSON 的了解"></a>JSON 的了解</h3><ul>
<li><code>JSON(JavaScript Object Notation)</code> 是一种轻量级的数据交换格式</li>
<li>它是基于<code>JavaScript</code>的一个子集。数据格式简单, 易于读写, 占用带宽小</li>
<li><code>JSON</code>字符串转换为JSON对象:</li>
</ul>
<figure class="highlight javascript"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> obj =<span class="built_in">eval</span>(<span class="string">'('</span>+ str +<span class="string">')'</span>);</span><br><span class="line"><span class="keyword">var</span> obj = str.parseJSON();</span><br><span class="line"><span class="keyword">var</span> obj = <span class="built_in">JSON</span>.parse(str);</span><br></pre></td></tr></tbody></table></figure>

<ul>
<li><code>JSON</code>对象转换为JSON字符串：</li>
</ul>
<figure class="highlight text"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">var last=obj.toJSONString();</span><br><span class="line">var last=JSON.stringify(obj);</span><br></pre></td></tr></tbody></table></figure>

<h3 id="js延迟加载的方式有哪些"><a href="#js延迟加载的方式有哪些" class="headerlink" title="js延迟加载的方式有哪些"></a>js延迟加载的方式有哪些</h3><ul>
<li>设置<code>&lt;script&gt;</code>属性 <code>defer="defer"</code> （脚本将在页面完成解析时执行）</li>
<li>动态创建 <code>script DOM</code>：<code>document.createElement('script');</code></li>
<li><code>XmlHttpRequest</code> 脚本注入</li>
<li>延迟加载工具 <code>LazyLoad</code></li>
</ul>
<h3 id="同步和异步的区别"><a href="#同步和异步的区别" class="headerlink" title="同步和异步的区别"></a>同步和异步的区别</h3><ul>
<li>同步：浏览器访问服务器请求，用户看得到页面刷新，重新发请求,等请求完，页面刷新，新内容出现，用户看到新内容,进行下一步操作</li>
<li>异步：浏览器访问服务器请求，用户正常操作，浏览器后端进行请求。等请求完，页面不刷新，新内容也会出现，用户看到新内容</li>
</ul>
<h3 id="渐进增强和优雅降级"><a href="#渐进增强和优雅降级" class="headerlink" title="渐进增强和优雅降级"></a>渐进增强和优雅降级</h3><ul>
<li>渐进增强 ：针对低版本浏览器进行构建页面，保证最基本的功能，然后再针对高级浏览器进行效果、交互等改进和追加功能达到更好的用户体验。</li>
<li>优雅降级 ：一开始就构建完整的功能，然后再针对低版本浏览器进行兼容</li>
</ul>
<h3 id="attribute和property的区别是什么"><a href="#attribute和property的区别是什么" class="headerlink" title="attribute和property的区别是什么"></a>attribute和property的区别是什么</h3><ul>
<li><p><code>attribute</code>是<code>dom</code>元素在文档中作为<code>html</code>标签拥有的属性；</p>
</li>
<li><p><code>property</code>就是<code>dom</code>元素在<code>js</code>中作为对象拥有的属性。</p>
</li>
<li><p>对于<code>html</code>的标准属性来说，<code>attribute</code>和<code>property</code>是同步的，是会自动更新的</p>
</li>
<li><p>但是对于自定义的属性来说，他们是不同步的</p>
</li>
</ul>
<h3 id="面向对象编程及面向过程编程，它们的异同和优缺点"><a href="#面向对象编程及面向过程编程，它们的异同和优缺点" class="headerlink" title="面向对象编程及面向过程编程，它们的异同和优缺点"></a>面向对象编程及面向过程编程，它们的异同和优缺点</h3><ul>
<li>面向过程就是分析出解决问题所需要的步骤，然后用函数把这些步骤一步一步实现，使用的时候一个一个依次调用就可以了</li>
<li>面向对象是把构成问题事务分解成各个对象，建立对象的目的不是为了完成一个步骤，而是为了描叙某个事物在整个解决问题的步骤中的行为</li>
<li>面向对象是以功能来划分问题，而不是步骤</li>
</ul>
<h3 id="面向对象编程思想"><a href="#面向对象编程思想" class="headerlink" title="面向对象编程思想"></a>面向对象编程思想</h3><ul>
<li>基本思想是使用对象，类，继承，封装等基本概念来进行程序设计</li>
<li>优点<ul>
<li>易维护<ul>
<li>采用面向对象思想设计的结构，可读性高，由于继承的存在，即使改变需求，那么维护也只是在局部模块，所以维护起来是非常方便和较低成本的</li>
</ul>
</li>
<li>易扩展</li>
<li>开发工作的重用性、继承性高，降低重复工作量。</li>
<li>缩短了开发周期</li>
</ul>
</li>
</ul>
<h3 id="对web标准、可用性、可访问性的理解"><a href="#对web标准、可用性、可访问性的理解" class="headerlink" title="对web标准、可用性、可访问性的理解"></a>对web标准、可用性、可访问性的理解</h3><ul>
<li>可用性（Usability）：产品是否容易上手，用户能否完成任务，效率如何，以及这过程中用户的主观感受可好，是从用户的角度来看产品的质量。可用性好意味着产品质量高，是企业的核心竞争力</li>
<li>可访问性（Accessibility）：Web内容对于残障用户的可阅读和可理解性</li>
<li>可维护性（Maintainability）：一般包含两个层次，一是当系统出现问题时，快速定位并解决问题的成本，成本低则可维护性好。二是代码是否容易被人理解，是否容易修改和增强功能。</li>
</ul>
<h3 id="使用js实现一个持续的动画效果"><a href="#使用js实现一个持续的动画效果" class="headerlink" title="使用js实现一个持续的动画效果"></a>使用js实现一个持续的动画效果</h3><p><strong>定时器思路</strong></p>
<figure class="highlight js"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> e = <span class="built_in">document</span>.getElementById(<span class="string">'e'</span>)</span><br><span class="line"><span class="keyword">var</span> flag = <span class="literal">true</span>;</span><br><span class="line"><span class="keyword">var</span> left = <span class="number">0</span>;</span><br><span class="line"><span class="built_in">setInterval</span>(<span class="function">() =&gt;</span> {</span><br><span class="line">    left == <span class="number">0</span> ? flag = <span class="literal">true</span> : left == <span class="number">100</span> ? flag = <span class="literal">false</span> : <span class="string">''</span></span><br><span class="line">    flag ? e.style.left = <span class="string">` <span class="subst">${left++}</span>px`</span> : e.style.left = <span class="string">` <span class="subst">${left--}</span>px`</span></span><br><span class="line">}, <span class="number">1000</span> / <span class="number">60</span>)</span><br></pre></td></tr></tbody></table></figure>

<p><strong>requestAnimationFrame</strong></p>
<figure class="highlight js"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//兼容性处理</span></span><br><span class="line"><span class="built_in">window</span>.requestAnimFrame = (<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>{</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">window</span>.requestAnimationFrame       ||</span><br><span class="line">           <span class="built_in">window</span>.webkitRequestAnimationFrame ||</span><br><span class="line">           <span class="built_in">window</span>.mozRequestAnimationFrame    ||</span><br><span class="line">           <span class="function"><span class="keyword">function</span>(<span class="params">callback</span>)</span>{</span><br><span class="line">                <span class="built_in">window</span>.setTimeout(callback, <span class="number">1000</span> / <span class="number">60</span>);</span><br><span class="line">           };</span><br><span class="line">})();</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> e = <span class="built_in">document</span>.getElementById(<span class="string">"e"</span>);</span><br><span class="line"><span class="keyword">var</span> flag = <span class="literal">true</span>;</span><br><span class="line"><span class="keyword">var</span> left = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">render</span>(<span class="params"></span>) </span>{</span><br><span class="line">    left == <span class="number">0</span> ? flag = <span class="literal">true</span> : left == <span class="number">100</span> ? flag = <span class="literal">false</span> : <span class="string">''</span>;</span><br><span class="line">    flag ? e.style.left = <span class="string">` <span class="subst">${left++}</span>px`</span> :</span><br><span class="line">        e.style.left = <span class="string">` <span class="subst">${left--}</span>px`</span>;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">(<span class="function"><span class="keyword">function</span> <span class="title">animloop</span>(<span class="params"></span>) </span>{</span><br><span class="line">    render();</span><br><span class="line">    requestAnimFrame(animloop);</span><br><span class="line">})();</span><br></pre></td></tr></tbody></table></figure>

<p><strong>使用css实现一个持续的动画效果</strong></p>
<figure class="highlight css"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">animation</span>:mymove <span class="number">5s</span> infinite;</span><br><span class="line"></span><br><span class="line"><span class="keyword">@keyframes</span> mymove {</span><br><span class="line">    <span class="selector-tag">from</span> {<span class="attribute">top</span>:<span class="number">0px</span>;}</span><br><span class="line">    <span class="selector-tag">to</span> {<span class="attribute">top</span>:<span class="number">200px</span>;}</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<ul>
<li><code>animation-name</code> 规定需要绑定到选择器的 <code>keyframe</code>名称。</li>
<li><code>animation-duration</code> 规定完成动画所花费的时间，以秒或毫秒计。</li>
<li><code>animation-timing-function</code> 规定动画的速度曲线。</li>
<li><code>animation-delay</code> 规定在动画开始之前的延迟。</li>
<li><code>animation-iteration-count</code> 规定动画应该播放的次数。</li>
<li><code>animation-direction</code> 规定是否应该轮流反向播放动画</li>
</ul>
<h3 id="封装一个函数，参数是定时器的时间，-then执行回调函数"><a href="#封装一个函数，参数是定时器的时间，-then执行回调函数" class="headerlink" title="封装一个函数，参数是定时器的时间，.then执行回调函数"></a>封装一个函数，参数是定时器的时间，.then执行回调函数</h3><figure class="highlight js"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">sleep</span> (<span class="params">time</span>) </span>{</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve</span>) =&gt;</span> <span class="built_in">setTimeout</span>(resolve, time));</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>



<h3 id="项目做过哪些性能优化？"><a href="#项目做过哪些性能优化？" class="headerlink" title="项目做过哪些性能优化？"></a>项目做过哪些性能优化？</h3><ul>
<li>减少 <code>HTTP</code> 请求数</li>
<li>减少 <code>DNS</code> 查询</li>
<li>使用 <code>CDN</code></li>
<li>避免重定向</li>
<li>图片懒加载</li>
<li>减少 <code>DOM</code> 元素数量</li>
<li>减少<code>DOM</code> 操作</li>
<li>使用外部 <code>JavaScript</code> 和 <code>CSS</code></li>
<li>压缩 <code>JavaScript</code> 、 <code>CSS</code> 、字体、图片等</li>
<li>优化 <code>CSS Sprite</code></li>
<li>使用 <code>iconfont</code></li>
<li>字体裁剪</li>
<li>多域名分发划分内容到不同域名</li>
<li>尽量减少 <code>iframe</code> 使用</li>
<li>避免图片 <code>src</code> 为空</li>
<li>把样式表放在<code>link</code> 中</li>
<li>把<code>JavaScript</code>放在页面底部</li>
</ul>
<h3 id="尽可能多的说出你对-Electron-的理解"><a href="#尽可能多的说出你对-Electron-的理解" class="headerlink" title="尽可能多的说出你对 Electron 的理解"></a>尽可能多的说出你对 Electron 的理解</h3><blockquote>
<p>最最重要的一点，<code>electron</code> 实际上是一个套了 <code>Chrome</code> 的 <code>nodeJS</code>程序</p>
</blockquote>
<p><strong>所以应该是从两个方面说开来</strong></p>
<ul>
<li><code>Chrome</code> （无各种兼容性问题）；</li>
<li><code>NodeJS</code>（<code>NodeJS</code> 能做的它也能做）</li>
</ul>
<p> XML和JSON的区别？</p>
<ul>
<li>数据体积方面<ul>
<li><code>JSON</code>相对<code>于XML</code>来讲，数据的体积小，传递的速度更快些。</li>
</ul>
</li>
<li>数据交互方面<ul>
<li><code>JSON</code>与<code>JavaScript</code>的交互更加方便，更容易解析处理，更好的数据交互</li>
</ul>
</li>
<li>数据描述方面<ul>
<li><code>JSON</code>对数据的描述性比<code>XML</code>较差</li>
</ul>
</li>
<li>传输速度方面<ul>
<li><code>JSON</code>的速度要远远快于<code>XML</code></li>
</ul>
</li>
</ul>
<h3 id="说说你对AMD和Commonjs的理解"><a href="#说说你对AMD和Commonjs的理解" class="headerlink" title="说说你对AMD和Commonjs的理解"></a>说说你对AMD和Commonjs的理解</h3><ul>
<li><code>CommonJS</code>是服务器端模块的规范，<code>Node.js</code>采用了这个规范。<code>CommonJS</code>规范加载模块是同步的，也就是说，只有加载完成，才能执行后面的操作。<code>AMD</code>规范则是非同步加载模块，允许指定回调函数</li>
<li><code>AMD</code>推荐的风格通过返回一个对象做为模块对象，<code>CommonJS</code>的风格通过对<code>module.exports</code>或<code>exports</code>的属性赋值来达到暴露模块对象的目的</li>
</ul>
<h3 id="用过哪些设计模式？"><a href="#用过哪些设计模式？" class="headerlink" title="用过哪些设计模式？"></a>用过哪些设计模式？</h3><ul>
<li>工厂模式：<ul>
<li>工厂模式解决了重复实例化的问题，但还有一个问题,那就是识别问题，因为根本无法</li>
<li>主要好处就是可以消除对象间的耦合，通过使用工程方法而不是<code>new</code>关键字</li>
</ul>
</li>
<li>构造函数模式<ul>
<li>使用构造函数的方法，即解决了重复实例化的问题，又解决了对象识别的问题，该模式与工厂模式的不同之处在于</li>
<li>直接将属性和方法赋值给 <code>this</code>对象;</li>
</ul>
</li>
</ul>
<h3 id="offsetWidth-offsetHeight-clientWidth-clientHeight与scrollWidth-scrollHeight的区别"><a href="#offsetWidth-offsetHeight-clientWidth-clientHeight与scrollWidth-scrollHeight的区别" class="headerlink" title="offsetWidth/offsetHeight,clientWidth/clientHeight与scrollWidth/scrollHeight的区别"></a>offsetWidth/offsetHeight,clientWidth/clientHeight与scrollWidth/scrollHeight的区别</h3><ul>
<li><code>offsetWidth/offsetHeight</code>返回值包含<strong>content + padding + border</strong>，效果与e.getBoundingClientRect()相同</li>
<li><code>clientWidth/clientHeight</code>返回值只包含<strong>content + padding</strong>，如果有滚动条，也<strong>不包含滚动条</strong></li>
<li><code>scrollWidth/scrollHeight</code>返回值包含<strong>content + padding + 溢出内容的尺寸</strong></li>
</ul>
<h3 id="javascript有哪些方法定义对象"><a href="#javascript有哪些方法定义对象" class="headerlink" title="javascript有哪些方法定义对象"></a>javascript有哪些方法定义对象</h3><ul>
<li>对象字面量： <code>var obj = {};</code></li>
<li>构造函数： <code>var obj = new Object();</code></li>
<li>Object.create(): <code>var obj = Object.create(Object.prototype);</code></li>
</ul>
<h3 id="常见兼容性问题？"><a href="#常见兼容性问题？" class="headerlink" title="常见兼容性问题？"></a>常见兼容性问题？</h3><ul>
<li><code>png24</code>位的图片在iE6浏览器上出现背景，解决方案是做成<code>PNG8</code></li>
<li>浏览器默认的<code>margin</code>和<code>padding</code>不同。解决方案是加一个全局的<code>*{margin:0;padding:0;}</code>来统一,，但是全局效率很低，一般是如下这样解决：</li>
</ul>
<figure class="highlight css"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">body</span>,<span class="selector-tag">ul</span>,<span class="selector-tag">li</span>,<span class="selector-tag">ol</span>,<span class="selector-tag">dl</span>,<span class="selector-tag">dt</span>,<span class="selector-tag">dd</span>,<span class="selector-tag">form</span>,<span class="selector-tag">input</span>,<span class="selector-tag">h1</span>,<span class="selector-tag">h2</span>,<span class="selector-tag">h3</span>,<span class="selector-tag">h4</span>,<span class="selector-tag">h5</span>,<span class="selector-tag">h6</span>,<span class="selector-tag">p</span>{</span><br><span class="line">    <span class="attribute">margin</span>:<span class="number">0</span>;</span><br><span class="line">    <span class="attribute">padding</span>:<span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<ul>
<li><code>IE</code>下,<code>event</code>对象有<code>x</code>,<code>y</code>属性,但是没有<code>pageX</code>,<code>pageY</code>属性</li>
<li><code>Firefox</code>下,<code>event</code>对象有<code>pageX</code>,<code>pageY</code>属性,但是没有<code>x,y</code>属性.</li>
</ul>
<h3 id="你觉得jQuery源码有哪些写的好的地方"><a href="#你觉得jQuery源码有哪些写的好的地方" class="headerlink" title="你觉得jQuery源码有哪些写的好的地方"></a>你觉得jQuery源码有哪些写的好的地方</h3><ul>
<li><code>jquery</code>源码封装在一个匿名函数的自执行环境中，有助于防止变量的全局污染，然后通过传入<code>window</code>对象参数，可以使<code>window</code>对象作为局部变量使用，好处是当<code>jquery</code>中访问<code>window</code>对象的时候，就不用将作用域链退回到顶层作用域了，从而可以更快的访问window对象。同样，传入<code>undefined</code>参数，可以缩短查找<code>undefined</code>时的作用域链</li>
<li><code>jquery</code>将一些原型属性和方法封装在了<code>jquery.prototype</code>中，为了缩短名称，又赋值给了<code>jquery.fn</code>，这是很形象的写法</li>
<li>有一些数组或对象的方法经常能使用到，<code>jQuery</code>将其保存为局部变量以提高访问速度</li>
<li><code>jquery</code>实现的链式调用可以节约代码，所返回的都是同一个对象，可以提高代码效率</li>
</ul>
<h3 id="Node的应用场景"><a href="#Node的应用场景" class="headerlink" title="Node的应用场景"></a>Node的应用场景</h3><ul>
<li>特点：<ul>
<li>1、它是一个<code>Javascript</code>运行环境</li>
<li>2、依赖于<code>Chrome V8</code>引擎进行代码解释</li>
<li>3、事件驱动</li>
<li>4、非阻塞<code>I/O</code></li>
<li>5、单进程，单线程</li>
</ul>
</li>
<li>优点：<ul>
<li>高并发（最重要的优点）</li>
</ul>
</li>
<li>缺点：<ul>
<li>1、只支持单核<code>CPU</code>，不能充分利用<code>CPU</code></li>
<li>2、可靠性低，一旦代码某个环节崩溃，整个系统都崩溃</li>
</ul>
</li>
</ul>
<h3 id="谈谈你对AMD、CMD的理解"><a href="#谈谈你对AMD、CMD的理解" class="headerlink" title="谈谈你对AMD、CMD的理解"></a>谈谈你对AMD、CMD的理解</h3><ul>
<li><code>CommonJS</code>是服务器端模块的规范，<code>Node.js</code>采用了这个规范。<code>CommonJS</code>规范加载模块是同步的，也就是说，只有加载完成，才能执行后面的操作。<code>AMD</code>规范则是非同步加载模块，允许指定回调函数</li>
<li><code>AMD</code>推荐的风格通过返回一个对象做为模块对象，<code>CommonJS</code>的风格通过对<code>module.exports</code>或<code>exports</code>的属性赋值来达到暴露模块对象的目的</li>
</ul>
<p><strong>es6模块 CommonJS、AMD、CMD</strong></p>
<ul>
<li><code>CommonJS</code> 的规范中，每个 <code>JavaScript</code> 文件就是一个独立的模块上下文（<code>module context</code>），在这个上下文中默认创建的属性都是私有的。也就是说，在一个文件定义的变量（还包括函数和类），都是私有的，对其他文件是不可见的。</li>
<li><code>CommonJS</code>是同步加载模块,在浏览器中会出现堵塞情况，所以不适用</li>
<li><code>AMD</code> 异步，需要定义回调<code>define</code>方式</li>
<li><code>es6</code> 一个模块就是一个独立的文件，该文件内部的所有变量，外部无法获取。如果你希望外部能够读取模块内部的某个变量，就必须使用<code>export</code>关键字输出该变量 <code>es6</code>还可以导出类、方法，自动适用严格模式</li>
</ul>
<h3 id="web开发中会话跟踪的方法有哪些"><a href="#web开发中会话跟踪的方法有哪些" class="headerlink" title="web开发中会话跟踪的方法有哪些"></a>web开发中会话跟踪的方法有哪些</h3><ul>
<li><code>cookie</code></li>
<li><code>session</code></li>
<li><code>url</code>重写</li>
<li>隐藏<code>input</code></li>
<li><code>ip</code>地址</li>
</ul>
<h3 id="说几条写JavaScript的基本规范-1"><a href="#说几条写JavaScript的基本规范-1" class="headerlink" title="说几条写JavaScript的基本规范"></a>说几条写JavaScript的基本规范</h3><ul>
<li>不要在同一行声明多个变量</li>
<li>请使用<code>===/!==</code>来比较<code>true/false</code>或者数值</li>
<li>使用对象字面量替代<code>new Array</code>这种形式</li>
<li>不要使用全局函数</li>
<li><code>Switch</code>语句必须带有<code>default</code>分支</li>
<li><code>If</code>语句必须使用大括号</li>
<li><code>for-in</code>循环中的变量 应该使用<code>var</code>关键字明确限定作用域，从而避免作用域污</li>
</ul>
<h3 id="JS-创建对象的几种方式"><a href="#JS-创建对象的几种方式" class="headerlink" title="JS 创建对象的几种方式"></a>JS 创建对象的几种方式</h3><blockquote>
<p><code>javascript</code>创建对象简单的说,无非就是使用内置对象或各种自定义对象，当然还可以用<code>JSON</code>；但写法有很多种，也能混合使用</p>
</blockquote>
<ul>
<li>对象字面量的方式</li>
</ul>
<figure class="highlight javascript"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">person={<span class="attr">firstname</span>:<span class="string">"Mark"</span>,<span class="attr">lastname</span>:<span class="string">"Yun"</span>,<span class="attr">age</span>:<span class="number">25</span>,<span class="attr">eyecolor</span>:<span class="string">"black"</span>};</span><br></pre></td></tr></tbody></table></figure>

<ul>
<li>用<code>function</code>来模拟无参的构造函数</li>
</ul>
<figure class="highlight javascript"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params"></span>)</span>{}</span><br><span class="line">	<span class="keyword">var</span> person=<span class="keyword">new</span> Person();<span class="comment">//定义一个function，如果使用new"实例化",该function可以看作是一个Class</span></span><br><span class="line">        person.name=<span class="string">"Mark"</span>;</span><br><span class="line">        person.age=<span class="string">"25"</span>;</span><br><span class="line">        person.work=<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>{</span><br><span class="line">        alert(person.name+<span class="string">" hello..."</span>);</span><br><span class="line">}</span><br><span class="line">person.work();</span><br></pre></td></tr></tbody></table></figure>

<ul>
<li>用<code>function</code>来模拟参构造函数来实现（用<code>this</code>关键字定义构造的上下文属性）</li>
</ul>
<figure class="highlight javascript"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Pet</span>(<span class="params">name,age,hobby</span>)</span>{</span><br><span class="line">       <span class="built_in">this</span>.name=name;<span class="comment">//this作用域：当前对象</span></span><br><span class="line">       <span class="built_in">this</span>.age=age;</span><br><span class="line">       <span class="built_in">this</span>.hobby=hobby;</span><br><span class="line">       <span class="built_in">this</span>.eat=<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>{</span><br><span class="line">           alert(<span class="string">"我叫"</span>+<span class="built_in">this</span>.name+<span class="string">",我喜欢"</span>+<span class="built_in">this</span>.hobby+<span class="string">",是个程序员"</span>);</span><br><span class="line">       }</span><br><span class="line">}</span><br><span class="line"><span class="keyword">var</span> maidou =<span class="keyword">new</span> Pet(<span class="string">"麦兜"</span>,<span class="number">25</span>,<span class="string">"coding"</span>);<span class="comment">//实例化、创建对象</span></span><br><span class="line">maidou.eat();<span class="comment">//调用eat方法</span></span><br></pre></td></tr></tbody></table></figure>

<ul>
<li>用工厂方式来创建（内置对象）</li>
</ul>
<figure class="highlight javascript"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> wcDog =<span class="keyword">new</span> <span class="built_in">Object</span>();</span><br><span class="line">     wcDog.name=<span class="string">"旺财"</span>;</span><br><span class="line">     wcDog.age=<span class="number">3</span>;</span><br><span class="line">     wcDog.work=<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>{</span><br><span class="line">       alert(<span class="string">"我是"</span>+wcDog.name+<span class="string">",汪汪汪......"</span>);</span><br><span class="line">     }</span><br><span class="line">     wcDog.work();</span><br></pre></td></tr></tbody></table></figure>

<ul>
<li>用原型方式来创建</li>
</ul>
<figure class="highlight javascript"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Dog</span>(<span class="params"></span>)</span>{}</span><br><span class="line">Dog.prototype.name=<span class="string">"旺财"</span>;</span><br><span class="line">Dog.prototype.eat=<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>{</span><br><span class="line">	alert(<span class="built_in">this</span>.name+<span class="string">"是个吃货"</span>);</span><br><span class="line">}</span><br><span class="line"><span class="keyword">var</span> wangcai =<span class="keyword">new</span> Dog();</span><br><span class="line">wangcai.eat();</span><br></pre></td></tr></tbody></table></figure>

<ul>
<li>用混合方式来创建</li>
</ul>
<figure class="highlight javascript"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"> <span class="function"><span class="keyword">function</span> <span class="title">Car</span>(<span class="params">name,price</span>)</span>{</span><br><span class="line">	<span class="built_in">this</span>.name=name;</span><br><span class="line">	<span class="built_in">this</span>.price=price;</span><br><span class="line">}</span><br><span class="line">Car.prototype.sell=<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>{</span><br><span class="line">	alert(<span class="string">"我是"</span>+<span class="built_in">this</span>.name+<span class="string">"，我现在卖"</span>+<span class="built_in">this</span>.price+<span class="string">"万元"</span>);</span><br><span class="line">}</span><br><span class="line"><span class="keyword">var</span> camry =<span class="keyword">new</span> Car(<span class="string">"凯美瑞"</span>,<span class="number">27</span>);</span><br><span class="line">camry.sell();</span><br></pre></td></tr></tbody></table></figure>



<h3 id="eval是做什么的"><a href="#eval是做什么的" class="headerlink" title="eval是做什么的"></a>eval是做什么的</h3><ul>
<li>它的功能是把对应的字符串解析成<code>JS</code>代码并运行</li>
<li>应该避免使用<code>eval</code>，不安全，非常耗性能（<code>2</code>次，一次解析成<code>js</code>语句，一次执行）</li>
<li>由<code>JSON</code>字符串转换为JSON对象的时候可以用<code>eval，var obj =eval('('+ str +')')</code></li>
</ul>
<h2 id="未解决的题目"><a href="#未解决的题目" class="headerlink" title="未解决的题目"></a>未解决的题目</h2><h3 id="JS-数字前补“0”"><a href="#JS-数字前补“0”" class="headerlink" title="JS 数字前补“0”"></a>JS 数字前补“0”</h3> <figure class="highlight js"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//迭代方式实现</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">padding1</span> (<span class="params">num, length</span>) </span>{</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">var</span> len = (num + <span class="string">""</span>).length; len &lt; length; len = num.length) {</span><br><span class="line">        <span class="comment">// console.log(len)</span></span><br><span class="line">        num = <span class="string">"0"</span> + num;</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">return</span> num;</span><br><span class="line">}</span><br><span class="line"><span class="comment">//递归方式实现</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">padding2</span> (<span class="params">num, length</span>) </span>{</span><br><span class="line">    <span class="keyword">if</span> ((num + <span class="string">""</span>).length &gt;= length) {</span><br><span class="line">        <span class="keyword">return</span> num;</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">return</span> padding2(<span class="string">"0"</span> + num, length)</span><br><span class="line">}</span><br><span class="line"><span class="comment">//转为小数</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">padding3</span> (<span class="params">num, length</span>) </span>{</span><br><span class="line">    <span class="keyword">var</span> decimal = num / <span class="built_in">Math</span>.pow(<span class="number">10</span>, length);</span><br><span class="line">    <span class="comment">//toFixed指定保留几位小数</span></span><br><span class="line">    <span class="built_in">console</span>.log(decimal)</span><br><span class="line">    decimal = decimal.toFixed(length) + <span class="string">""</span>;</span><br><span class="line">    <span class="built_in">console</span>.log(decimal)</span><br><span class="line">    <span class="keyword">return</span> decimal.substr(decimal.indexOf(<span class="string">"."</span>) + <span class="number">1</span>);</span><br><span class="line">}</span><br><span class="line"><span class="comment">//填充截取法</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">padding4</span> (<span class="params">num, length</span>) </span>{</span><br><span class="line">    <span class="comment">//这里用slice和substr均可</span></span><br><span class="line">    <span class="comment">// console.log((Array(length).join("0") + num))</span></span><br><span class="line">    <span class="keyword">return</span> (<span class="built_in">Array</span>(length).join(<span class="string">"0"</span>) + num).slice(-length);</span><br><span class="line">}</span><br><span class="line"><span class="comment">//填充截取法</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">padding5</span> (<span class="params">num, length</span>) </span>{</span><br><span class="line">    <span class="keyword">var</span> len = (num + <span class="string">""</span>).length;</span><br><span class="line">    <span class="keyword">var</span> diff = length - len;</span><br><span class="line">    <span class="keyword">if</span> (diff &gt; <span class="number">0</span>) {</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">Array</span>(diff).join(<span class="string">"0"</span>) + num;</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">return</span> num;</span><br><span class="line">}</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">test</span> (<span class="params">num, length</span>) </span>{</span><br><span class="line">    <span class="built_in">document</span>.write(padding1(num, length));</span><br><span class="line">    <span class="built_in">document</span>.write(<span class="string">"&lt;br&gt;"</span>);</span><br><span class="line">    <span class="built_in">document</span>.write(padding2(num, length));</span><br><span class="line">    <span class="built_in">document</span>.write(<span class="string">"&lt;br&gt;"</span>);</span><br><span class="line">    <span class="built_in">document</span>.write(padding3(num, length));</span><br><span class="line">    <span class="built_in">document</span>.write(<span class="string">"&lt;br&gt;"</span>);</span><br><span class="line">    <span class="built_in">document</span>.write(padding4(num, length));</span><br><span class="line">    <span class="built_in">document</span>.write(<span class="string">"&lt;br&gt;"</span>);</span><br><span class="line">    <span class="built_in">document</span>.write(padding5(num, length));</span><br><span class="line">    <span class="built_in">document</span>.write(<span class="string">"&lt;br&gt;"</span>);</span><br><span class="line">}</span><br><span class="line">test(<span class="number">123</span>, <span class="number">10</span>);</span><br><span class="line">test(<span class="number">1234567890123</span>, <span class="number">10</span>);</span><br><span class="line"><span class="comment">// 0000000123</span></span><br><span class="line"><span class="comment">// 0000000123</span></span><br><span class="line"><span class="comment">// 0000000123</span></span><br><span class="line"><span class="comment">// 0000000123</span></span><br><span class="line"><span class="comment">// 000000123</span></span><br><span class="line"><span class="comment">// 1234567890123</span></span><br><span class="line"><span class="comment">// 1234567890123</span></span><br><span class="line"><span class="comment">// 4567890123</span></span><br><span class="line"><span class="comment">// 4567890123</span></span><br><span class="line"><span class="comment">// 1234567890123</span></span><br></pre></td></tr></tbody></table></figure>

<ul>
<li><p> <code>(num + "").length</code>可以确定当前数值的长度，根据此来填充 </p>
</li>
<li><p><code>return (Array(length).join("0") + num).slice(-length);</code></p>
</li>
<li><p>转为小数 较为复杂</p>
</li>
</ul>
<h3 id="ts对比js？"><a href="#ts对比js？" class="headerlink" title="ts对比js？"></a>ts对比js？</h3>
    </div>

    
    
    
      
  <div class="popular-posts-header">相关文章</div>
  <ul class="popular-posts">
    <li class="popular-posts-item">
      <div class="popular-posts-title"><a href="\2022\08\15\React\" rel="bookmark">React</a></div>
    </li>
    <li class="popular-posts-item">
      <div class="popular-posts-title"><a href="\2022\08\16\Webpack\" rel="bookmark">Webpack</a></div>
    </li>
    <li class="popular-posts-item">
      <div class="popular-posts-title"><a href="\2022\08\17\小程序\" rel="bookmark">小程序</a></div>
    </li>
    <li class="popular-posts-item">
      <div class="popular-posts-title"><a href="\2022\08\17\ES6\" rel="bookmark">ES6</a></div>
    </li>
    <li class="popular-posts-item">
      <div class="popular-posts-title"><a href="\2022\05\20\前端面试指南\" rel="bookmark">前端面试指南</a></div>
    </li>
  </ul>

        

<div>
<ul class="post-copyright">
  <li class="post-copyright-author">
    <strong>本文作者： </strong>henfy
  </li>
  <li class="post-copyright-link">
    <strong>本文链接：</strong>
    <a href="http://henfy233.github.io/2022/08/16/JS/" title="JS">http://henfy233.github.io/2022/08/16/JS/</a>
  </li>
  <li class="post-copyright-license">
    <strong>版权声明： </strong>本博客所有文章除特别声明外，均采用 <span class="exturl" data-url="aHR0cHM6Ly9jcmVhdGl2ZWNvbW1vbnMub3JnL2xpY2Vuc2VzL2J5LW5jLXNhLzQuMC96aF9DTg=="><i class="fab fa-fw fa-creative-commons"></i>BY-NC-SA</span> 许可协议。转载请注明出处！
  </li>
</ul>
</div>


      <footer class="post-footer">
          
          <div class="post-tags">
              <a href="/tags/%E9%9D%A2%E8%AF%95/" rel="tag"><i class="fa fa-tag"></i> 面试</a>
              <a href="/tags/%E5%89%8D%E7%AB%AF/" rel="tag"><i class="fa fa-tag"></i> 前端</a>
          </div>

        


        
    <div class="post-nav">
      <div class="post-nav-item">
    <a href="/2022/08/16/Webpack/" rel="prev" title="Webpack">
      <i class="fa fa-chevron-left"></i> Webpack
    </a></div>
      <div class="post-nav-item">
    <a href="/2022/08/17/%E5%B0%8F%E7%A8%8B%E5%BA%8F/" rel="next" title="小程序">
      小程序 <i class="fa fa-chevron-right"></i>
    </a></div>
    </div>
      </footer>
    
  </article>
  
  
  



          </div>
          
    <div class="comments" id="gitalk-container"></div>



        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">

    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
          <div class="post-toc motion-element"><ol class="nav"><li class="nav-item nav-level-2"><a class="nav-link" href="#JavaScript"><span class="nav-number">1.</span> <span class="nav-text">JavaScript</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E2%9D%A4-this%E6%8C%87%E5%90%91"><span class="nav-number">1.1.</span> <span class="nav-text">❤ this指向</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E2%9D%A4-This"><span class="nav-number">1.2.</span> <span class="nav-text">❤ This</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E2%9D%A4-call-apply-bind%E7%9A%84%E4%BD%9C%E7%94%A8%E5%92%8C%E5%8C%BA%E5%88%AB"><span class="nav-number">1.3.</span> <span class="nav-text">❤ call apply bind的作用和区别</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E2%9D%A4-%E5%8F%98%E9%87%8F%E6%8F%90%E5%8D%87"><span class="nav-number">1.4.</span> <span class="nav-text">❤ 变量提升</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E2%9D%A4-%E4%BD%9C%E7%94%A8%E5%9F%9F"><span class="nav-number">1.5.</span> <span class="nav-text">❤ 作用域</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#JS-%E4%BD%9C%E7%94%A8%E9%93%BE%E5%9F%9F"><span class="nav-number">1.6.</span> <span class="nav-text">JS 作用链域</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E2%9D%A4-%E9%97%AD%E5%8C%85"><span class="nav-number">1.7.</span> <span class="nav-text">❤ 闭包</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E2%9D%A4-New%E7%9A%84%E5%8E%9F%E7%90%86"><span class="nav-number">1.8.</span> <span class="nav-text">❤ New的原理</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E2%9D%A4-%E5%8E%9F%E5%9E%8B%EF%BC%8C%E5%8E%9F%E5%9E%8B%E9%93%BE"><span class="nav-number">1.9.</span> <span class="nav-text">❤ 原型，原型链</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E2%9D%A4-%E7%BB%A7%E6%89%BF"><span class="nav-number">1.10.</span> <span class="nav-text">❤ 继承</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B"><span class="nav-number">1.11.</span> <span class="nav-text">数据类型</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E4%BB%8B%E7%BB%8D-JS-%E6%9C%89%E5%93%AA%E4%BA%9B%E5%86%85%E7%BD%AE%E5%AF%B9%E8%B1%A1"><span class="nav-number">1.11.1.</span> <span class="nav-text">介绍 JS 有哪些内置对象</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#JS-%E6%9C%89%E5%87%A0%E7%A7%8D%E7%B1%BB%E5%9E%8B%EF%BC%8C%E7%94%BB%E4%B8%80%E4%B8%8B%E5%86%85%E5%AD%98%E5%9B%BE"><span class="nav-number">1.11.2.</span> <span class="nav-text">JS 有几种类型，画一下内存图</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E2%9D%A4-JS-%E5%9F%BA%E6%9C%AC%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B-%E5%BC%95%E7%94%A8%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B"><span class="nav-number">1.11.3.</span> <span class="nav-text">❤ JS 基本数据类型 引用数据类型</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E2%9D%A4-JS-%E5%88%A4%E6%96%AD%E5%8F%98%E9%87%8F%E7%9A%84%E7%B1%BB%E5%9E%8B"><span class="nav-number">1.12.</span> <span class="nav-text">❤ JS 判断变量的类型</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E2%9D%A4-JS-%E5%8D%95%E7%BA%BF%E7%A8%8B%E6%A8%A1%E5%9E%8B"><span class="nav-number">1.13.</span> <span class="nav-text">❤ JS 单线程模型</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%AF%B7%E8%A7%A3%E9%87%8A%E4%BB%80%E4%B9%88%E6%98%AF%E4%BA%8B%E4%BB%B6%E4%BB%A3%E7%90%86"><span class="nav-number">1.14.</span> <span class="nav-text">请解释什么是事件代理</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BA%8B%E4%BB%B6%E6%A8%A1%E5%9E%8B"><span class="nav-number">1.15.</span> <span class="nav-text">事件模型</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E2%9D%A4-%E6%95%B0%E7%BB%84%E5%92%8C%E6%95%B0%E7%BB%84%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="nav-number">1.16.</span> <span class="nav-text">❤ 数组和数组的区别</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E2%9D%A4-Ajax%E5%8E%9F%E7%90%86"><span class="nav-number">1.17.</span> <span class="nav-text">❤ Ajax原理</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%A8%A1%E5%9D%97%E5%8C%96%E5%BC%80%E5%8F%91%E6%80%8E%E4%B9%88%E5%81%9A%EF%BC%9F"><span class="nav-number">1.18.</span> <span class="nav-text">模块化开发怎么做？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%BC%82%E6%AD%A5%E5%8A%A0%E8%BD%BDJS%E7%9A%84%E6%96%B9%E5%BC%8F%E6%9C%89%E5%93%AA%E4%BA%9B%EF%BC%9F"><span class="nav-number">1.19.</span> <span class="nav-text">异步加载JS的方式有哪些？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E2%9D%A4-%E5%86%85%E5%AD%98%E6%B3%84%E9%9C%B2"><span class="nav-number">1.20.</span> <span class="nav-text">❤ 内存泄露</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#Chrome-devTools-%E6%9F%A5%E7%9C%8B%E5%86%85%E5%AD%98%E6%83%85%E5%86%B5"><span class="nav-number">1.20.1.</span> <span class="nav-text">Chrome devTools 查看内存情况</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%86%85%E5%AD%98%E6%B3%84%E6%BC%8F%E7%9A%84%E5%9C%BA%E6%99%AF"><span class="nav-number">1.20.2.</span> <span class="nav-text">内存泄漏的场景</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#JS-%E5%86%85%E5%AD%98%E6%B3%84%E6%BC%8F-%E6%95%B4%E5%90%88"><span class="nav-number">1.20.3.</span> <span class="nav-text">JS 内存泄漏 整合</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E2%9D%A4-null%EF%BC%8Cundefined-%E7%9A%84%E5%8C%BA%E5%88%AB%EF%BC%8C%E5%A6%82%E4%BD%95%E8%AE%A9%E4%B8%80%E4%B8%AA%E5%B1%9E%E6%80%A7%E5%8F%98%E4%B8%BAnull"><span class="nav-number">1.21.</span> <span class="nav-text">❤ null，undefined 的区别，如何让一个属性变为null</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#let-%E4%B8%8E-var%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="nav-number">1.22.</span> <span class="nav-text">let 与 var的区别</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#let-var-const"><span class="nav-number">1.23.</span> <span class="nav-text">let var const</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E2%9D%A4-map-%E4%B8%8E-forEach%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="nav-number">1.24.</span> <span class="nav-text">❤ map 与 forEach的区别</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%B0%88%E4%B8%80%E8%B0%88%E4%BD%A0%E7%90%86%E8%A7%A3%E7%9A%84%E5%87%BD%E6%95%B0%E5%BC%8F%E7%BC%96%E7%A8%8B"><span class="nav-number">1.25.</span> <span class="nav-text">谈一谈你理解的函数式编程</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E2%9D%A4-JS-%E5%AE%9E%E7%8E%B0%E5%BC%82%E6%AD%A5%E7%BC%96%E7%A8%8B%E7%9A%84%E6%96%B9%E6%B3%95"><span class="nav-number">1.26.</span> <span class="nav-text">❤ JS 实现异步编程的方法</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E2%9D%A4-%E6%95%B0%E7%BB%84%E5%8E%BB%E9%87%8D%E6%96%B9%E6%B3%95%E6%80%BB%E7%BB%93"><span class="nav-number">1.27.</span> <span class="nav-text">❤ 数组去重方法总结</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%EF%BC%88%E8%AE%BE%E8%AE%A1%E9%A2%98%EF%BC%89%E6%83%B3%E5%AE%9E%E7%8E%B0%E4%B8%80%E4%B8%AA%E5%AF%B9%E9%A1%B5%E9%9D%A2%E6%9F%90%E4%B8%AA%E8%8A%82%E7%82%B9%E7%9A%84%E6%8B%96%E6%9B%B3%EF%BC%9F%E5%A6%82%E4%BD%95%E5%81%9A%EF%BC%9F%EF%BC%88%E4%BD%BF%E7%94%A8%E5%8E%9F%E7%94%9FJS%EF%BC%89"><span class="nav-number">1.28.</span> <span class="nav-text">（设计题）想实现一个对页面某个节点的拖曳？如何做？（使用原生JS）</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E2%9D%A4-JS-%E5%85%A8%E5%B1%80%E5%87%BD%E6%95%B0%E5%92%8C%E5%85%A8%E5%B1%80%E5%8F%98%E9%87%8F"><span class="nav-number">1.29.</span> <span class="nav-text">❤ JS 全局函数和全局变量</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E2%9D%A4-%E6%B7%B1%E6%B5%85%E6%8B%B7%E8%B4%9D"><span class="nav-number">1.30.</span> <span class="nav-text">❤ 深浅拷贝</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%B5%85%E6%8B%B7%E8%B4%9D"><span class="nav-number">1.30.1.</span> <span class="nav-text">浅拷贝</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%B7%B1%E6%8B%B7%E8%B4%9D"><span class="nav-number">1.30.2.</span> <span class="nav-text">深拷贝</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E2%9D%A4-%E9%98%B2%E6%8A%96-%E8%8A%82%E6%B5%81"><span class="nav-number">1.31.</span> <span class="nav-text">❤ 防抖/节流</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E9%98%B2%E6%8A%96"><span class="nav-number">1.31.1.</span> <span class="nav-text">防抖</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E8%8A%82%E6%B5%81"><span class="nav-number">1.31.2.</span> <span class="nav-text">节流</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E2%9D%A4-%E4%BA%8B%E4%BB%B6%E5%BE%AA%E7%8E%AFEvent-loop%EF%BC%8C%E5%AE%8F%E4%BB%BB%E5%8A%A1%E4%B8%8E%E5%BE%AE%E4%BB%BB%E5%8A%A1"><span class="nav-number">1.32.</span> <span class="nav-text">❤ 事件循环Event loop，宏任务与微任务</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%AF%B4%E8%AF%B4%E4%BA%8B%E4%BB%B6%E6%B5%81"><span class="nav-number">1.33.</span> <span class="nav-text">说说事件流</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%AF%B4%E8%AF%B4%E4%BB%8E%E8%BE%93%E5%85%A5URL%E5%88%B0%E7%9C%8B%E5%88%B0%E9%A1%B5%E9%9D%A2%E5%8F%91%E7%94%9F%E7%9A%84%E5%85%A8%E8%BF%87%E7%A8%8B%EF%BC%8C%E8%B6%8A%E8%AF%A6%E7%BB%86%E8%B6%8A%E5%A5%BD"><span class="nav-number">1.34.</span> <span class="nav-text">说说从输入URL到看到页面发生的全过程，越详细越好</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%8E%B0%E5%9C%A8%E8%A6%81%E4%BD%A0%E5%AE%8C%E6%88%90%E4%B8%80%E4%B8%AADialog%E7%BB%84%E4%BB%B6%EF%BC%8C%E8%AF%B4%E8%AF%B4%E4%BD%A0%E8%AE%BE%E8%AE%A1%E7%9A%84%E6%80%9D%E8%B7%AF%EF%BC%9F%E5%AE%83%E5%BA%94%E8%AF%A5%E6%9C%89%E4%BB%80%E4%B9%88%E5%8A%9F%E8%83%BD%EF%BC%9F"><span class="nav-number">1.35.</span> <span class="nav-text">现在要你完成一个Dialog组件，说说你设计的思路？它应该有什么功能？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#caller%E5%92%8Ccallee%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="nav-number">1.36.</span> <span class="nav-text">caller和callee的区别</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#ajax%E3%80%81axios%E3%80%81fetch%E5%8C%BA%E5%88%AB"><span class="nav-number">1.37.</span> <span class="nav-text">ajax、axios、fetch区别</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E2%9D%A4-axios-%E7%9A%84%E6%8B%A6%E6%88%AA%E5%99%A8%E5%8E%9F%E7%90%86%E5%8F%8A%E5%BA%94%E7%94%A8"><span class="nav-number">1.37.1.</span> <span class="nav-text">❤ axios 的拦截器原理及应用</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E2%9D%A4-fetch-%E8%AF%B7%E6%B1%82%E6%96%B9%E5%BC%8F"><span class="nav-number">1.37.2.</span> <span class="nav-text">❤ fetch 请求方式</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E2%9D%A4-JS-%E7%BB%A7%E6%89%BF%E7%9A%84%E6%96%B9%E6%B3%95%E5%92%8C%E4%BC%98%E7%BC%BA%E7%82%B9%EF%BC%9F"><span class="nav-number">1.38.</span> <span class="nav-text">❤ JS 继承的方法和优缺点？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%95%B0%E7%BB%84%E7%9B%B8%E5%85%B3%EF%BC%9A"><span class="nav-number">1.39.</span> <span class="nav-text">数组相关：</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E2%9D%A4-JS-%E6%95%B0%E7%BB%84%E5%B8%B8%E7%94%A8%E6%96%B9%E6%B3%95"><span class="nav-number">1.39.1.</span> <span class="nav-text">❤ JS 数组常用方法</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%88%97%E4%B8%BE-JS-%E6%95%B0%E7%BB%84%E5%92%8C%E5%AF%B9%E8%B1%A1%E6%9C%89%E5%93%AA%E4%BA%9B%E5%8E%9F%E7%94%9F%E6%96%B9%E6%B3%95%EF%BC%9F"><span class="nav-number">1.39.2.</span> <span class="nav-text">列举 JS 数组和对象有哪些原生方法？</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E2%9D%A4-%E5%88%A4%E6%96%AD%E6%95%B0%E7%BB%84%E7%9A%84%E6%96%B9%E6%B3%95"><span class="nav-number">1.39.3.</span> <span class="nav-text">❤ 判断数组的方法</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#slice-%E4%B8%8E-splice-%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="nav-number">1.39.4.</span> <span class="nav-text">slice() 与 splice() 的区别</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%88%A0%E9%99%A4%E6%8C%87%E5%AE%9A-index-%E7%9A%84%E6%95%B0%E7%BB%84%E5%85%83%E7%B4%A0"><span class="nav-number">1.39.5.</span> <span class="nav-text">删除指定 index 的数组元素</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%88%A4%E6%96%AD%E6%95%B0%E7%BB%84%E4%B8%AD%E6%98%AF%E5%90%A6%E5%8C%85%E5%90%AB%E6%9F%90%E4%B8%AA%E5%80%BC"><span class="nav-number">1.39.6.</span> <span class="nav-text">判断数组中是否包含某个值</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#MVVM"><span class="nav-number">1.40.</span> <span class="nav-text">MVVM</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%BB%A7%E6%89%BF"><span class="nav-number">1.41.</span> <span class="nav-text">继承</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%8A%A0%E8%BD%BD"><span class="nav-number">1.42.</span> <span class="nav-text">加载</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%9C%89%E5%9B%9B%E4%B8%AA%E6%93%8D%E4%BD%9C%E4%BC%9A%E5%BF%BD%E7%95%A5enumerable%E4%B8%BAfalse%E7%9A%84%E5%B1%9E%E6%80%A7"><span class="nav-number">1.43.</span> <span class="nav-text">有四个操作会忽略enumerable为false的属性</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%B1%9E%E6%80%A7%E7%9A%84%E9%81%8D%E5%8E%86"><span class="nav-number">1.44.</span> <span class="nav-text">属性的遍历</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%B8%BA%E4%BB%80%E4%B9%88%E9%80%9A%E5%B8%B8%E5%9C%A8%E5%8F%91%E9%80%81%E6%95%B0%E6%8D%AE%E5%9F%8B%E7%82%B9%E8%AF%B7%E6%B1%82%E7%9A%84%E6%97%B6%E5%80%99%E4%BD%BF%E7%94%A8%E7%9A%84%E6%98%AF-1x1-%E5%83%8F%E7%B4%A0%E7%9A%84%E9%80%8F%E6%98%8E-gif-%E5%9B%BE%E7%89%87"><span class="nav-number">1.45.</span> <span class="nav-text">为什么通常在发送数据埋点请求的时候使用的是 1x1 像素的透明 gif 图片</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%AF%B9%E5%8E%9F%E7%94%9FJavascript%E4%BA%86%E8%A7%A3%E7%A8%8B%E5%BA%A6"><span class="nav-number">1.46.</span> <span class="nav-text">对原生Javascript了解程度</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Js%E5%8A%A8%E7%94%BB%E4%B8%8ECSS%E5%8A%A8%E7%94%BB%E5%8C%BA%E5%88%AB%E5%8F%8A%E7%9B%B8%E5%BA%94%E5%AE%9E%E7%8E%B0"><span class="nav-number">1.47.</span> <span class="nav-text">Js动画与CSS动画区别及相应实现</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#JS-%E6%95%B0%E7%BB%84%E5%92%8C%E5%AF%B9%E8%B1%A1%E7%9A%84%E9%81%8D%E5%8E%86%E6%96%B9%E5%BC%8F%EF%BC%8C%E4%BB%A5%E5%8F%8A%E5%87%A0%E7%A7%8D%E6%96%B9%E5%BC%8F%E7%9A%84%E6%AF%94%E8%BE%83"><span class="nav-number">1.48.</span> <span class="nav-text">JS 数组和对象的遍历方式，以及几种方式的比较</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BA%8B%E4%BB%B6%E7%9A%84%E5%90%84%E4%B8%AA%E9%98%B6%E6%AE%B5"><span class="nav-number">1.49.</span> <span class="nav-text">事件的各个阶段</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%A6%82%E4%BD%95%E6%B8%B2%E6%9F%93%E5%87%A0%E4%B8%87%E6%9D%A1%E6%95%B0%E6%8D%AE%E5%B9%B6%E4%B8%8D%E5%8D%A1%E4%BD%8F%E7%95%8C%E9%9D%A2"><span class="nav-number">1.50.</span> <span class="nav-text">如何渲染几万条数据并不卡住界面</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%B8%8C%E6%9C%9B%E8%8E%B7%E5%8F%96%E5%88%B0%E9%A1%B5%E9%9D%A2%E4%B8%AD%E6%89%80%E6%9C%89%E7%9A%84checkbox%E6%80%8E%E4%B9%88%E5%81%9A%EF%BC%9F"><span class="nav-number">1.51.</span> <span class="nav-text">希望获取到页面中所有的checkbox怎么做？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#JS-%E6%B7%BB%E5%8A%A0%E3%80%81%E7%A7%BB%E9%99%A4%E3%80%81%E7%A7%BB%E5%8A%A8%E3%80%81%E5%A4%8D%E5%88%B6%E3%80%81%E5%88%9B%E5%BB%BA%E5%92%8C%E6%9F%A5%E6%89%BE%E8%8A%82%E7%82%B9"><span class="nav-number">1.52.</span> <span class="nav-text">JS 添加、移除、移动、复制、创建和查找节点</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F"><span class="nav-number">1.53.</span> <span class="nav-text">正则表达式</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#JS-%E4%B8%AD-callee-%E5%92%8C-caller-%E7%9A%84%E4%BD%9C%E7%94%A8%EF%BC%9F"><span class="nav-number">1.54.</span> <span class="nav-text">JS 中 callee 和 caller 的作用？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#window-onload%E5%92%8C-document-ready"><span class="nav-number">1.55.</span> <span class="nav-text">window.onload和$(document).ready</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#addEventListener-%E5%92%8CattachEvent-%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="nav-number">1.56.</span> <span class="nav-text">addEventListener()和attachEvent()的区别</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%8E%B7%E5%8F%96%E9%A1%B5%E9%9D%A2%E6%89%80%E6%9C%89%E7%9A%84checkbox"><span class="nav-number">1.57.</span> <span class="nav-text">获取页面所有的checkbox</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#JavaScript-%E5%AF%B9%E8%B1%A1%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F%E7%9A%84%E7%90%86%E8%A7%A3"><span class="nav-number">1.58.</span> <span class="nav-text">JavaScript 对象生命周期的理解</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%88%91%E7%8E%B0%E5%9C%A8%E6%9C%89%E4%B8%80%E4%B8%AAcanvas%EF%BC%8C%E4%B8%8A%E9%9D%A2%E9%9A%8F%E6%9C%BA%E5%B8%83%E7%9D%80%E4%B8%80%E4%BA%9B%E9%BB%91%E5%9D%97%EF%BC%8C%E8%AF%B7%E5%AE%9E%E7%8E%B0%E6%96%B9%E6%B3%95%EF%BC%8C%E8%AE%A1%E7%AE%97canvas%E4%B8%8A%E6%9C%89%E5%A4%9A%E5%B0%91%E4%B8%AA%E9%BB%91%E5%9D%97"><span class="nav-number">1.59.</span> <span class="nav-text">我现在有一个canvas，上面随机布着一些黑块，请实现方法，计算canvas上有多少个黑块</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BB%8B%E7%BB%8D-DOM-%E7%9A%84%E5%8F%91%E5%B1%95"><span class="nav-number">1.60.</span> <span class="nav-text">介绍 DOM 的发展</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BB%8B%E7%BB%8DDOM0%EF%BC%8CDOM2%EF%BC%8CDOM3%E4%BA%8B%E4%BB%B6%E5%A4%84%E7%90%86%E6%96%B9%E5%BC%8F%E5%8C%BA%E5%88%AB"><span class="nav-number">1.61.</span> <span class="nav-text">介绍DOM0，DOM2，DOM3事件处理方式区别</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BB%8B%E7%BB%8D%E4%BA%8B%E4%BB%B6%E2%80%9C%E6%8D%95%E8%8E%B7%E2%80%9D%E5%92%8C%E2%80%9C%E5%86%92%E6%B3%A1%E2%80%9D%E6%89%A7%E8%A1%8C%E9%A1%BA%E5%BA%8F%E5%92%8C%E4%BA%8B%E4%BB%B6%E7%9A%84%E6%89%A7%E8%A1%8C%E6%AC%A1%E6%95%B0"><span class="nav-number">1.62.</span> <span class="nav-text">介绍事件“捕获”和“冒泡”执行顺序和事件的执行次数</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%8C%BA%E5%88%86%E2%80%9C%E5%AE%A2%E6%88%B7%E5%8C%BA%E5%9D%90%E6%A0%87%E2%80%9D%E3%80%81%E2%80%9C%E9%A1%B5%E9%9D%A2%E5%9D%90%E6%A0%87%E2%80%9D%E3%80%81%E2%80%9C%E5%B1%8F%E5%B9%95%E5%9D%90%E6%A0%87%E2%80%9D"><span class="nav-number">1.63.</span> <span class="nav-text">区分“客户区坐标”、“页面坐标”、“屏幕坐标”</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%A7%A3%E9%87%8A%E4%B8%80%E4%B8%8B%E8%BF%99%E6%AE%B5%E4%BB%A3%E7%A0%81%E7%9A%84%E6%84%8F%E6%80%9D"><span class="nav-number">1.64.</span> <span class="nav-text">解释一下这段代码的意思</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%AF%B7%E8%A7%A3%E9%87%8A%E4%B8%80%E4%B8%8B-JS-%E7%9A%84%E5%90%8C%E6%BA%90%E7%AD%96%E7%95%A5"><span class="nav-number">1.65.</span> <span class="nav-text">请解释一下 JS 的同源策略</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%A6%82%E4%BD%95%E5%88%A0%E9%99%A4%E4%B8%80%E4%B8%AAcookie"><span class="nav-number">1.66.</span> <span class="nav-text">如何删除一个cookie</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E9%A1%B5%E9%9D%A2%E7%BC%96%E7%A0%81%E5%92%8C%E8%A2%AB%E8%AF%B7%E6%B1%82%E7%9A%84%E8%B5%84%E6%BA%90%E7%BC%96%E7%A0%81%E5%A6%82%E6%9E%9C%E4%B8%8D%E4%B8%80%E8%87%B4%E5%A6%82%E4%BD%95%E5%A4%84%E7%90%86"><span class="nav-number">1.67.</span> <span class="nav-text">页面编码和被请求的资源编码如果不一致如何处理</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%8A%8A-lt-script-gt-%E6%94%BE%E5%9C%A8-lt-body-gt-%E4%B9%8B%E5%89%8D%E5%92%8C%E4%B9%8B%E5%90%8E%E6%9C%89%E4%BB%80%E4%B9%88%E5%8C%BA%E5%88%AB%EF%BC%9F%E6%B5%8F%E8%A7%88%E5%99%A8%E4%BC%9A%E5%A6%82%E4%BD%95%E8%A7%A3%E6%9E%90%E5%AE%83%E4%BB%AC%EF%BC%9F"><span class="nav-number">1.68.</span> <span class="nav-text">把&lt;script&gt;放在&lt;/body&gt;之前和之后有什么区别？浏览器会如何解析它们？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#JS-%E4%B8%AD%EF%BC%8C%E8%B0%83%E7%94%A8%E5%87%BD%E6%95%B0%E6%9C%89%E5%93%AA%E5%87%A0%E7%A7%8D%E6%96%B9%E5%BC%8F"><span class="nav-number">1.69.</span> <span class="nav-text">JS 中，调用函数有哪几种方式</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%AE%80%E5%8D%95%E5%AE%9E%E7%8E%B0-Function-bind-%E5%87%BD%E6%95%B0"><span class="nav-number">1.70.</span> <span class="nav-text">简单实现 Function.bind 函数</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BB%80%E4%B9%88%E6%98%AF%E5%8D%95%E7%BA%BF%E7%A8%8B%EF%BC%8C%E5%92%8C%E5%BC%82%E6%AD%A5%E7%9A%84%E5%85%B3%E7%B3%BB"><span class="nav-number">1.71.</span> <span class="nav-text">什么是单线程，和异步的关系</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%98%AF%E5%90%A6%E7%94%A8%E8%BF%87-jQuery-%E7%9A%84-Deferred"><span class="nav-number">1.72.</span> <span class="nav-text">是否用过 jQuery 的 Deferred</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E4%B9%8Bhybrid"><span class="nav-number">1.73.</span> <span class="nav-text">前端面试之hybrid</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E4%B9%8B%E7%BB%84%E4%BB%B6%E5%8C%96"><span class="nav-number">1.74.</span> <span class="nav-text">前端面试之组件化</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E4%B9%8BMVVM%E6%B5%85%E6%9E%90"><span class="nav-number">1.75.</span> <span class="nav-text">前端面试之MVVM浅析</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%AE%9E%E7%8E%B0%E6%95%88%E6%9E%9C%EF%BC%8C%E7%82%B9%E5%87%BB%E5%AE%B9%E5%99%A8%E5%86%85%E7%9A%84%E5%9B%BE%E6%A0%87%EF%BC%8C%E5%9B%BE%E6%A0%87%E8%BE%B9%E6%A1%86%E5%8F%98%E6%88%90border-1px-solid-red%EF%BC%8C%E7%82%B9%E5%87%BB%E7%A9%BA%E7%99%BD%E5%A4%84%E9%87%8D%E7%BD%AE"><span class="nav-number">1.76.</span> <span class="nav-text">实现效果，点击容器内的图标，图标边框变成border 1px solid red，点击空白处重置</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#JavaScript%E7%9A%84%E7%BB%84%E6%88%90"><span class="nav-number">1.77.</span> <span class="nav-text">JavaScript的组成</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%AF%B4%E5%87%A0%E6%9D%A1%E5%86%99JavaScript%E7%9A%84%E5%9F%BA%E6%9C%AC%E8%A7%84%E8%8C%83"><span class="nav-number">1.78.</span> <span class="nav-text">说几条写JavaScript的基本规范</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%A6%82%E4%BD%95%E7%BC%96%E5%86%99%E9%AB%98%E6%80%A7%E8%83%BD%E7%9A%84JavaScript"><span class="nav-number">1.79.</span> <span class="nav-text">如何编写高性能的JavaScript</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#script-%E7%9A%84%E4%BD%8D%E7%BD%AE%E6%98%AF%E5%90%A6%E4%BC%9A%E5%BD%B1%E5%93%8D%E9%A6%96%E5%B1%8F%E6%98%BE%E7%A4%BA%E6%97%B6%E9%97%B4"><span class="nav-number">1.80.</span> <span class="nav-text">script 的位置是否会影响首屏显示时间</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%A7%A3%E9%87%8A-JS-%E4%B8%AD%E7%9A%84%E4%BD%9C%E7%94%A8%E5%9F%9F%E4%B8%8E%E5%8F%98%E9%87%8F%E5%A3%B0%E6%98%8E%E6%8F%90%E5%8D%87"><span class="nav-number">1.81.</span> <span class="nav-text">解释 JS 中的作用域与变量声明提升</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#JS-%E5%AE%9E%E7%8E%B0%E4%B8%80%E4%B8%AA%E7%B1%BB%EF%BC%8C%E5%AE%9E%E4%BE%8B%E5%8C%96%E8%BF%99%E4%B8%AA%E7%B1%BB"><span class="nav-number">1.82.</span> <span class="nav-text">JS 实现一个类，实例化这个类</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E2%80%9C1%E2%80%9D-%E2%80%9C2%E2%80%9D-%E2%80%9C3%E2%80%9D-map-parseInt"><span class="nav-number">1.83.</span> <span class="nav-text">[“1”, “2”, “3”].map(parseInt)</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%AF%B4%E8%AF%B4%E4%B8%A5%E6%A0%BC%E6%A8%A1%E5%BC%8F%E7%9A%84%E9%99%90%E5%88%B6"><span class="nav-number">1.84.</span> <span class="nav-text">说说严格模式的限制</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E2%80%9Cuse-strict%E2%80%9D-%E6%98%AF%E4%BB%80%E4%B9%88%E6%84%8F%E6%80%9D"><span class="nav-number">1.85.</span> <span class="nav-text">“use strict”;是什么意思</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#JSON-%E7%9A%84%E4%BA%86%E8%A7%A3"><span class="nav-number">1.86.</span> <span class="nav-text">JSON 的了解</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#js%E5%BB%B6%E8%BF%9F%E5%8A%A0%E8%BD%BD%E7%9A%84%E6%96%B9%E5%BC%8F%E6%9C%89%E5%93%AA%E4%BA%9B"><span class="nav-number">1.87.</span> <span class="nav-text">js延迟加载的方式有哪些</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%90%8C%E6%AD%A5%E5%92%8C%E5%BC%82%E6%AD%A5%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="nav-number">1.88.</span> <span class="nav-text">同步和异步的区别</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%B8%90%E8%BF%9B%E5%A2%9E%E5%BC%BA%E5%92%8C%E4%BC%98%E9%9B%85%E9%99%8D%E7%BA%A7"><span class="nav-number">1.89.</span> <span class="nav-text">渐进增强和优雅降级</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#attribute%E5%92%8Cproperty%E7%9A%84%E5%8C%BA%E5%88%AB%E6%98%AF%E4%BB%80%E4%B9%88"><span class="nav-number">1.90.</span> <span class="nav-text">attribute和property的区别是什么</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%BC%96%E7%A8%8B%E5%8F%8A%E9%9D%A2%E5%90%91%E8%BF%87%E7%A8%8B%E7%BC%96%E7%A8%8B%EF%BC%8C%E5%AE%83%E4%BB%AC%E7%9A%84%E5%BC%82%E5%90%8C%E5%92%8C%E4%BC%98%E7%BC%BA%E7%82%B9"><span class="nav-number">1.91.</span> <span class="nav-text">面向对象编程及面向过程编程，它们的异同和优缺点</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%BC%96%E7%A8%8B%E6%80%9D%E6%83%B3"><span class="nav-number">1.92.</span> <span class="nav-text">面向对象编程思想</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%AF%B9web%E6%A0%87%E5%87%86%E3%80%81%E5%8F%AF%E7%94%A8%E6%80%A7%E3%80%81%E5%8F%AF%E8%AE%BF%E9%97%AE%E6%80%A7%E7%9A%84%E7%90%86%E8%A7%A3"><span class="nav-number">1.93.</span> <span class="nav-text">对web标准、可用性、可访问性的理解</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BD%BF%E7%94%A8js%E5%AE%9E%E7%8E%B0%E4%B8%80%E4%B8%AA%E6%8C%81%E7%BB%AD%E7%9A%84%E5%8A%A8%E7%94%BB%E6%95%88%E6%9E%9C"><span class="nav-number">1.94.</span> <span class="nav-text">使用js实现一个持续的动画效果</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%B0%81%E8%A3%85%E4%B8%80%E4%B8%AA%E5%87%BD%E6%95%B0%EF%BC%8C%E5%8F%82%E6%95%B0%E6%98%AF%E5%AE%9A%E6%97%B6%E5%99%A8%E7%9A%84%E6%97%B6%E9%97%B4%EF%BC%8C-then%E6%89%A7%E8%A1%8C%E5%9B%9E%E8%B0%83%E5%87%BD%E6%95%B0"><span class="nav-number">1.95.</span> <span class="nav-text">封装一个函数，参数是定时器的时间，.then执行回调函数</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E9%A1%B9%E7%9B%AE%E5%81%9A%E8%BF%87%E5%93%AA%E4%BA%9B%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96%EF%BC%9F"><span class="nav-number">1.96.</span> <span class="nav-text">项目做过哪些性能优化？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%B0%BD%E5%8F%AF%E8%83%BD%E5%A4%9A%E7%9A%84%E8%AF%B4%E5%87%BA%E4%BD%A0%E5%AF%B9-Electron-%E7%9A%84%E7%90%86%E8%A7%A3"><span class="nav-number">1.97.</span> <span class="nav-text">尽可能多的说出你对 Electron 的理解</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%AF%B4%E8%AF%B4%E4%BD%A0%E5%AF%B9AMD%E5%92%8CCommonjs%E7%9A%84%E7%90%86%E8%A7%A3"><span class="nav-number">1.98.</span> <span class="nav-text">说说你对AMD和Commonjs的理解</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%94%A8%E8%BF%87%E5%93%AA%E4%BA%9B%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%EF%BC%9F"><span class="nav-number">1.99.</span> <span class="nav-text">用过哪些设计模式？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#offsetWidth-offsetHeight-clientWidth-clientHeight%E4%B8%8EscrollWidth-scrollHeight%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="nav-number">1.100.</span> <span class="nav-text">offsetWidth/offsetHeight,clientWidth/clientHeight与scrollWidth/scrollHeight的区别</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#javascript%E6%9C%89%E5%93%AA%E4%BA%9B%E6%96%B9%E6%B3%95%E5%AE%9A%E4%B9%89%E5%AF%B9%E8%B1%A1"><span class="nav-number">1.101.</span> <span class="nav-text">javascript有哪些方法定义对象</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%B8%B8%E8%A7%81%E5%85%BC%E5%AE%B9%E6%80%A7%E9%97%AE%E9%A2%98%EF%BC%9F"><span class="nav-number">1.102.</span> <span class="nav-text">常见兼容性问题？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BD%A0%E8%A7%89%E5%BE%97jQuery%E6%BA%90%E7%A0%81%E6%9C%89%E5%93%AA%E4%BA%9B%E5%86%99%E7%9A%84%E5%A5%BD%E7%9A%84%E5%9C%B0%E6%96%B9"><span class="nav-number">1.103.</span> <span class="nav-text">你觉得jQuery源码有哪些写的好的地方</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Node%E7%9A%84%E5%BA%94%E7%94%A8%E5%9C%BA%E6%99%AF"><span class="nav-number">1.104.</span> <span class="nav-text">Node的应用场景</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%B0%88%E8%B0%88%E4%BD%A0%E5%AF%B9AMD%E3%80%81CMD%E7%9A%84%E7%90%86%E8%A7%A3"><span class="nav-number">1.105.</span> <span class="nav-text">谈谈你对AMD、CMD的理解</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#web%E5%BC%80%E5%8F%91%E4%B8%AD%E4%BC%9A%E8%AF%9D%E8%B7%9F%E8%B8%AA%E7%9A%84%E6%96%B9%E6%B3%95%E6%9C%89%E5%93%AA%E4%BA%9B"><span class="nav-number">1.106.</span> <span class="nav-text">web开发中会话跟踪的方法有哪些</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%AF%B4%E5%87%A0%E6%9D%A1%E5%86%99JavaScript%E7%9A%84%E5%9F%BA%E6%9C%AC%E8%A7%84%E8%8C%83-1"><span class="nav-number">1.107.</span> <span class="nav-text">说几条写JavaScript的基本规范</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#JS-%E5%88%9B%E5%BB%BA%E5%AF%B9%E8%B1%A1%E7%9A%84%E5%87%A0%E7%A7%8D%E6%96%B9%E5%BC%8F"><span class="nav-number">1.108.</span> <span class="nav-text">JS 创建对象的几种方式</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#eval%E6%98%AF%E5%81%9A%E4%BB%80%E4%B9%88%E7%9A%84"><span class="nav-number">1.109.</span> <span class="nav-text">eval是做什么的</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%9C%AA%E8%A7%A3%E5%86%B3%E7%9A%84%E9%A2%98%E7%9B%AE"><span class="nav-number">2.</span> <span class="nav-text">未解决的题目</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#JS-%E6%95%B0%E5%AD%97%E5%89%8D%E8%A1%A5%E2%80%9C0%E2%80%9D"><span class="nav-number">2.1.</span> <span class="nav-text">JS 数字前补“0”</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#ts%E5%AF%B9%E6%AF%94js%EF%BC%9F"><span class="nav-number">2.2.</span> <span class="nav-text">ts对比js？</span></a></li></ol></li></ol></div>
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope="" itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="henfy" src="/images/avatar.jpg">
  <p class="site-author-name" itemprop="name">henfy</p>
  <div class="site-description" itemprop="description">技术分享的博客</div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">15</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/categories/">
          
        <span class="site-state-item-count">5</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
          
        <span class="site-state-item-count">4</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>
  <div class="links-of-author motion-element">
      <span class="links-of-author-item">
        <span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL2hlbmZ5MjMz" title="GitHub → https://github.com/henfy233"><i class="fab fa-github fa-fw"></i>GitHub</span>
      </span>
      <span class="links-of-author-item">
        <span class="exturl" data-url="bWFpbHRvOjYxOTg5OTU3M0BxcS5jb20=" title="E-Mail → mailto:619899573@qq.com"><i class="fa fa-envelope fa-fw"></i>E-Mail</span>
      </span>
  </div>
  <div class="cc-license motion-element" itemprop="license">
    <span class="exturl cc-opacity" data-url="aHR0cHM6Ly9jcmVhdGl2ZWNvbW1vbnMub3JnL2xpY2Vuc2VzL2J5LW5jLXNhLzQuMC96aF9DTg=="><img src="/images/cc-by-nc-sa.svg" alt="Creative Commons"></span>
  </div>



      </div>

      <iframe frameborder="no" border="0" marginwidth="0" marginheight="0" width="330" height="86" src="//music.163.com/outchain/player?type=2&amp;id=28234009&amp;auto=1&amp;height=66"></iframe>
        <div class="back-to-top motion-element">
          <i class="fa fa-arrow-up"></i>
          <span>0%</span>
        </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  © 2018 – 
  <span itemprop="copyrightYear">2022</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">henfy</span>
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item-icon">
      <i class="fa fa-chart-area"></i>
    </span>
    <span title="站点总字数">270k</span>
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item-icon">
      <i class="fa fa-coffee"></i>
    </span>
    <span title="站点阅读时长">4:06</span>
</div>
  <div class="powered-by">由 <span class="exturl theme-link" data-url="aHR0cHM6Ly9oZXhvLmlv">Hexo</span> &amp; <span class="exturl theme-link" data-url="aHR0cHM6Ly90aGVtZS1uZXh0Lm9yZw==">NexT.Gemini</span> 强力驱动
  </div>

        
<div class="busuanzi-count">
  <script data-pjax="" async="" src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>
    <span class="post-meta-item" id="busuanzi_container_site_uv" style="display: none;">
      <span class="post-meta-item-icon">
        <i class="fa fa-user"></i>
      </span>
      <span class="site-uv" title="总访客量">
        <span id="busuanzi_value_site_uv"></span>
      </span>
    </span>
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item" id="busuanzi_container_site_pv" style="display: none;">
      <span class="post-meta-item-icon">
        <i class="fa fa-eye"></i>
      </span>
      <span class="site-pv" title="总访问量">
        <span id="busuanzi_value_site_pv"></span>
      </span>
    </span>
</div>








      </div>
    </footer>
  </div>

  
  
  <script src="//cdn.jsdelivr.net/npm/pjax@0.2.8/pjax.js"></script>
  <script src="//cdn.jsdelivr.net/npm/jquery@3/dist/jquery.min.js"></script>
  <script src="//cdn.jsdelivr.net/gh/fancyapps/fancybox@3/dist/jquery.fancybox.min.js"></script>
  <script src="//cdn.jsdelivr.net/npm/lozad@1/dist/lozad.min.js"></script>
  <script src="//cdn.jsdelivr.net/npm/pangu@4/dist/browser/pangu.min.js"></script>
  
  











  




  
  




  














    <div id="pjax">
  

  





    </div>


<script src="/bundle.js"></script><script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
;

var pjax = new Pjax({
  selectors: [
    'head title',
    '#page-configurations',
    '.content-wrap',
    '.post-toc-wrap',
    '.languages',
    '#pjax'
  ],
  switches: {
    '.post-toc-wrap': Pjax.switches.innerHTML
  },
  analytics: false,
  cacheBust: false,
  scrollTo : !CONFIG.bookmark.enable
});

window.addEventListener('pjax:success', () => {
  document.querySelectorAll('script[data-pjax], script#page-configurations, #pjax script').forEach(element => {
    var code = element.text || element.textContent || element.innerHTML || '';
    var parent = element.parentNode;
    parent.removeChild(element);
    var script = document.createElement('script');
    if (element.id) {
      script.id = element.id;
    }
    if (element.className) {
      script.className = element.className;
    }
    if (element.type) {
      script.type = element.type;
    }
    if (element.src) {
      script.src = element.src;
      // Force synchronous loading of peripheral JS.
      script.async = false;
    }
    if (element.dataset.pjax !== undefined) {
      script.dataset.pjax = '';
    }
    if (code !== '') {
      script.appendChild(document.createTextNode(code));
    }
    parent.appendChild(script);
  });
  NexT.boot.refresh();
  // Define Motion Sequence & Bootstrap Motion.
  if (CONFIG.motion.enable) {
    NexT.motion.integrator
      .init()
      .add(NexT.motion.middleWares.subMenu)
      .add(NexT.motion.middleWares.postList)
      .bootstrap();
  }
  NexT.utils.updateSidebarPosition();
});
;

    (function(){
      var canonicalURL, curProtocol;
      //Get the <link> tag
      var x=document.getElementsByTagName("link");
		//Find the last canonical URL
		if(x.length > 0){
			for (i=0;i<x.length;i++){
				if(x[i].rel.toLowerCase() == 'canonical' && x[i].href){
					canonicalURL=x[i].href;
				}
			}
		}
    //Get protocol
	    if (!canonicalURL){
	    	curProtocol = window.location.protocol.split(':')[0];
	    }
	    else{
	    	curProtocol = canonicalURL.split(':')[0];
	    }
      //Get current URL if the canonical URL does not exist
	    if (!canonicalURL) canonicalURL = window.location.href;
	    //Assign script content. Replace current URL with the canonical URL
      !function(){var e=/([http|https]:\/\/[a-zA-Z0-9\_\.]+\.baidu\.com)/gi,r=canonicalURL,t=document.referrer;if(!e.test(r)){var n=(String(curProtocol).toLowerCase() === 'https')?"https://sp0.baidu.com/9_Q4simg2RQJ8t7jm9iCKT-xh_/s.gif":"//api.share.baidu.com/s.gif";t?(n+="?r="+encodeURIComponent(document.referrer),r&&(n+="&l="+r)):r&&(n+="?l="+r);var i=new Image;i.src=n}}(window);})();
  ;

NexT.utils.loadComments(document.querySelector('#gitalk-container'), () => {
  NexT.utils.getScript('//cdn.jsdelivr.net/npm/gitalk@1/dist/gitalk.min.js', () => {
    var gitalk = new Gitalk({
      clientID    : '95a51042662de49c617b',
      clientSecret: '4aad194349abd9bf63cee6abd3f5153ae20c50ab',
      repo        : 'henfy233.github.io',
      owner       : 'henfy233',
      admin       : ['henfy233'],
      id          : 'edd54121d7ac64aca1a7ff08533ed162',
        language: 'zh-CN',
      distractionFreeMode: true
    });
    gitalk.render('gitalk-container');
  }, window.Gitalk);
});
</script></body></html>